[{"content":"","date":null,"permalink":"/es/apps/","section":"Apps","summary":"","title":"Apps"},{"content":"","date":null,"permalink":"/es/","section":"Oscar Moreno | Desarrollador iOS ","summary":"","title":"Oscar Moreno | Desarrollador iOS "},{"content":"Aprende Swift jugando. Avanza cada día en solo unos minutos.\nQuizzySwift es un juego de preguntas divertido y eficaz que te ayuda a aprender a programar en Swift — el potente lenguaje que utilizan los desarrolladores de Apple en todo el mundo.\nTanto si estás empezando desde cero como si quieres repasar tus conocimientos, QuizzySwift hace que aprender a programar sea fácil y entretenido. Solo necesitas unos minutos al día para adquirir conocimientos reales de programación.\nAprende sin esfuerzo #Convierte sesiones cortas de práctica en avances reales en Swift — casi sin darte cuenta.\nMejora cada semana #Desarrolla habilidades sólidas con práctica diaria constante. Observa cómo aumenta tu confianza mientras subes de nivel.\nPrepárate para desafíos reales #Refuerza tus conocimientos para entrevistas, proyectos personales o tu próximo trabajo como desarrollador Swift.\nQuizzySwift es ideal para cualquiera que quiera dominar Swift de forma inteligente — mediante repetición divertida, feedback claro y resultados reales.\n","date":null,"permalink":"/es/apps/quizzyswift/","section":"Apps","summary":"QuizzySwift es un juego de preguntas divertido y eficaz que te ayuda a aprender a programar en Swift","title":"QuizzySwift"},{"content":"NSBuddy es una app exclusiva para macOS diseñada para desarrolladores Swift que quieren mejorar su eficiencia al programar y ahorrar un tiempo valioso. Tanto si eres un desarrollador con experiencia como si estás empezando, NSBuddy reúne todas las herramientas esenciales en un solo lugar, permitiéndote mantener el foco y la productividad.\nPensada específicamente para proyectos con Swift y SwiftUI, NSBuddy ofrece un conjunto de utilidades prácticas creadas para simplificar el trabajo diario de quienes desarrollan para plataformas Apple.\nPor qué elegir NSBuddy: # Gestión eficiente del disco: Elimina fácilmente archivos temporales programando o limpiando manualmente Derived Data y las previsualizaciones de Xcode, liberando espacio importante en disco.\nGeneración de código Swift: Acelera tu flujo de trabajo generando structs en Swift y consultas de Core Data directamente desde JSON u otros modelos.\nConversión de formatos sin esfuerzo: Convierte archivos JSON en modelos Swift, transforma formatos de color o genera representaciones listas para usar en código en segundos.\nCódigo más legible: Da formato y embellece automáticamente JSON para que tu código esté limpio y listo para el desarrollo.\nValidación rápida: Verifica y prueba al instante tus expresiones regulares y estructuras JSON para evitar errores antes de que ocurran.\nRecursos personalizados: Organiza tus herramientas y documentación favoritas con enlaces personalizados, accediendo rápidamente a los recursos que más utilizas.\nEspacio de trabajo a medida: Personaliza tu experiencia eligiendo solo las herramientas que necesitas, manteniendo tu entorno limpio y enfocado en lo importante.\nHaz tu proceso de desarrollo más fluido con NSBuddy, donde cada herramienta está diseñada para acompañarte en tu camino como desarrollador Swift.\nPronto en la App Store.\n","date":null,"permalink":"/es/apps/nsbuddy/","section":"Apps","summary":"NSBuddy es una app exclusiva para macOS diseñada para desarrolladores Swift que quieren mejorar su eficiencia al programar y ahorrar un tiempo valioso.","title":"NSBuddy"},{"content":"","date":null,"permalink":"/es/blog/","section":"Blog","summary":"","title":"Blog"},{"content":"Una de mis características favoritas en Swift son los enums.\nSon fáciles de entender y de utilizar.\nPero en ocasiones, no les sacamos el provecho que podríamos.\nY eso se puede conseguir (entre otras formas) con los valores asociados.\nLos valores asociados te permiten recoger valores de distintos tipos, asociados a los distintos casos de la enumeración.\nSi lo necesitas, también escribí un artículo sobre las enumeraciones\nAsí que hoy, te muestro como poder sacarles partido, y en qué ocasiones es una ventaja utilizarlos.\nCómo definir los valores asociados en tus enumeraciones #Solo debes incluir a continuación de cada caso, el tipo del valor que quieres asociar.\nPuedes definir la cantidad de valores que quieras.\nAunque, como en otros casos, no es recomendable que sea un número alto de valores.\nDe esta forma, mejorarás la legibilidad y reducirás la complejidad.\nAdemás, opcionalmente, también puedes indicar el nombre del parámetro.\nstruct User { let name: String } enum Resolution { case completed case dropped } enum State { case toDo(estimatedDate: Date) case inProgress(assignee: User) case done(time: Int) case close(Resolution) } Como puedes ver, cada caso del enum State tiene un valor asociado.\nTodos cuentan con el nombre del parámetro, excepto el caso de cierre.\nAsignar valores asociados a un caso de una enumeración #Una vez definido el enum, cuando escojas un caso, debes asignarle un valor del tipo especificado.\nlet state = State.toDo(estimatedDate: Date.now.addingTimeInterval(86400)) let state2 = State.inProgress(assignee: .init(name: \u0026#34;John\u0026#34;)) let state3 = State.done(time: 10) let state4 = State.close(.completed) Además, esto también ocurre cuando utilizar un switch para manejar las distintas situaciones.\nPero, de esta forma, el parámetro que asignas en cada caso del switch , no tiene por qué tener el mismo nombre que en la definición.\nNi estás obligado a llamar al parámetro si no lo necesitas para la gestión.\nLo puedes ver mejor en este ejemplo.\nfunc manageTask(_ task: State) { switch task { case .toDo: print(\u0026#34;Task is not started yet.\u0026#34;) case .inProgress(let assignee): print(\u0026#34;\\(assignee) is working on it\u0026#34;) case .done(var duration): duration /= 60 print(\u0026#34;Task was completed in \\(duration) hours\u0026#34;) case .close(let finalState): print(\u0026#34;Task is finished. It was \\(finalState)\u0026#34;) } } manageTask(.toDo(estimatedDate: Date.now.addingTimeInterval(172.800))) let user = User(name: \u0026#34;Erlich Bachman\u0026#34;) manageTask(.inProgress(assignee: user)) manageTask(.done(minutes: 90.0)) Como puedes ver, en el caso del toDo no se utiliza la fecha estimada de inicio, así que no necesitas recuperar ese valor.\nMientras que en los casos done y close, no coincide el nombre del parámetro de la definición, con el del switch.\nVentajas de usar tipos asociados para las enumeraciones #Mejora de la legibilidad #Sé que lo digo en muchas ocasiones, pero pasamos más tiempo leyendo código que escribiéndolo.\nAsí que mejor que esa actividad sea lo más sencilla posible.\nGracias a los valores asociados, no hace falta que crees estructuras externas con las que asociar a los casos.\nAdemás, también se mantendría más simple la jerarquía del código sin esas clases.\nMayor estabilidad #El tipado fuerte una de las mayores ventajas de Swift.\nY se refuerza con esta característica.\nDebes definir el tipo de cada valor asociado.\nY solo puedes asignar un valor de ese tipo, con lo que podrás evitar valores por un tipado incorrecto.\nAdemás, si estás usando un switch para gestionar las acciones según el caso, estás obligado a indicar todos los casos.\nY el mismo Xcode, te ayuda a añadir los valores asociados si los necesitas necesitas.\nEjemplos de uso de valores asociados #Manejo de errores #Es fácil que para complementar la información de un error, necesites datos adicionales.\nEsta información podría ser el mensaje que debes mostrar, o algo que necesites para solucionarlo.\nenum ArcadeMachineError: Error { case invalidSelection case insufficientFunds(coinsNeeded: Int) case userUnknown(user: String) } func displayError(_ error: ArcadeMachineError) { switch error { case .invalidSelection: print(\u0026#34;Invalid selection\u0026#34;) case .insufficientFunds(let coinsNeeded): print(\u0026#34;Insufficient funds. You need \\(coinsNeeded) coins\u0026#34;) case .userUnknown(let user): print(\u0026#34;User \\(user) is unknown\u0026#34;) } } displayError(.userUnknown(user: \u0026#34;pacman\u0026#34;)) Definir acciones de la vista #Las acciones que se ejecutan a raiz de la interacción del usuario, suelen requerir valores relacionados:\nenum UserAction { case login(username: String, password: String) case logout case updateProfile(name: String, age: Int) } func performAction(_ action: UserAction) { switch action { case .login(let username, let password): print(\u0026#34;Logging in with \\(username) and \\(password)\u0026#34;) case .logout: print(\u0026#34;Logging out\u0026#34;) case .updateProfile(let name, let age): print(\u0026#34;Updating profile with name: \\(name), age: \\(age)\u0026#34;) } } performAction(.updateProfile(name: \u0026#34;grogu\u0026#34;, age: 50) Modelar datos complejos #Por ejemplo, cuando tratas con elementos multimedia.\nÉstos, suelen llevar asociados distintos tipos de datos.\nCon una enumeración y valores asociados, es tan sencillo definirlo como gestionarlo.\nenum MediaType { case image(url: String, resolution: (width: Int, height: Int)) case video(url: String, duration: TimeInterval) case audio(url: String, bitrate: Int) } func handleMedia(_ media: MediaType) { switch media { case .image(let url, let resolution): print(\u0026#34;Image URL: \\(url), Resolution: \\(resolution.width)x\\(resolution.height)\u0026#34;) case .video(let url, let duration): print(\u0026#34;Video URL: \\(url), Duration: \\(duration) seconds\u0026#34;) case .audio(let url, let bitrate): print(\u0026#34;Audio URL: \\(url), Bitrate: \\(bitrate) kbps\u0026#34;) } } handleMedia(.video(url: \u0026#34;R.Astley-never_gonna_give_you_up.mp4\u0026#34;, duration: 213)) Gestionar estados #Éste es, posiblemente, el uso más extendido de los valores asociados en las enumeraciones.\nY es que, los estados de una app, suelen conllevar otro dato relacionado con el usuario, la vista que se muestra, etc\u0026hellip;\nenum AppState { case onboarding(step: Int) case loggedIn(userID: String) case loggedOut } func handleAppState(_ state: AppState) { switch state { case .onboarding(let step): print(\u0026#34;Onboarding step \\(step)\u0026#34;) case .loggedIn(let userID): print(\u0026#34;User logged in with ID \\(userID)\u0026#34;) case .loggedOut: print(\u0026#34;User logged out\u0026#34;) } } handleAppState(.onboarding(step: 1)) Filtros avanzados #Los valores asociados también pueden ser muy útiles con los filtros.\nYa que, cuando los utilizas, necesitas definir el valor de dichos filtros.\nAsí, podrás establecerlos fácilmente.\nenum Filter { case priceRange(min: Double, max: Double) case category(name: String) case availability(isInStock: Bool) } func applyFilter(_ filter: Filter) { switch filter { case .priceRange(let min, let max): print(\u0026#34;Filter by price range: \\(min) - \\(max)\u0026#34;) case .category(let name): print(\u0026#34;Filter by category: \\(name)\u0026#34;) case .availability(let isInStock): print(\u0026#34;Filter by availability: \\(isInStock ? \u0026#34;In stock\u0026#34; : \u0026#34;Out of stock\u0026#34;)\u0026#34;) } } applyFilter(.priceRange(min: 10.0, max: 20.0)) Conclusiones #Has podido ver lo sencillo que es asociar valores a los distintos casos de un enum:\nÚnicamente debes definirlos a continuación de cada caso Aprovecha el autocompletado de XCode para añadir los valores que necesites Te ayudan a tener un código más estable, legible y seguro. Como ejemplos donde los puedes utilizar tienes:\nManejo de errores Definición de acciones de la vista Modelado de datos complejos Gestión de estados Filtros avanzados Y si quieres practicar, aquí te dejo un playground con los ejemplos: enum-associated-values.playground.zip Fuente #Valores asociados de Enumeraciones - Documentación oficial de Swift\n","date":"15 octubre 2024","permalink":"/es/blog/valores-asociados-enum/","section":"Blog","summary":"Descubre cómo gestionar múltiples tipos de datos en una sola enumeración","title":"Mejora tus enumeraciones con los valores asociados"},{"content":"Hace unas semanas escribiendo sobre los key-path me llamó la atención el uso de los subscripts.\nEn español lo podríamos traducir como subíndices.\nAsí, que seguí investigando sobre ello, y como he visto las ventajas que ofrecen, te explico como aprovecharlos para tener un código más personalizado y legible.\nQué son los subscripts en Swift #Los subscripts en Swift te facilitan una forma flexible de acceder a elementos que se encuentran en colecciones, secuencias o tipos personalizados.\nEsos tipos personalizados podrían ser clases, estructuras o enumeraciones.\nOfrecen una sintaxis sencilla para establecer y recuperar valores sin necesidad de métodos separados para getters y/o setters.\nLos subscripts son métodos especiales que permiten acceder a elementos en un tipo similar a una colección.\nY para ello, se hace uso de la misma notación que los arrays. Es decir, mediante corchetes [ ].\nCómo se crean subscripts #Para crear un subscript, simplemente debes crear un método con el nombre subscript.\nsubscript(index: Index) -\u0026gt; OutputType { get { // Return a value } set(newValue) { // Set a value } } No es obligadorio usar el set, podrías simplemente devolver el valor, por lo que tampoco sería necesario indicar explícitamente el get.\nsubscript(index: Index) -\u0026gt; OutputType { // Return a value } Cómo acceder a elementos mediante subscripts en Swift #Siguiendo la sintaxis explicada, aquí puedes ver como crear un método subscript para una estructura que te devuelva el elemento que le pidas de la secuencia Fibonacci.\nstruct Fibonacci { subscript(position: Int) -\u0026gt; Int { guard n \u0026gt; 1 else { return n } var a = 0, b = 1 for _ in 2...n { let temp = a + b a = b b = temp } return b } } Como ves, al método subscript, se le puedes pasar un parámetro position para saber la posición del elemento que quieres obtener.\nComo también puedes comprobar, no necesitas un setter para establecer un valor.\nAsí que si le indicas la posición que quieres, podrás tener el valor de esa posición.\nlet fib = Fibonacci() // Prints \u0026#34;13\u0026#34; print(fib[7]) Subscripts con múltiples parámetros #Los subscripts pueden tomar múltiples parámetros, permitiendo formas de acceso más complejas.\nAquí puedes ver un ejemplo de una estructura para formar un cubo en 3D.\nstruct Cube3D { private var cells: [[[Int]]] let size: Int init(size: Int, defaultValue: Int = 0) { self.size = size self.cells = Array(repeating: Array(repeating: Array(repeating: defaultValue, count: size), count: size), count: size) } subscript(x: Int, y: Int, z: Int) -\u0026gt; Int { get { guard isValidIndex(x: x, y: y, z: z) else { fatalError(\u0026#34;Index out of range\u0026#34;) } return cells[x][y][z] } set { guard isValidIndex(x: x, y: y, z: z) else { fatalError(\u0026#34;Index out of range\u0026#34;) } cells[x][y][z] = newValue } } subscript(xRange: Range\u0026lt;Int\u0026gt;, yRange: Range\u0026lt;Int\u0026gt;, z: Int) -\u0026gt; [[Int]] { guard isValidRange(xRange: xRange, yRange: yRange, z: z) else { fatalError(\u0026#34;Range out of cube bounds\u0026#34;) } return xRange.map { x in yRange.map { y in cells[x][y][z] } } } private func isValidIndex(x: Int, y: Int, z: Int) -\u0026gt; Bool { return x \u0026gt;= 0 \u0026amp;\u0026amp; x \u0026lt; size \u0026amp;\u0026amp; y \u0026gt;= 0 \u0026amp;\u0026amp; y \u0026lt; size \u0026amp;\u0026amp; z \u0026gt;= 0 \u0026amp;\u0026amp; z \u0026lt; size } private func isValidRange(xRange: Range\u0026lt;Int\u0026gt;, yRange: Range\u0026lt;Int\u0026gt;, z: Int) -\u0026gt; Bool { return xRange.lowerBound \u0026gt;= 0 \u0026amp;\u0026amp; xRange.upperBound \u0026lt;= size \u0026amp;\u0026amp; yRange.lowerBound \u0026gt;= 0 \u0026amp;\u0026amp; yRange.upperBound \u0026lt;= size \u0026amp;\u0026amp; z \u0026gt;= 0 \u0026amp;\u0026amp; z \u0026lt; size } } Tras los parámetros y el inicializador, cuenta con dos métodos subscript.\nEl primero toma tres parámetros de posición, para determinar el lugar en el cubo 3D, y tiene tanto un getter como un setter.\nEl segundo también toma varios parámetros, de tipo Range.\nEste segundo subscript, permitiría obtener una porción en 2D, del cubo.\nComo estás tratando con colecciones y secuencias, es muy importante comprobar que nunca se accede a posiciones fuera del índice para evitar crashes. Por eso los métodos isValidIndex e isValidRange. Y ahora, podrás asignar y recuperar los valores del cubo.\nvar cube = Cube3D(size: 5, defaultValue: 0) cube[0, 0, 0] = 1 cube[1, 2, 3] = 5 cube[4, 4, 4] = 9 // Prints \u0026#34;1\u0026#34; print(cube[0, 0, 0]) // Prints \u0026#34;5\u0026#34; print(cube[1, 2, 3]) // Prints \u0026#34;9\u0026#34; print(cube[4, 4, 4]) let slice = cube[0..\u0026lt;2, 0..\u0026lt;3, 0] // Prints [[1, 0, 0], [0, 0, 0]] print(slice) Subscripts de Tipo #También puedes definir subscripts en el tipo mismo, en lugar de en las instancias.\nPara ello, simplemente indica la palabra clave static antes de subscript, de igual forma que harías cualquier método estático.\nenum DayOfWeek: Int { case monday = 1 case tuesday case wednesday case thursday case friday case saturday case sunday static subscript(index: Int) -\u0026gt; DayOfWeek? { return DayOfWeek(rawValue: index) } } Y ahora, si quieres acceder a cualquier día de la semana de la enumeración, solo debes indicar su índice.\n// day is equal to .wednesday let day = DayOfWeek[3] Fíjate que al lunes se le ha asignado 1 ya que, al menos en España, el lunes es el primer día de la semana. Y queda más natural acceder a él de esa forma. Si no se hubiera indicado, en el ejemplo anterior, day sería igual a thursday y al caso monday se accedería a través del índice 0. Conclusiones #Resumiendo, sobre los subscripts, los puntos más importantes:\nProporcionan acceso abreviado a elementos de colecciones. Se pueden usar tanto para obtener, como para establecer valores. Se pueden definir múltiples subscripts para un solo tipo. Los subscripts pueden tener múltiples parámetros de entrada. Puedes crear subscripts estáticos que no pertenecen a la instancia sino al tipo. Pero, ten en cuenta lo siguiente para aprovecharlos al máximo:\nÚsalos cuando te faciliten una sintaxis más natural para acceder a elementos en tus tipos personalizados. Recuerda manejar los errores y verificar los límites en los subscripts. Asegúrate cuando debes utilizar subscripts de solo lectura o de lectura/escritura. Usa subscripts de tipo únicamente cuando tenga sentido acceder a valores directamente en el tipo en lugar de en las instancias. Y como es habitual, te dejo el playground para que practiques. Subscripts.playground.zip Sources #Subscripts - Documentación oficial de Swift\n","date":"8 octubre 2024","permalink":"/es/blog/subscripts-en-swift/","section":"Blog","summary":"Los subscripts te permiten acceder de forma más flexible y personalizada a distintos datos","title":"Accede a elementos de colecciones de forma sencilla"},{"content":"A medida que la complejidad de los proyectos crecen, es habitual crear código muy similar.\nYa sabes que la mejor forma de optimizarlo es no repetirlo.\nO al menos, aprovechar los puntos comunes.\nPues para ese caso te puede ser de gran ayuda utilizar genéricos.\nPueden parecer complejos al principio.\nPero si te acostumbras a usarlos, tendrás un código más limpio y reutilizable.\n¿Por qué usar los genéricos en Swift? #Imagina que tienes un método tan sencillo como el siguiente que muestra un mensaje con un valor que pasas como parámetro.\nfunc logString(value: String) { print(\u0026#34;INFO - Value recorded: \\(value)\u0026#34;) } // Prints \u0026#34;INFO - Value recorded: RandomResult\u0026#34; logString(value: \u0026#34;RandomResult\u0026#34;) Pero ¿y su necesitas pasar también un valor de tipo entero?\nEse método también sería sencillo.\nfunc logInt(value: Int) { print(\u0026#34;INFO - Value recorded: \\(value)\u0026#34;) } // Prints \u0026#34;INFO - Value recorded: 10\u0026#34; logInt(value: 10) Pero, cómo seguramente te has dado cuenta, es prácticamente igual que el primero.\nAdemás ¿y si quisieras capturar valores del resto de tipos de datos? Double, Bool, Float\u0026hellip;\nPosiblemente, ya has adivinado el problema que esto te puede traer.\nHabría una cantidad importante de código duplicado, y por lo tanto, ineficiente.\nEste es el problema que resuelven los genéricos.\nPermiten crear funciones y tipos, que trabajen con distintos tipos sin tener que repetir código tan similar.\n¿Cómo se crean los genéricos en Swift? #Swift te permite crear tanto funciones genéricas, como tus propios tipos genéricos.\nNombres de parámetros de tipos #Antes de crear genéricos, es importante entender como nombrarlos.\nAunque no te hayas dado cuenta, ya has utilizado los genéricos previamente.\nComo por ejemplo, cuando has utilizado un array, que se define como Array\u0026lt;Element\u0026gt;.\nSiendo Element cualquier tipo que componga el array: String, Int, Double\u0026hellip;\nLo mismo ocurre con los diccionarios, ya que en este caso se definen como Dictionary\u0026lt;Key, Value\u0026gt;.\nPor eso los diccionarios trabajan con dos elementos: una clave y un valor.\nEn algunos casos, se usan este tipo de nombres descriptivos en los genéricos: Element, Key, Value\u0026hellip;\nPero en otros, cuando no hay una relación que tenga sentido, se suele usar simplemente una letra mayúscula.\nLa convención, en este último caso, es usar T, U o V.\n¿Y si necesitas más? Bueno, en ese caso\u0026hellip; igual deberías revisar ese código para evitar tantos parámetros 😉\nFunciones genéricas #Tomando el ejemplo anterior sobre mensajes de log, podrías crear una función genérica de la siguiente forma:\nfunc log\u0026lt;T\u0026gt;(value: T) { print(\u0026#34;INFO - Value recorded: \\(value)\u0026#34;) } La primera diferencia, es sustituir el tipo de los parámetros de entrada de la función.\nEs decir, el tipo del parámetro value es T, en lugar de String o Int.\nT se refiere a cualquier tipo de Swift.\nY la segunda diferencia, es incluir a continuación del nombre de la función, el tipo genérico que se va a utilizar, entre los signos \u0026lt; y \u0026gt;.\nTipos genéricos #Los genéricos no se limitan solo a las funciones.\nImagina que quieres crear un almacen para guardar valores de tipo String.\nPodría ser una estructura como la siguiente:\nstruct StringsStore { var content: [String] mutating func add(string: String) { content.append(string) } mutating func clear() { content.removeAll() } } Pero de nuevo, tendrías la limitación anterior si quisieras aceptar también enteros.\nAsí que, como en el caso de las funciones, habría que sustituir el tipo de los parámetros, usando por ejemplo Element.\nY a continuación del nombre del tipo, es donde incluirías el tipo con los signos\u0026lt;Element\u0026gt;.\nstruct ValuesStore\u0026lt;Element\u0026gt; { var content: [Element] mutating func add(value: Element) { content.append(value) } mutating func clear() { content.removeAll() } } Y ahora sí, puedes usarlo con distintos tipos:\nvar intsStore = ValuesStore(content: [2,4,5]) intsStore.add(value: 10) // Prints \u0026#34;[2, 4, 5, 10]\u0026#34; print(intsStore.content) var doublesStore = ValuesStore(content: [2.5, 4.7, 5.8]) doublesStore.add(value: 4.7) // Prints \u0026#34;[2.5, 4.7, 5.8, 4.7]\u0026#34; print(doublesStore.content) Extensiones de genéricos #Puedes crear también extensiones de tipos genéricos.\nY no necesitas indicar de nuevo el tipo de parámetro.\nEs decir, puedes usar el mismo de su definición.\nEn el caso de ValuesStore, sería de la siguiente forma:\nextension ValuesStore { var lastElement: Element? { content.last } } // Prints \u0026#34;10\u0026#34; print(intsStore.lastElement ?? \u0026#34;Empty store\u0026#34;) Limitar los genéricos con Where #Pueden haber situaciones donde necesites hacer un genérico para varios tipos\u0026hellip; pero no para todos los tipos.\nImagina el siguiente caso:\nfunc sumTwoValues\u0026lt;T\u0026gt;(valueA: T, valueB: T) -\u0026gt; T { // ERROR: Binary operator \u0026#39;+\u0026#39; cannot be applied to two \u0026#39;T\u0026#39; operands valueA + valueB } En el ejemplo anterior, podrías usar enteros, dobles, o cualquier tipo de número, ya que se va a realizar una suma.\nPero no podrías pasar dos valores Bool porque no pueden sumarse.\n¿Solución? Restringir T para que solo puedan ser tipos que conformen el protocolo Numeric.\nPara ello, simplemente usa la claúsula where, para indicar los tipos de T.\nfunc sumTwoValues\u0026lt;T\u0026gt;(valueA: T, valueB: T) -\u0026gt; T where T: Numeric { valueA + valueB } Y ahora sí, podrías ejecutar las operaciones que desearas.\n// Returns 7 sumTwoValues(valueA: 2, valueB: 5) // Returns 31.1 sumTwoValues(valueA: 10.5, valueB: 20.6) Usar múltiples genéricos #En los ejemplos anteriores, has visto como usar un tipo genérico: T, o Element.\nLo que significa que podía admitir cualquier tipo, pero con la limitación que, dicho tipo siempre fuera el mismo.\nEn el ejemplo anterior, en que se sumaban dos valores, podrías sumar dos enteros, o dos dobles, etc\u0026hellip; Pero siempre, el mismo valor\nUsar varios tipos, es muy sencillo, simplemente debes declarar otros tipos genéricos, separándolos por comas. Y teniendo en cuenta el estándar de nombres mencionado antes.\nAquí tienes otro ejemplo:\nfunc displayTemp\u0026lt;City,Temp\u0026gt;(city: City, temp: Temp) where City: StringProtocol, Temp: Numeric { print(\u0026#34;\\(city):\\(temp)\u0026#34;) } El código anterior no es óptimo, ya que se podría simplificar si los parámetros conformaran los protocolos StringProtocol y Numeric (displayTemp(city: String, temp: any Numeric)) pero se ha usado para mostrar un ejemplo sencillo. Y ya podrías usar distintos tipos de genéricos\n// Prints \u0026#34;Valencia:20\u0026#34; displayTemp(city: \u0026#34;Valencia\u0026#34;, temp: 20) // Prints \u0026#34;Munich:5.5\u0026#34; displayTemp(city: \u0026#34;Munich\u0026#34;, temp: 5.5) Conclusiones #Así que resumiendo lo más importante:\nDebes utilizar genéricos para unificar código muy similar que realice operaciones con distintos tipos Puedes usarlos en funciones o en tipos Puedes utilizar: Palabras como Element, Key o Value si tienen relación que tenga sentido. Letras como T, U o V para casos más abrastactos. Si quieres acotar los tipos de un genérico, usa la cláusula where para especificar un protocolo. Si solo indicas un tipo genérico, siempre deberás usar siempre el mismo tipo en la función o tipo. Y si quieres practicar, te dejo aquí el playground con ejemplos 🙂\ngenerics-swift.playground.zip Fuente #Genéricos - Documentación de Swift\n","date":"1 octubre 2024","permalink":"/es/blog/genericos-swift/","section":"Blog","summary":"Los genéricos en Swift permiten utilizar código muy similar para operaciones con distintos tipos","title":"Optimizar código en Swift gracias a los genéricos"},{"content":"La pasada semana pude asistir a un evento que significaba mucho para mí y al que tenía muchas ganas de asistir por primera vez.\nAntes de ir, pregunté a las distintas personas que conocía y habían estado en años anteriores.\nAún así, lo que pude ver superó mis expectativas.\nAsí que hoy, te cuento cómo lo viví y por qué pienso que deberías ir si te interesa el desarrollo para entornos Apple.\nNo sin antes dar las gracias a hiberus, que ha hecho posible que varios compañeros del equipo iOS hayamos podido asistir.\nUn poco de historia #NSSpain ha sido un evento notable en el calendario de los desarrolladores Apple desde su inicio en 2013.\nCreado por Luis Ascorbe y Borja Reinares el evento ya ha completado su decimosegunda edición y todo apunta (y espero) a que le quedan muchas más.\nA lo largo de los años, ha ganado popularidad, no solo en España, sino a nivel internacional.\nSu ambiente colaborativo ha sido clave para construir una comunidad tan importante y cercana dentro del ecosistema Apple.\nNSSpain 2024 #La edición de 2024 se celebró del 17 al 19 de septiembre en Logroño, atrayendo a profesionales de todo el mundo para compartir experiencias y aprender sobre las últimas novedades en el desarrollo de iOS, macOS, watchOS y tvOS.\naaand we are open!@NSSpain XII, our 12th edition 🏴‍☠️ #nsspain2024 pic.twitter.com/sPAfM2Yvhd\n\u0026mdash; NSSpain XII (@NSSpain) September 18, 2024 A punto ya de empezar en #NSSpain pic.twitter.com/y2rIIxiU4Q\n\u0026mdash; Óscar Moreno (@oscarmorenodev) September 18, 2024 Otro hecho que en mi opinión favorece su éxito es la fecha elegida.\nTras una reciente WWDC con novedades y el lanzamiento de la nueva versión de iOS, es accesible iniciar nuevas conversaciones o charlas.\nOrganización #Este año, los talleres (opcionales, a los que no pude asistir) se realizaron el 17 de septiembre, y las conferencias principales tuvieron lugar los días 18 y 19.\nDesde el primer momento se nota que los organizadores se han preocupado por crear un entorno acogedor, promoviendo un espacio para la colaboración y el intercambio de ideas.\nAdemás, se han cuidado detalles para que en los descansos, desplazamientos y horarios, tengas todo lo que necesites y en el menor tiempo posible.\nEjemplos de ello son pedir un café en el break, a penas sin hacer cola, hasta la facilidad para desplazarnos a la bodega.\nLa calidad de los ponentes fue notable también, contando con expertos que aportaron tanto conocimientos técnicos como su visión del futuro del desarrollo Apple.\nCharlas #Las charlas ofrecieron un enfoque profundo sobre tecnologías como Swift, SwiftUI, Testing y Vision Pro.\nSe discutieron arquitecturas de software, accesibilidad y seguridad, proporcionando las herramientas necesarias para mejorar las aplicaciones.\nEn las charlas hubieron enfoques de todo tipo, desde más divertidos, hasta más inspiradores o reflexivos.\nLas sesiones también destacaron por su diversidad temática, asegurando que tanto desarrolladores principiantes como experimentados pudieran llevarse algo valioso.\nNo voy a hablar en detalle de las charlas, ni revelaré los aspectos técnicos, ya que se publicarán en el canal de Vimeo de NSSpain, y te recomiendo verlas.\nPero sí que quiero darte algunas claves que me parecieron importantes. Tanto desde el punto técnico de desarrollo Apple, como si quieres dar charlas en este tipo de eventos.\nTampoco te cuento aquí sobre todas las charlas, no significa que las no están no fueran interesantes, pero extendería demasiado el artículo.\nAsí que cuando te recomiendo que las veas, te recomiendo que sean todas, y que tú decidas las que más te gustaron.\nPreparing Your App For Apple Intelligence - Matthew Cassinelli #Fue la primera de las charlas. Tenia bastante interés en ella porque Apple Intelligence es una novedad muy importante para mí a la que auguro (con el tiempo) un gran potencial.\nMathew planteó una clave importante: Diseña para Apple Intelligence no para Siri Shortcuts.\nSo You Think You Know Swift? - Nick Lockwood #La expectación de la segunda charla era alta, su título (So You Think You Know Swift?) planteaba un importante reto.\nSi planteas esta pregunta en un evento lleno de desarrolladores Apple, o traes algo bueno, o pierdes credibilidad, y Nick no defraudó.\nNos ofreció una charla muy técnica con una recopilación de trucos para escribir código más eficiente, muy bien organizada por las distintas características del lenguaje.\nBroken isolation - draining your credentials from popular macOS password managers - Wojciech Reguła #La siguiente charla, confieso que en principio no era una de las que más esperaba ver.\nPero Wojciech la llevó de una forma excelente, haciéndola fácil de seguir, y con un resultado sorprendente.\nNo me esperaba ver lo que enseñó y cómo las aplicaciones más populares de gestión de contraseñas en macOS guardan las contraseñas.\nCreeme, te sorprenderá.\nGetting the most from Swift Macros - Daniel Steinberg #Otra charla destacada fue la de Daniel Steinberg, quien cuenta con un importante número de libros publicados sobre desarrollo con Swift en Editors Cut\nDaniel planteó la cuestión sobre si debemos crear nuestras propias macros. Y viendo su charla tengo clara la respuesta 😂, así que tú tampoco te la pierdas.\nFue envidiable como supo mostrar los entresijos de las Macros.\nY aunque son complejos, conocerlos es imprescindibles para aprovechar todo su potencial.\nTraining, Using, Distributing and Managing Machine Learning models for your iOS app - Felix Krause #Alguien que también levantó mucha expectación fue Felix Krause, fundador de fastlane, la herramienta open source utilizada en numerosos proyectos iOS y Android para construir y desplegar.\nY no solo eso, porque ahora está inmerso en el proyecto ContextSDK, que descubre la mejor manera de monetizar tus usuarios por medio de inteligencia artificial.\nAsí que como apasionado de la tecnología, y cada vez más de la IA, es una suerte poder escuchar a Felix cómo enfocar un negocio basado en el ML para conseguir la información que necesitan tus usuarios.\nSin duda un ejemplo inspirador sobre cómo aprovechar la tecnología para aportar valor a tus usuarios.\nChasing Fun: Creating a Career You Love - Michael Flarup #Una charla que también me impactó positivamente fue la de Michael Flarup.\nTenía muchas ganas de escucharle, porque el desarrollo profesional es otro de los campos que me interesan.\nMichael es un ejemplo de cómo dar una charla en este tipo de eventos, no solo por lo que nos contó, sino sobretodo por CÓMO lo contó.\nY es que supo captar la atención en todo momento, mezclando su recorrido profesional con momentos muy divertidos, destacando la importancia de trabajar en aquello que amas y seguir avanzando sin decaer.\nAdemás, al estar más centrado en diseño, me ha sentir más curiosidad por sus libros sobre iconos para apps\nBest-in-class Pull Request - Danijela Vrzan #También tenía ganas de ver a Danijela.\nDesde hace un tiempo sigo su blog, en el que ofrece recursos muy interesantes, no solo de Swift, sino también de desarrollo en general o diseño.\nDanijela habló de un tema tan práctico como las PRs, y mostró de forma sencilla las diferencias entre una buena PR y otra que no lo es.\nHay que tener en cuenta que una Pull Request no solo afecta a quien la crea, sino también a quien la revisará o quién la tomará como ejemplo.\nDestacaría el ejemplo que dio sobre como afrontar las PRs de gran de tamaño.\nTest your apps! How testing can make you more efficient and what are best practices for maintainable tests - Krzysztof Zablocki #El segundo día empezó fuerte (y no por el vino de la noche anterior en la bodega 😉)\nEmpezó hablando Krzysztof Zablocki, alguien que ha desarrollado librerías y herramientas utilizadas en Apple, Disney, Airbnb, The New York Times o Vinted.\nY si con ese portfolio se añade que el tema es testing, tenía toda mi atención.\nKrzysztof nos enseñó las mejores prácticas que ha aprendido a lo largo de este tiempo para hacer tests, poniendo énfasis en que sean mantenibles.\nLo que sin duda nos puede ahorrar mucho tiempo.\nLo que me pareció mas importante es que planteó en varias ocasiones la importancia de probar implementaciones, no comportamientos.\nAccessibility and the Vision Pro - Robin Kanatzar #Si te interesa la accesibilidad (y debería interesarte) tampoco puedes perderte la charla de Robin.\nTe vendrá genial una buena base, pero si no la tienes, no te preocupes, lo explica muy bien y es fácil de seguir.\nExplicó las diferencias y novedades con las que contamos en este campo, para el nuevo dispositivo de computación espacial.\nY es que, en este nuevo hardware, hay muchos detalles que aún no tenemos en cuenta.\nDetalles que pueden marcar la diferencia en la experiencia que tengan los usuarios que utilicen características de accesibilidad.\nSwift Server-Side. The Apple Last Frontier - Adolfo Vera #Otra de las charlas que también me gustó mucho fue la de Adolfo con el que, aunque había escrito por RRSS previamente, conocí allí por primera vez.\nAdolfo habló sobre Vapor, un herramienta para mí todavía infravalorada, y que aporta muchas ventajas a los desarrollos de aplicaciones, especialmente para Apple.\nNos ofreció una visión general de qué podemos hacer, y cual es la mejor manera, facilitando consejos que serán de gran ayuda para tus primeros desarrollos con Vapor.\nPero sin duda, destacaría como supo captar la atención del público a lo largo de la charla 🙂.\nUna charla muy divertida y recomendable.\nThe Date-ing Game - Ellen Shapiro #Ellen también trajo una charla muy interesante, aunque el tema no lo pudiera parecer en un primer momento: las fechas.\nFue también muy ameno y divertido seguir la charla y descubrir la cantidad de elementos que podemos (y debemos) tener en cuenta a la hora de trabajar con fechas.\nEspecialmente si debemos trabajar con varios formatos.\nImprescindible si es tu caso.\nWarp Speed with Metal Performance Shaders - Francesco Marini #Francesco nos regaló una masterclass sobre el hardware de Apple y cómo aprovecharlo para mejorar el rendimiento gráfico de juegos o apps.\nFue una charla muy profunda, que sin duda volveré a ver (poniendo el video en pausa por momentos 😅) para poder profundizar y buscar información relativa.\nMucha información y de calidad.\nMuy importante también verla si trabajas con gráficos.\n“It Scrolls Like Butter” Part 2: Implementing High Performance Scrolling in Threads - Tim Oliver #También levantó gran expectación la charla de Oliver, y es que no todos los días puedes ver en directo a un ingeniero iOS en Instagram.\nY si hay algo que haces en Instagram, es el scroll.\nAsí que fue genial escuchar tantos detalles, y de una forma tan divertida y amena, que mejoran sin duda la experiencia del usuario.\nBuilding amazing user experiences using SharePlay - Vanessa Furtado #Finalizando el segundo día, me sorprendió muy gratamente la charla de Vanesa.\nHasta ese momento, pensaba que SharePlay se limitaba a compartir video y audio.\nPero nos mostró como lo aprovechan en iFood.\nAdemás de hacer la charla muy interesante, fue creativa y estoy seguro que a mas de uno (como a mí) le ha traído nuevas ideas para su desarrollo.\nSoftware engineer or code craftsman - Michael Fletcher #Y para cerrar el evento, Michael trajo una interesante cuestión: ¿Ingeniero de software o artesano de código.\nMostrando ejemplos y comparaciones de la vida real, nos invitó a pensar sobre lo que hacemos y lo que nos gustaría hacer.\nOne more thing #He dicho ya en varios momentos que me gustó no solo por el nivel técnico, sino también por lo que me divertí.\nY uno de esos momentos especiales fue cuando pudimos aprender cómo coger correctamente una copa y probar el vino 😂\nNo sé si saldrá en los videos, pero desde luego lo merece.\nwe got @facumenzella and @nyeeu hijacking (a bit) the schedule to learn how to properly hold and tate a glass of wine 🍷 #NSSpain2024 pic.twitter.com/IsP8EYU6An\n\u0026mdash; NSSpain XII (@NSSpain) September 18, 2024 No todo es código #NSSpain 2024 no fue solo un espacio para aprender sobre tecnología, sino también para conectar con la comunidad.\nEl networking fue un componente esencial, y las actividades sociales trajeron la oportunidad de conocer a otros profesionales de manera más distendida.\nUna de las experiencias también más enriquecedoras fue la visita a una bodega el día 18 de septiembre, donde después de las ponencias, pudimos aprender detalles sobre la producción y almacenamiento de vino, seguidos de una cena tipo cóctel que abrió más oportunidades de conversación y colaboración.\nVisita a la bodega pic.twitter.com/959T2BDFVi\n\u0026mdash; Óscar Moreno (@oscarmorenodev) September 18, 2024 Además, durante las noches, la mayoría de los asistentes se reunían en la famosa Calle Laurel y sus alrededores, un lugar conocido por su ambiente animado y su gastronomía (destacando los pinchos y el vino 🍷).\nEstas salidas nocturnas permitieron seguir compartiendo ideas en un entorno más informal.\nAdemás, la visita a Logroño en estas fechas tuvo un atractivo añadido, y es que el día 20 de septiembre comenzaron las fiestas locales, creando un ambiente festivo que potenció la experiencia del evento.\nPor qué deberías ir a la próxima NSSpain #NSSpain sigue siendo una de las mejores oportunidades para desarrolladores de Apple que buscan mejorar sus habilidades.\nAprender de expertos y construir relaciones profesionales sólidas es imprescindible si te preocupa tu desarrollo profesional.\nTanto desde el punto de vista técnico como humano, el evento se supera a sí mismo.\nOfrece no solo contenido técnico valioso, sino también una comunidad fuerte y accesible.\nNo hay duda de que futuras ediciones continuarán siendo un punto de referencia en el calendario de desarrolladores Apple a nivel internacional.\nSi buscas mejorar en tu carrera como desarrollador, aprender de los mejores y ampliar tu red de contactos, NSSpain es la conferencia a la que debes asistir.\nConclusiones #NSSpain 2024 demostró una vez más por qué es un evento imperdible para los desarrolladores de Apple, no solo de España.\nSe ha convertido en un referente internacional donde es importante que vayas si quieres: aprender, conectar con otros profesionales y divertirte (no necesariamente en ese orden 😉)\n","date":"24 septiembre 2024","permalink":"/es/blog/nsspain-2024-es/","section":"Blog","summary":"NSSpain es una conferencia internacional de ingeniería Apple muy especial","title":"Por qué deberías ir a NSSpain"},{"content":"Los key-path son una característica de Swift que resultan confusas al principio.\nPero, con la llegada de SwiftUI, se ha extendido su uso.\nY su uso, no solo se limita al nuevo framework para las interfaces.\nConocerlo, te puede ayudar con alternativas para acceder a datos de los tipos.\nEscribir una expresión Key-Path #Las expresiones de ruta clave o key-path tienen esta estructura\n\\\u0026lt;#type name#\u0026gt;.\u0026lt;#path#\u0026gt;\nEl type name, es el nombre concreto de un tipo (estructura, clase, enumeración\u0026hellip;) incluyendo tipos básicos como Int, [String] o Set\u0026lt;Double\u0026gt;.\nEl path, puede contener una propiedad, un subcript, u opcionales.\nCuando se compila, la expresión key-path se reemplaza por una instancia de la clase KeyPath Acceder a un valor usando un Key-Path #Así que, si quieres acceder a un valor de ruta clave, puedes hacerlo a través del subscript que pide un key-path, y que está disponible para todos los tipos\nstruct Driver { var name: String } let driver = Driver(name: \u0026#34;Fernando Alonso\u0026#34;) let pathToNameProperty = \\Driver.name let driverName = driver[keyPath: pathToNameProperty] print(driverName) // Prints \u0026#34;Fernando Alonso\u0026#34; Ten en cuenta, que el type name se puede omitir cuando la inferencia de tipos pueda saber el tipo que espera.\nstruct Race { var winner: Driver func displayWinnerProperty(keypath: KeyPath\u0026lt;Driver, String\u0026gt;) { print(\u0026#34;The winner is \\(winner[keyPath: keypath])\u0026#34;) } } let sai = Driver(name: \u0026#34;Carlos Sainz\u0026#34;) let race = Race(winner: sai) race.displayWinnerProperty(keypath: \\.name) // Prints \u0026#34;The winner is Carlos Sainz\u0026#34; Key-Path de identidad #Además, el path puede hacer referencia a self, en lo que se conoce como key-path de identidad (\\.self)\nEl key-path de identidad se refiere a la instancia en sí.\nGracias a eso, puede ser util para cambiar por ejemplo una instancia entera con una línea.\nvar verstappenPoints = (a: 25, b: 18, c:25) // Equivalent to verstappenPoints = (a: 18, b: 25, c: 25) verstappenPoints[keyPath: \\.self] = (a: 18, b: 25, c: 25) print(verstappenPoints) // Prints \u0026#34;(a: 18, b: 25, c: 25)\u0026#34; Pero donde se suele aprovechar esta característica es en SwitUI, por ejemplo, en un ForEach\nList { ForEach([2, 4, 6, 8, 10], id: \\.self) { Text(\u0026#34;\\($0) is even\u0026#34;) } } Acceder a múltiples valores de un tipo #Otra de sus características es que es posible acceder a propiedades anidadas.\nEs decir, hacer referencia a la propiedad del valor de una propiedad.\nPuedes ver un ejemplo a continuación\nstruct Championsip { var winner: Driver init(winnerName: String) { self.winner = Driver(name: winnerName) } } let champion = Championsip(winnerName: \u0026#34;Max Verstappen\u0026#34;) let nestedKeyPath = \\Championsip.winner.name let championName = champion[keyPath: nestedKeyPath] print(championName) // Prints \u0026#34;Max Verstappen\u0026#34; Acceder a subscripts #Otra posibilidad que existe es que el path incluya subscripts usando corchetes.\nlet tracks = [\u0026#34;Spa\u0026#34;, \u0026#34;Monza\u0026#34;, \u0026#34;Montmelo\u0026#34;, \u0026#34;Suzuka\u0026#34;] let fasterTrack = tracks[keyPath: \\[String].[1]] print(fasterTrack) // Prints \u0026#34;Monza\u0026#34; En este caso es imprescindible que el tipo del parámetro del subscript cumpla con el protocolo Hashable Además, debes tener en cuenta que en este caso, los valores capturados usan la semántica por valor, en lugar de por referencia.\nPor lo que una copia, no actualizará su propio valor, aunque modifiques el original.\nPuedes verlo más claro en el siguiente ejemplo\nvar index = 1 let pathToTrack = \\[String].[index] let closure: ([String]) -\u0026gt; String = { strings in strings[index] } print(tracks[keyPath: pathToTrack]) // Prints \u0026#34;Monza\u0026#34; print(closure(tracks)) // Prints \u0026#34;bonjour\u0026#34; index += 1 print(tracks[keyPath: pathToTrack]) // Prints \u0026#34;Monza\u0026#34; // Because \u0026#39;fn\u0026#39; closes over \u0026#39;index\u0026#39;, it uses the new value print(closure(greetings)) // Prints \u0026#34;Spa\u0026#34; Acceder a valores opcionales #Para acceder a valores opcionales, simplemente tienes que hacer uso del encadenamiento de opcionales, o forzar el desempaquetado.\nlet firstTrack: String? = tracks.first let count = tracks[keyPath: \\[String].first?.count] print(count as Any) // Prints Montmelo characters number \u0026#34;Optional(8)\u0026#34; Key-Path como alternativa a closures y funciones #También puedes usar los key-path en otros contextos.\nPor ejemplo, en los que tienes que pasar una función o un closure.\nstruct Lap { var time: Double var valid: Bool } var timelaps = [ Lap(time: 106.0, valid: true), Lap(time: 99.5, valid: true), Lap(time: 102.0, valid: false) ] // Usual let validLaps1 = timelaps.filter{ $0.valid } print(validLaps1.count) // Prints \u0026#34;2\u0026#34; // Equivalent with key-paths let validLaps2 = timelaps.filter(\\.valid) print(validLaps2.count) // Prints \u0026#34;2\u0026#34; Fijate como al final del ejemplo, puedes filtrar las vueltas válidas con .filter(\\.valid) en lugar de con el habitual .filter{ $0.valid }.\nÁmbito de los Key-Path #Por último, en relación a los key-path, hay algo importante que debes tener en cuenta.\nLos resultados de una expresión key-path solo se evaluan en el punto en el que dicha expresión se evalua. Si llamas a una función dentro de un subscript en una expresión key-path, la función se llamará solo una vez, como parte de la evaluación de la expresión, pero no siempre que se use el key-path.\nPuedes verlo en este ejemplo:\nfunc displayValidLap() -\u0026gt; Int { print(\u0026#34;Valid lap!\u0026#34;) return 0 } let greetingKeyPath = \\[Lap][displayValidLap()] // Prints \u0026#34;Valid lap!\u0026#34; // Using greetingKeyPath doesn\u0026#39;t call displayValidLap again. let someLap = timelaps[keyPath: greetingKeyPath] Conclusión #Los key-path son complejos, y es una característica que cuesta ver su utilidad.\nNo obstante, son utilizados en SwiftUI, por lo que es importante conocerlos y entenderlos.\nLo más importante, recuerda que:\nSu estructura es \\\u0026lt;#type name#\u0026gt;.\u0026lt;#path#\u0026gt;. El type name es el nombre del tipo y el path es el nombre de la propiedad de dicho tipo. Cuando se compila, se reemplaza por una instancia de la clase KeyPath Puedes acceder a Un parámetro Una instancia completa (\\.self) Un subscript Un valor opcional Y como la práctica hace el maestro, te dejo un playground para que puedas jugar 😉\nkey-paths-swift.playground.zip Fuente #Expresiones Key-path - Documentación de Swift\n","date":"17 septiembre 2024","permalink":"/es/blog/expresiones-keypath-swift/","section":"Blog","summary":"Las expresiones key-path ofrecen una alternativa para el acceso a datos de los tipos","title":"Cómo funcionan los key-path"},{"content":"La primera vez que vi un property wrapper fue en SwiftUI, pero es una característica de Swift que puedes usar desde la versión 5.1\nLas propiedades definen características de los tipos, pero a menudo tienes que realizar (las mismas) operaciones sobre ellas.\nLa forma más sencilla de realizar estas operaciones es utilizando los observadores de propiedad de los que te hablé anteriormente.\nPero, ¿y si debes realizar esas operaciones demasiadas veces? Si solo usas los observadores, enseguida tendrás código duplicado.\nLa solución pasa por utilizar envoltorios de propiedad, o property wrappers.\nProperty Wrappers en Swift #Los property wrappers, añaden una capa de separación entre el código que define una propiedad y el que gestiona como se almacena.\nSu principal ventaja es que escribes el código que opera sobre esa propiedad una vez, y lo reutilizas en las propiedades que necesitas.\nCómo crear un property wrapper en Swift #En el siguiente código puedes ver cómo se crea\n@propertyWrapper struct DashCase { private var text = \u0026#34;\u0026#34; var wrappedValue: String { get { text } set { text = newValue.lowercased().replacingOccurrences(of: \u0026#34; \u0026#34;, with: \u0026#34;-\u0026#34;) } } } Puedes crear una clase, una estructura o una enumeración, y es necesario que vaya precedido por la directiva de atributo @propertyWrapper\nEl tipo, debe tener una propiedad llamada wrappedValue, que devolverá el valor que definas cuando se acceda a una propiedad con el propertyValue creado.\nAsí, podríamos usar el anterior property wrapper de la siguiente manera\nstruct Branch { @DashCase var name: String } var branch = Branch() branch.name = \u0026#34;Random Branch Name\u0026#34; print(branch.name) // Muestra \u0026#34;random-branch-name\u0026#34; De esta forma, no es necesario que Branch tenga que formatear cada vez el nombre. Y por otro lado, podrás usar DashCasecada vez que necesites formatear un texto a minúsculas y guiones.\nstruct File { @DashCase var name: String } var file = File() file.name = \u0026#34;Random File Name\u0026#34; print(file.name) // Muestra \u0026#34;random-file-name\u0026#34; Fíjate que si declaras una propiedad adicional en el tipo, es conveniente declararla privada. Así te aseguras que en la implementación solo se puede acceder al valor a través de la wrappedValue\nEstablecer los valores iniciales de un property wrapper #Además, si lo necesitas, puedes utilizar un inicializador.\nEsto te permitiría crear el property wrapper de la siguiente forma:\n@propertyWrapper struct SnakeCase { var wrappedValue: String init(wrappedValue: String) { self.wrappedValue = wrappedValue.replacingOccurrences(of: \u0026#34; \u0026#34;, with: \u0026#34;_\u0026#34;).lowercased() } } Esto puede suponer una ventaja, cuando necesites por ejemplo que sea obligatorio crear el objeto, con un valor inicial, porque tendrás que introducirlo\nstruct Table { @SnakeCase var name: String } var table = Table(name: \u0026#34;hello World\u0026#34;) print(table.name) // Muestra \u0026#34;hello_world\u0026#34; Valor proyectad de un property wrapper #Además del valor envuelto, que devuelve un property wrapper, como has podido ver en los ejemplos anteriores, también permite disponer de un valor proyectado\nEste valor proyectado podría servir, siguiendo los ejemplos anteriores, para saber si se ha formateado el valor.\n@propertyWrapper struct Capitalized { private var text: String private(set) var projectedValue = false var wrappedValue: String { get { text } set { text = newValue.capitalized } } init(wrappedValue: String) { self.text = wrappedValue.capitalized projectedValue = true } } Con ello, podrías hacer lo siguiente\nstruct CustomText { @Capitalized var title: String } let text = CustomText(title: \u0026#34;One more thing...\u0026#34;) print(text.title) // Muestra \u0026#34;One More Thing...\u0026#34; print(text.$title) // Muestra \u0026#34;true\u0026#34; Conclusión #Como has visto, utilizar property wrappers trae la principal ventaja de reutilizar código entre parámetros de distintos tipos que sobre los que necesitan realizar las mismas operaciones.\nLo más importante:\nNecesitas usar la directiva @propertyWrapper y que tenga al menos una propiedad llamada wrappedValue Puedes usar si quieres una propiedad projectedValue si quieres exponer alguna funcionalidad adicional Si necesitas un propiedad adicional para realizar las operaciones, declarala como privada para que solo se pueda modificar desde el property wrapper. Si quieres practicar, aquí tienes un playground con los ejemplos 😉\nproperty-wrappers-in-swift.playground.zip Fuentes #Property Wrappers - Documentación de Swift\nProperty Wrappers en Swift - Swift by Sundell\n","date":"10 septiembre 2024","permalink":"/es/blog/property-wrappers-en-swift/","section":"Blog","summary":"Los property wrappers te permiten encapsular código repetitivo para las propiedades","title":"Cómo crear property wrappers para reutilizar código"},{"content":"En (muchas) ocasiones, debes pasar más tiempo leyendo código que escribiéndolo, por eso es clave entender lo que lees.\nAdemás, es una buena forma de aprender más conceptos de programación.\n¿Sabes en qué se diferencia open de public?¿Por qué no es lo mismo fileprivate que private?\nSaber esto, evita que pierdas el tiempo con errores en los que a veces no encontrarás explicación, y te ayudará a estructurar mejor tu aplicación.\nEl control de acceso permite gestionar el acceso a determinadas partes de tu código desde otras partes del mismo. Esto te permite ocultar los detalles de implementación de tipos, propiedades, funciones\u0026hellip; (a los que llamaremos entidades)\nNo siempre es necesario utilizarlos, ya que Swift facilita un nivel de acceso predeterminado para los escenarios más básicos.\nFicheros fuente, módulos y paquetes #Antes de seguir, es importante que conozcas los siguientes elementos para entender desde donde podrás acceder.\nFichero fuente #Un fichero fuente (source file) es un fichero con extensión .swift que se encuentra dentro de un módulo.\nTen en cuenta que normalmente se define cada tipo (clase, estructura o enumeración) en un fichero fuente, pero en ocasiones pueden haber varios relacionados en el mismo.\nMódulo #Un módulo es una unidad de distribución de código.\nPuede ser un framework o una aplicación, que formará una unidad.\nLos módulos pueden importarte desde otros módulos usando la palabra clave import\nPaquete #Un paquete es un grupo de modulos que forman una unidad.\nCuando se crea un paquete, se deben especificar los módulos que va a contener.\nNiveles de acceso en Swift #Ahora puedes ver los distintos niveles ordenados de menor a mayor restricción.\nopen #Cuando una entidad está definida con open, podrás acceder a ella desde cualquier fichero fuente que se encuentre en el mismo módulo.\nY además, también desde ficheros fuente de otros módulos, que importen el módulo que contienen dicha entidad.\nPor otro lado, permite acceder desde subclases o sobreescribir métodos desde fuera del módulo (overriding).\nLo debes utilizar cuando crees una interfaz pública de un framework.\npublic #Utilizar public es casi lo mismo que open.\nLa diferencia es que en el caso de public, no puedes acceder desde subclases ni sobescribir métodos.\npackage #Este acceso está disponible desde Swift 5.9\nComo habrás intuido, permite acceder desde cualquier fichero fuente dentro del mismo paquete\ninternal #El uso de internal permite acceder desde cualquier fichero fuente del mismo módulo, pero no de distintos módulos.\nEs habitual utilizarlo cuando se define la estructura de una app o framework sencillo.\nSeguramente apenas lo verás, ya que es el que se utiliza por defecto. Es decir, si no ves ningún control de acceso antes de la palabra clave de la entidad (struct, class, let, var, etc\u0026hellip; ) Es porque está utilizando internal.\nfileprivate #En este caso, con fileprivate solo se podrá acceder a estas entidades desde el mismo fichero fuente que lo contenga.\nDe esta forma, si por ejemplo en un fichero .swift tienes distintas clases y estructuras, la que esté marcada con fileprivate podrá ser accedida desde el resto de clases y estructuras de ese mismo fichero.\nprivate #Por último, private solo permite acceder a su contenido desde su declaración.\nEs decir, si una clase está marcada con este control de acceso, solo se podrán acceder a sus entidades, desde dentro de dicha clase.\nCómo usar los niveles de acceso en Swift #Para usar los distintos niveles simplemente tienes que indicarlo delante de la palabra clave de la entidad.\nMira los siguientes ejemplos:\nopen class MyClass {} public struct MyStruct {} internal let myConstant = \u0026#34;Hello World!\u0026#34; fileprivate var myVar = \u0026#34;Hello again!\u0026#34; v private func myMethod() {} Principio de los niveles de acceso #Los distintos niveles de acceso siguen un principio general:\nNo se puede definir ninguna entidad dentro de otra entidad que tenga un nivel de acceso inferior (más restrictivo) Es decir, no puedes definir una variable pública dentro de una clase privada; ni puedes definir una variable abierta, en un método interno.\nNivel de acceso predeterminado #El nivel de acceso por defecto es internal, por lo que si no indicas nada antes de la entidad, será éste el que tome.\nConclusión #Has visto los distintos niveles de acceso: open, public, internal, fileprivate y private, y las restricciones que implican cada uno de ello.\nEs importante utilizar el adecuado para mantener un código limpio, organizado, y eficiente, permitiendo el acceso únicamente a quien lo necesite.\nRecuerda que si no indicas nada, Swift considerará la entidad como internal.\nFuentes #Control de acceso - Documentación de Swift\n","date":"3 septiembre 2024","permalink":"/es/blog/niveles-acceso-swift/","section":"Blog","summary":"Los niveles de acceso definen desde dónde se puede acceder a tu código","title":"Qué significan los distintos niveles de acceso en Swift"},{"content":"Los dispositivos Apple destacan por varios motivos: un diseño que los identifica y muchos quieren copiar, durabilidad y fiabilidad, pero sobretodo, un ecosistema que funciona como un todo a la hora de proveer servicios.\nEsto, aunque tiene sus desventajas, la primera ventaja que suele venir a la cabeza es la facilidad para la coordinación de todos esos componentes.\nY si hay una materia donde la coordinación entre los distintos componentes es clave, es en la seguridad.\nEn este artículo no quiero limitarme a mencionar notificias de mayor o menor actualidad donde \u0026ldquo;se dice\u0026rdquo; que es un sistema seguro. Sino que quiero enumerar, basándome en la documentación oficial de la marca, de las medidas que utilicen para que tus datos y los míos estén seguros.\nLos de Cupertino dividen sus medidas de seguridad en varias áreas, tanto físicas como lógicas, que abarcan la totalidad de los actores que intervienen en este asunto.\nHardware y biometría #La base de la seguridad de un dispositivo es su hardware. Poniendo un ejemplo extremo, imagina un dispositivo que no tuviera posibilidad de acceder a internet por no contar con modem o tarjeta de red, o que no permita la entrada de volúmenes de datos: tarjetas de memoria, USBs, SSDs\u0026hellip;\nEn este caso, estos dispositivos limitarían la posibilidad de inyección de código malicioso, o la extracción de datos del usuario. Lo que podría suponer un menor riesgo de seguridad.\nPor eso, la seguridad de los dispositivos de Apple empieza en su hardware, y más concretamente en las funciones que tienen sus procesadores.\nDurante los últimos años, Apple ha invertido grandes esfuerzos en el diseño de sus propios chip, y perfeccionando los sistemas alojados en éstos, llamados System on Chip ó SoC\nUn ejemplo de ello es Secure Enclave, un subsistema de seguridad que se encuentra en las versiones más recientes de los dispositivos de Apple.\nSecure Enclave se encuentra a parte del procesador principal, para mantener los datos de seguros, en caso que la seguridad de dicho procesador fuera vulnerada.\nAdemás, se ha diseñado de la misma forma que el SoC, contando con:\nUna ROM de arranque que establece la raiz de confianza de hardware Un motor AES para criptografía Memoria protegida Para la identificación de usuarios, Apple hace uso de la biometría.\nEl método más conocido es FaceID, el sistema mediante el cual, a través de la mirada, se pueden realizar operaciones como: desbloqueo del dispositivo y confirmación de pagos y compras.\nFaceID utiliza redes neuronales para validar la coincidencia y aprender sobre los cambios que hayan en la apariencia del individuo.\nY todo esto, lo consigue a través de la cámara TrueDepth, que destaca por poder hacer escaneos en 3D de nuestro rostro, lo que evita, por ejemplo, que una simple imagen nuestra, pueda servir para suplantar nuestra identidad.\nPor otro lado, los dispositivos más antiguos, así como los teclados Magic Keyboard, cuentan con TouchID, que se utiliza para los mismos casos que los anteriormente nombrados, pero a través de nuestras digitales.\nPero no solo se limita a usar la huella grabada en su primera configuración, ya que el sensor detectará los nuevos nodos que existan con cada uso.\nAdemás, es importante que sepas que Apple facilita APIs que permiten a las aplicaciones hacer uso de estos elementos biométricos para desarrollar apps seguras.\nSistema operativo #Los sistemas operativos cuentan con diversos servicios y recursos, a los aplicaciones, usuarios y demás acceden para gestionar la información.\nLa seguridad del sistema, por lo tanto, es la encargada de gestionar estos accesos, únicamente a quien deba hacerlo.\nUn elemento muy importante en este apartado sería un arranque seguro, lo suficiente como para evitar que cualquier código no deseado, se inserte en él, y por lo tanto, consiga un alto privilegio pudiendo acceder a cualquier parte del sistema.\nEsto se consigue asegurando que cada paso es seguro, y no se pasa el control al siguiente hasta su completa validación.\nUna vez con el sistema funcionando, otro factor que determina la seguridad son las actualizaciones. En este caso, la misión del sistema será asegurar que no es posible instalar versiones anteriores y en consecuencia, posiblemente vulnerables.\nPor otro lado, los volúmenes (dispositivos de almacenamiento de datos), como medios de entrada y salida, también pueden ser vulnerados y utilizados para comprometer la seguridad.\nPara evitarlo, Apple en este caso, desde macOS 11, usa añade medidas de encriptación para proteger el código del sistema, de forma que éste no pueda ser modificado.\nEncriptación y protección de datos #Los iPhone y iPad usan un tipo de encriptación llamada Protección de datos, mientras que los datos de los equipos Mac basados en Intel se estaban asegurados con un método de encriptación del volumen que llamaron FileVault.\nAsí, en los dispositivos móviles (iPhone y iPad), de un uso por espacios de tiempo más breve, se hace uso de códigos, que son más ágiles de introducir. Se pueden usar de cuatro dígitos, de seis, o de longitud indeterminada.\nSin embargo, para el acceso en ordenadores, en los que solemos pasar varias horas frente a ellos, se utilizan contraseñas\nObviamente, a mayor longitud del código o de la contraseña, más difícil será que puedan averiguarlos. Esto es debido a que, además de necesitar más intentos de fuerza bruta, cuanto más complejo sea, más segura será la clave de encriptación.\nComo te contaba antes, esto combinado con el uso de FaceID y TouchID, mejora la experiencia de usuario, sin reducir la seguridad de tus datos.\nComo capa adicional, Apple aplica un tiempo de demora en el caso de fallar.\nPor ejemplo, en dispositivos iOS y iPadOS son los siguientes:\nIntentos Demora 1-4 Ninguna 5 1 minuto 6 5 minutos 7-8 15 minutos 9 1 hora Además, si después de 10 intentos, la opción de \u0026ldquo;Borrar datos\u0026rdquo; está activada, el contenido y los ajustes se eliminan del almacenamiento\nY en el caso de macOS, los tiempos de demora coinciden, pero en el caso de superar los 10 intentos, éste se desactivará.\nPor último, Apple también protege los datos, haciendo uso de una técnica que llama almacén seguro de datos, que evita que las distintas aplicaciones puedan acceder a nuestros datos de usuario como Calendario, Cámara, Contactos, Recordatorios, Notas\u0026hellip;\nSeguridad de las apps #Las apps suponen un grave riesgo para la seguridad de tus datos, en cuanto a que es la principal via de entrada de código a los mismos.\nSin embargo, resulta posible prescindir de ellas, ya que también son la primera fuente de funcionalidad para el hardware.\nUna primera capa ya te he mencionado anteriormente, con el almacén seguro de datos.\nEn este caso, se puede diferenciar entre apps del App Store y descargadas de otras fuentes, algo que, hasta hace bien poco, era exclusivo de macOS.\nEn el caso de macOS, a partir de la versión 10.15, todas las descargas fuera del App Store, deben estar certificadas por Apple, para evitar el mensaje de seguridad y el bloqueo.\nPor otro lado, el mismo sistema de macOS, cuenta con un sistema propio de protección antivirus para evitar la ejecución de código malicioso.\nEn el caso de apps para iOS y iPadOS, todas deben estar firmadas mediante el mecanismo implementado por Apple para subir dichas apps al App Store. Esto se realiza a través de la validación de un certificado que facilita el Apple Developer Program\nEstas validaciones, no solo se realizan por desarrolladores o empresas que distribuyen apps a usuarios finales. Sino que es un proceso por el que también se debe pasar por las organizaciones que desarrollen apps internas para sus empleados.\nPero, todo esto se refiere únicamente a la instalación.\nApple mejora aún más la seguridad, añadiendo una capa adicional al entorno de ejecución de las apps, mediante tres elementos.\nEl primero es el aislamiento, y es que, todas las apps de terceros, se ejecutan en un entorno aislado, para evitar que puedan acceder a archivos almacenados por otras apps, o que modifiquen el contenido del sistema.\nPor lo que para acceder a información ajena, debe pasar sí o sí por los métodos que establece Apple en el sistema.\nEl segundo son las autorizaciones que, mediante pares de clave-valor, permiten la autenticación fuera del entorno de ejecución, como por ejemplo, un ID de usuario en UNIX. Dichas autorizaciones se aseguran mediante firma digital, por lo que no es posible modificarlas.\nY el tercer y último elemento, es la aleatorización del espacio de direcciones, lo que ayuda a proteger el sistema frente a ataques que hacen uso de fallos por memoria corrupta.\nServicios #El primer componente que nos da acceso a los servicios que facilita Apple en sus dispositivos es el Apple ID. Éste, cuenta con una serie de requisitos habituales para evitar que un tercero consiga acceso a éste. Dichos requisitos, a la hora de crear su contraseña son:\nAl menos ocho caracteres Combinación de números y letras No deben tener más de tres caracteres idénticos o consecutivos No debe ser de uso común. Además, por defecto, Apple cuenta con la autenticación de doble factor, lo que evita accesos no deseados en caso que alguien consiga tu contraseña.\nPor otro lado, en caso de querer restablecer la contraseña, debe hacerse desde otro dispositivo de confianza.\niCloud es probablemente el servicio más usado de la compañía, que permite el almacenamiento de datos de las categorías fotos, contactos, email, salud\u0026hellip; por lo que todo esfuerzo es poco para mantener a Apple como un actor comprometido con la seguridad.\nEn este caso, Apple ofrece dos opciones para encriptar su contenido:\nProtección estándar: Los datos del usuario se encriptan y sus claves se almacenan en los centros de datos de Apple, quien solo puede ayudar a recuperar datos, pero no dispone de ellos. 14 categorías de datos usarán la encriptación de punto a punto. Protección avanzada: Solo se puede acceder a las claves de encriptación desde un dispositivo de confianza, que es donde se protegen por encriptación punto a punto. Siendo en este caso, 23 las categorías que harán uso de ella. Otro elemento, cada vez más usado, y sin duda al que hay que prestar especial atención es a Apple Pay, el cual permite realizar pagos.\nY aquí Apple protege los pagos mediante: Secure Element y el Controlador NFC.\nEl primero incluye applets (componentes que se ejecutan en el contexto de otro programa) certificados por entidades emisoras de tarjetas o redes de pagos. De esta forma, son éstas las únicas que conocen las claves de encriptación para acceder a los datos de los applets.\nEn el segundo caso, el controlador actua como puerta de enlace, permitiendo al primero poder realizar el pago en un terminal de punto de venta sin contacto. Éste, permite la conexión, una vez el usuario ha autorizado el pago mediante biometría o código.\nSeguridad en la red #En cuanto a la parte red, y aún siendo el elemento principal de la comunicación entre dispositivos, me limitaré a dar los datos técnicos sin entrar en detalle.\nAsí, iOS, iPadOS y macOS con compatibles con las versiones de TLS:\nTLS 1.0 TLS 1.1 TLS 1.2 TLS 1.3 Datagram Transport Layer Security (DTLS) Siendo TLS compatible con AES128 y AES256.\nEn cuanto a las redes privadas virtuales (VPNs), los protocolos compatibles son:\nIKEv2/IPsec con autenticación por secreto compartido, certificados RSA certificados de algoritmo de firma digital de curva elíptica (ECDSA), EAP‑MSCHAPv2 o EAP-TLS. VPN SSL con la app cliente adecuada de App Store. L2TP/IPsec con autenticación de usuario mediante contraseña de MS-CHAPV2 y autenticación de máquina mediante secreto compartido (iOS, iPadOS y macOS), y RSA SecurID o CRYPTOCard (solo macOS). Cisco IPsec con autenticación de usuario mediante contraseña, RSA SecurID o CRYPTOCard, y autenticación de máquina mediante secreto compartido y certificados (solo macOS). Kit de desarrollo #Por último, Apple te facilita una serie de kits para desarrollas apps que amplíen los servicios de éstos.\nEstos kits son: HomeKit, CloudKit, SiriKit, DriverKit, ReplayKit y ARKit.\nEn este caso, quizá el servicio donde más en juego entra la privacidad, es el caso de HomeKit, encargado de gestionar dispositivos del hogar, tan sensibles como cámaras de videovigilancia, o de grabación de audio como HomePods.\nPara asegurar estos dispositivos, HomeKit se basa en pares de claves Ed25519 constituidos por una clave pública y una privada.\nDichas claves, se almacenarán en el Llavero de iCloud, para poder actualizarse entre dispositivos.\nConclusión #Los elementos que influyen en la seguridad de los dispositivos Apple, son muchos y de distinta índole. Pero, tanto como si eres programador, manager o usuario, conocerlos es de gran importancia, principalmente para ser conscientes de los riesgos a los que estamos expuestos.\nY si además, tu trabajo está influido por dicha seguridad, puedes aportar un gran valor a los usuarios de tus apps.\n","date":"9 mayo 2024","permalink":"/es/blog/seguridad-apple/","section":"Blog","summary":"Apple combina numerosos elementos para fomentar y mantener la seguridad en sus dispositivos y apps","title":"Guía de seguridad aplicada en dispositivos Apple"},{"content":"","date":"2 mayo 2024","permalink":"/es/blog/sesgos-cognitivos-desarrollo-software/","section":"Blog","summary":"Descubre otros factores que pueden afectar a la calidad de tu código","title":"Cómo afectan los sesgos cognitivos al desarrollo de software"},{"content":"Programando para Apple es el podcast de desarrollo de aplicaciones para dispositivos Apple.\nNoticias de actualidad, análisis, opinión y entrevistas para profesionales y empresas cuyo negocio se basa en la programación y distribución de aplicaciones para el ecosistema de Apple.\nProgramar apps para iOS, visionOS, MacOS o el resto de sistemas de los de Cupertino, no es solo escribir código en Swift y SwiftUI, por eso en este podcast te recopilo la información más relevante para ayudarte a conseguir tus objetivos.\n","date":null,"permalink":"/es/podcast/","section":"Programando para Apple","summary":"\u003cp\u003eProgramando para Apple es el podcast de desarrollo de aplicaciones para dispositivos Apple.\u003c/p\u003e\n\u003cp\u003eNoticias de actualidad, análisis, opinión y entrevistas para profesionales y empresas cuyo negocio se basa en la programación y distribución de aplicaciones para el ecosistema de Apple.\u003c/p\u003e\n\u003cp\u003eProgramar apps para iOS, visionOS, MacOS o el resto de sistemas de los de Cupertino, no es solo escribir código en Swift y SwiftUI, por eso en este podcast te recopilo la información más relevante para ayudarte a conseguir tus objetivos.\u003c/p\u003e","title":"Programando para Apple"},{"content":"Episodio 6 Ya has escrito el código de tu app y te dispones a subirla al App Store pero, ¿cumples todos los requisitos para que la publiquen?¿Sabes cuanto se podría demorar si no tienes todo en cuenta?\nEn el episodio de hoy te cuento todo lo que revisa Apple para que superes con éxito la revisión y se publique lo antes posible.\nDisponible en:\nYoutube\nApple Podcasts\nSpotify\n","date":"30 abril 2024","permalink":"/es/podcast/revision-app-store/","section":"Programando para Apple","summary":"Descubre los detalles que Apple tiene en cuenta para publicar tu aplicación en el App Store","title":"Supera la revisión del App Store"},{"content":"Una de las principales ventajas que tiene desarrollar apps de forma nativa para Apple, es que con el mismo lenguaje (Swift) y el mismo framework de UI (SwiftUI) puedes crear apps para todos sus dispositivos.\nNo obstante, existen sutiles diferencias entre dichos dispositivos. Y a su vez, entre distintas versiones de éstos.\nPor eso, puedes dar un paso más allá en el desarrollo de tus productos si tienes en cuenta algunos factores, consiguiendo para tus usuarios una mejor experiencia.\nPor eso, hoy te quiero exponer estos detalles\nDiseño responsivo #Gracias a SwiftUI, no es necesario realizar los ajustes en las constraints como ocurría con UIKit, que permitían definir las distancias entre elementos, y con respecto al borde de la pantalla. Por lo que en ese sentido, no debes preocuparte.\nPero, lo que sí debes tener en cuenta, es que utilizar los tamaños dínamicos, y las fuentes facilitadas por Apple, permiten asegurar esa compatibilidad en lo que respecta a la interfaz. Además, se simplifica y agiliza la parte de desarrollo.\nPuedes encontrar más info, en la documentación oficial de SwiftUI: Aplicando a una fuerte soporte de tamaño dinámico\nAdemás, gracias a la previsualización de SwiftUI, puedes comprobar como quedarán las vistas en varios dispositivos de forma simultánea.\nCrea una app multiplataforma #Xcode permite la creación de apps multiplataforma, de esta forma, no habrán targets diferentes para iOS y macOS.\nCrea un diseño dinámico #Existen modificadores de diseño en SwiftUI que te permiten ajustar como se mostrará la vista, en función por ejemplo, del valor de una variable (vinculada por ejemplo a las subvistas que existan)\nUtiliza una versión mínima de sistema reciente #Apple se preocupa por esta compatibilidad, ya que le supone un enorme beneficio que a sus usuarios les suponga una ventaja tener sus dispositivos. Es de gran comodidad hacer una foto con el iPhone, verla en el iPad, y después editarla con el Macbook Pro.\nY esto es algo que cada vez tiene más en cuenta, por eso las versiones más recientes facilitarán la integración y compatibilidad para que una app se pueda usar en todos esos dispositivos.\nNo te olvides del modo oscuro #Otro detalle importante que puedes ver en la previsualización de SwiftUI, es que con simple click puedes comprobar como se ve tu app en modo claro u oscuro.\nEsta es una característica que cada vez se usa más por parte de los usuarios, no solo por elegir el modo que visualmente más le atraiga. Muchas veces viene configurado de forma automática. De esta forma, de día veremos el modo claro, y de noche el modo oscuro.\nPor este motivo, también es muy importante, utilizar en la medida de lo posible los colores y modificadores que facilita SwiftUI, para que tengan sus distintas versiones de colores.\nPrueba diferentes disposiciones de pantallas #En ocasiones, los usuarios prefieren utilizar el dispositivo en modo vertical, o en modo horizontal.\nSí, de nuevo, gracias a SwiftUI y no tener que depender de las constraints, nos ha facilitado los desarrollos. Pero es importante comprobar (también en la preview) como se mostrarán las vistas en las distintas orientaciones de pantalla.\nConsidera las vistas de iPad #SwiftUI cuenta con el protocolo NavigationSplitViewStyle para poder mostrar vistas divididas en paneles.\nEl ejemplo más claro es en la app de Correo, donde se muestran, de izquierda a derecha:\nLos distintos buzones El contenido del buzón El mensaje seleccionado de ese buzón. Esto es útil para colecciones, que tengan a su vez información anidada Pero recuerda comprobar el resultado en la previsualización de cada dispositivo.\nAprovecha las capacidades únicas de cada dispositivo #Aunque desarrollar una app que funcione a través de múltiples dispositivos es crucial, también es esencial aprovechar las capacidades únicas de cada uno.\nPor ejemplo, el Apple Watch ofrece funcionalidades de salud únicas, mientras que el Apple TV puede centrarse en capacidades multimedia.\nAsegúrate de diseñar tu app no solo para que sea compatible, sino también para que explote al máximo las características específicas de cada dispositivo.\nGestión del estado del dispositivo #Es fundamental gestionar el estado del dispositivo al diseñar para múltiples plataformas.\nEsto incluye manejar cambios como la rotación de la pantalla, interrupciones como llamadas entrantes o alertas, y ajustes del sistema como los cambios en las configuraciones de accesibilidad.\nEscucha los eventos del sistema y responde adecuadamente para asegurar una experiencia fluida y coherente en todos los dispositivos.\nConclusión #Como has podido, comprobar todos los aspectos a tener en cuenta, se pueden resumir en dos:\nUtilizar los elementos que facilita Apple de forma nativo Previsualizar los resultados en los distintos dispositivos de destino. Esto hará que puedas aprovechar una de las fortalezas de la compañía de Cupertino: la experiencia de uso de su ecosistema.\n","date":"25 abril 2024","permalink":"/es/blog/compatibilidad-apps-ecosistema-apple/","section":"Blog","summary":"Swift facilita poder crear apps para varios dispositivos, pero debemos asegurar su compatibilidad","title":"Asegurar la compatibilidad de las apps para el ecosistema de Apple"},{"content":"Episodio 5 ¿Es un buen momento para empezar a crear apps para visionOS?¿Sabes qué necesitas para hacerlo? En el episodio de hoy respondemos a estas preguntas y analizamos las apps destacadas ya disponibles.\nDisponible en:\nYoutube\nApple Podcasts\nSpotify\n","date":"23 abril 2024","permalink":"/es/podcast/crear-apps-vision-pro/","section":"Programando para Apple","summary":"¿Es un buen momento para empezar a crear apps para visionOS?¿Sabes qué necesitas para hacerlo?","title":"Crear apps para visionOS"},{"content":"Las propiedades son una característica fundamental en cualquier lenguaje orientado a objetos o, como en el caso de Swift, orientado a protocolos.\nPiensa en un objeto, por ejemplo, un smartphone. Podrías ver que un smarphone tiene:\nComportamientos Características Entre los comportamientos podrías identificar: Llamar a un contacto, navegar por internet, hacer una foto\u0026hellip; Es decir, acciones que puedes realizar con el dispositivo, o dicho de otra forma: qué puede hacer.\nY sobre las características, podrías ver: el tamaño de la pantalla, el peso, el color\u0026hellip; Es decir, detalles que definen cómo es el objeto, o mejor dicho, propiedades\nY es que, las propiedades, son las que van a almacenar las características de los tipos (clases, estructuras, enumeraciones o protocolos) que definan dicha propiedad.\nCon eso, podemos definir las propiedades de 2 formas distintas: mediante propiedades almacenadas, o a través de propiedades calculadas.\nPropiedades almacenadas #Las propiedades almacenadas son la forma más simple de definir una propiedad. Dentro de un tipo, indicas su propiedad; y para ello, escribe el tipo de valor (constante o variable), junto al nombre de la propiedad.\nA partir, de ahí, puedes indicar el tipo de valor (y le asignarás el valor cuando lo inicialices) o puedes asignarle un valor, y Swift inferirá el tipo de dato que estás almacenando.\nstruct Movie { let title: String let year: Int var released = false } var theFuture = Movie(title: \u0026#34;The future\u0026#34;, year: 2026) En ese ejemplo, puedes ver 3 propiedades para la estructura Movie.\nEl título y el año, deberás indicarlo en la inicialización. Mientras que, si no indicas lo contrario, la instancia se crea indicando que la película no ha sido lanzada ya que released se inicializará commo false si no has indicado nada.\nPropiedades en instancias constantes #Es importante que tengas en cuenta que si creas un instancia en una constante, pueden ocurrir dos situaciones distintas, dependiendo de si es una estructura o una clase.\nEn el caso de las estructuras, al ser tipos por valor, no podrás modificar las propiedades de la instancia (aunque esas propiedades las hayas definido con variables). Y es que, la instancia, se almacenará en una ubicación constante, y por lo tanto, será inmutable.\nEsto no ocurre con las clases ya que, al ser tipos por referencia, lo que mantienen constante es la referencia a la ubicación en memoria. Por lo tanto, sí puedes modificar el contenido y por ello, sus propiedes (siempre y cuando hayas definido esas propiedades como variables)\nstruct VideogameStruct { let title var played } class VideogameClass { let title var played } let videogameInStruct = VideogameStruct(title: \u0026#34;The last of us\u0026#34;, played: false) // ERROR: Change \u0026#39;let\u0026#39; to \u0026#39;var\u0026#39; to make it mutable let videogameInClass = VidegameClass(title: \u0026#34;God of war\u0026#34;, played: false) videogameInStruct.played = true // ERROR: Change \u0026#39;let\u0026#39; to \u0026#39;var\u0026#39; to make it mutable videgameInClass.played = true // You can change de value. Como ves, en caso de la estructura, este código no compilará. Tanto en la instanciación como al intentar modificar el valor, te dirá que cambies let por var para hacerla mutable.\nPropiedades lazy #Las propiedades lazy, son propiedades perezosas porque su valor inicial no se calcula hasta que no necesitan ser usadas.\nPara definirlas solo hay que utilizar la palabra reservada lazy al inicio de la declaración.\nclass Network { var online: Bool = false // Logic to check if internet connection works. } struct Device { let owner: String lazy var network = Network() } Las propiedades lazy son especialmente útiles para optimizar el rendimiento, ya que no se accederá al valor si no es necesario.\nEn el ejemplo anterior, puedes instanciar el dispositivo, y asignarle un propietario pero, como saber si dispone de conexión, es una tarea más compleja que implica otras operaciones, puedes seguir sin comprobarlo hasta que lo necesites.\nSi mútiples hilos acceden simultáneamente a una propiedad lazy que no ha sido inicializada, Swift no puede garantizar que solo se inicialice una vez. Propiedades calculadas #Los otros tipos de propiedades, las propiedades calculadas, no almacenan un valor directamente, sino que lo calculan y lo devuelven cuando se les llama.\nSon útiles cuando su valor depende por ejemplo, del valor de otras propiedades dentro de ese mismo tipo.\nAquí puedes ver un ejemplo sencillo:\nstruct TVSeries { var title: String var startYear: Int var endYear: Int? // A nil value indicates the series has not concluded // Computed property to determine if the series is still airing var isAiring: Bool { get { if let endYear = endYear { return false // The series has concluded } else { return true // The series is still airing } } set { let result = newValue ? \u0026#34;is\u0026#34; : \u0026#34;is not\u0026#34; print(\u0026#34;\\(title) \\(result) on air!\u0026#34;) } } } let breakingBad = TVSeries(title: \u0026#34;Breaking Bad\u0026#34;, startYear: 2008, endYear: 2013) let strangerThings = TVSeries(title: \u0026#34;Stranger Things\u0026#34;, startYear: 2016, endYear: nil) print(\u0026#34;\\(breakingBad.title) is still airing?: \\(breakingBad.isAiring)\u0026#34;) print(\u0026#34;\\(strangerThings.title) is still airing?: \\(strangerThings.isAiring)\u0026#34;) En este fragmento de estructura de una serie de televisión, puedes ver que la propiedad calculada se divide en dos componentes: el get (que se ejecutará cuando quieras acceder al valor, es decir, en la línea del print) y el set (que se ejecuta cuando se ha establecido el valor de la variable calculada, después de haberse ejecutado el print)\nAsí, en el get, puedes ver que cuando necesites el valor la propiedad isAiring (que indica si está en emisión) comprobará si tiene fecha de fin (en cuyo caso, ya no estará en emisión).\nSin embargo, el set, imprimirá un mensaje dependiendo si el valor ha sido establecido a true o false. Como puedes ver también, se puede acceder al nuevo valor mediante la variable newValue que Swift creará automáticamente.\nPropiedades de solo lectura #Las propiedades calculadas, que solo tienen get pero no tienen set se considerán propiedades de solo lectura, ya que no se ejecutará nada, cuando se establezca el valor, y por lo tanto, solo se podrá leer.\nPuedes ver este ejemplo:\nstruct Rectangle { var width: Double var height: Double var area: Double { get { return width * height } } } El área de un rectángulo, solo puede leerse, ya que si la modificas, obligatoriamente modificarías el ancho y/o el alto, por eso en este ejemplo, solo existe el get.\nEl ejemplo anterior, se puede simplicar de dos formas:\nComo solo tiene el get, se puede omitir. Como solo existe una sentencia, se puede omitir el return. struct Rectangle { var width: Double var height: Double var area: Double { width * height } } De esta forma, puedes mejorar la legibilidad de tu código\u0026hellip; y quién tenga que mantenerlo te lo agradecerá 😉.\nObservadores de propiedad #Los observadores de propiedad, hacen que se puedan realizar acciones, cuando el valor de una propiedad cambia. Es decir, sería similar al set de una propiedad calculada, pero los observadores te permiten ejecutar acciones:\nAntes de que se cambie el valor (willSet) Cuando se ha cambiado el valor (didSet) Los observadores de propiedad, se ejecutarán SIEMPRE que se establezca un valor en una propiedad. Aunque el valor establecido sea el mismo que ya tenía previamente. Los observadores de propiedad se pueden utilizar en:\nPropiedades almacenadas que tú definas Propiedades almacenadas que heredes Propiedades calculadas que heredes Mira este otro ejemplo:\nstruct ProgressTracker { var task: String var percentageComplete: Double { willSet(newPercentage) { print(\u0026#34;Will set percentageComplete for \\(task) to \\(newPercentage)%\u0026#34;) } didSet { print(\u0026#34;Did set percentageComplete for \\(task) from \\(oldValue)% to \\(percentageComplete)%\u0026#34;) if percentageComplete == 100.0 { print(\u0026#34;\\(task) is now complete.\u0026#34;) } } } } var reportProgress = ProgressTracker(task: \u0026#34;Download\u0026#34;, percentageComplete: 0) reportProgress.percentageComplete = 30 reportProgress.percentageComplete = 80 reportProgress.percentageComplete = 100 Como puedes ver, puedes pasar el nombre del valor que podrás utilizar en su bloque (como por ejeplo con la constante newPercentaje).\nTambién puedes usar oldValue, que es la constante que crea automáticamente Swift, y que almacena el valor anterior.\nProperty wrappers (envoltorios de propiedad) #Por último, es importante saber que también existen property wrappers, permiten separar el código que gestiona como una propiedad es almacenada y el código que define dicha propiedad, y esto lo consigue, envolviendo el cálculo.\nLo podrías hacer de la siguiente forma:\n@propertyWrapper struct NonNegative { private var value: Int var wrappedValue: Int { get { value } set { value = max(0, newValue) } // Ensure the value is never negative } // Initialize with a value that is guaranteed to be non-negative init(wrappedValue: Int) { self.value = max(0, wrappedValue) } } struct InventoryItem { @NonNegative var stock: Int } var item = InventoryItem(stock: 5) print(item.stock) // Prints: 5 item.stock = -3 print(item.stock) // Prints: 2 Con este ejemplo, puedes tratar por una parte como se gestionan las propiedades para comprobar que una propiedad no tenga un valor entero negativo. Y así, reutilizarlo en otras partes del código, sin tener que copiar y pegar el contenido de los getters y los setters.\nEl uso de property wrappers, requiere y permite muchos más detalles, así que si quieres saber más puedes verlo en la documentación oficial.\nConclusión #Has podido ver como las propiedades, básicamente definen las características del tipo al que pertenecen.\nPero, para poder aprovecharlas al máximo, y optimizar tu código, es clave conocer todas las operaciones que puedes hacer con ellas.\nSwift, como en muchas otras carácterísticas, ofrece diferentes métodos para acceder, calcular y devolver valores de propiedades, lo que hace que escribir código eficiente sea más sencillo.\n","date":"18 abril 2024","permalink":"/es/blog/propiedades-swift/","section":"Blog","summary":"Las propiedades permiten almacenar valores con información sobre el tipo que las define","title":"Definiendo las características de los tipos: Las propiedades"},{"content":"Episodio nº 4 En el episodio de hoy te voy a hablar de mi visión sobre cómo aprovechar la inteligencia artificial para programar, de cómo la he usado hasta ahora, y cómo espero poder usarla en un futuro.\nDisponible en:\nYoutube\nApple Podcasts\nSpotify\n","date":"15 abril 2024","permalink":"/es/podcast/inteligencia-articifial-para-programar/","section":"Programando para Apple","summary":"Mi visión y experiencia sobre cómo aprovechar la inteligencia artificial para programar","title":"Usar IA para programar"},{"content":"Episodio nº 3 Hoy te cuento qué me ha supuesto el cambio de trabajar con UIKit a SwiftUI, y las principales ventajas que le veo al nuevo framework para el desarrollo de interfaces en aplicaciones para sistemas de Apple.\nDisponible en:\nYoutube\nApple Podcasts\nSpotify\n","date":"8 abril 2024","permalink":"/es/podcast/uikit-swiftui/","section":"Programando para Apple","summary":"Qué me ha supuesto el cambio de trabajar con UIKit a SwiftUI, y las principales ventajas de usarlo","title":"De UIKit a SwiftUI"},{"content":"Existen numerosos tipos de aplicaciones. Me atrevería a decir, que casi tantos, como tipos de empresas o desarrolladores. Y, aunque tenemos un número importante en nuestros dispositivos, también es cierto que el número de las que utilizamos habitualmente se reduce drásticamente.\nEsto muestra la importancia de seleccionar cada uno de los detalles que engloban a una app: UX/UI, contenido, onboarding, accesibilidad… detalles que cambiarán también notablemente según al público que se dirijan, y por lo tanto, también podremos decir que existirán tantos tipos de cada elemento, como usuarios.\nPero si hay algo que reduce las posibilidades a un número más reducido, es el modelo de negocio escogido para, como tanto nos gusta 😉, que nuestra app sea rentable.\n¿Y sabes que esos beneficios pueden variar considerablemente dependiendo del modelo que escojas?\nPor eso hoy quiero hablarte de los distintos modelos de negocio que puedes utilizar si vas a lanzar una aplicación para un dispositivo Apple, y que sea lo más rentable posible.\nModelos de negocio de aplicaciones en App Store #Gratuito #En una aplicación gratuita, el usuario podrá descargar la app y podrá utilizarla completamente, sin realizar ningún pago.\nEste modelo es utilizado en muchas ocasiones cuando no se buscan beneficios directamente económicos: mejorar imagen de marca, validación de idea de mercado, mostrar un portfolio…\nLa opción más habitual para generar ingresos directos con este modelo es mediante la inserción de banners de publicidad.\nDe esta forma, el modelo de negocio será muy similar a sitios webs de contenido que obtienen sus ingresos de la publicidad, por lo que necesitarás un importante número de usuarios que usen tu app, y además, que lo hagan de forma recurrente, para que esos ingresos se mantengan a lo largo del tiempo. Además, es muy importante no saturar al usuario con publicidad para no emprobrecer la experiencia de usuario.\nEn este caso puedes utilizar SDKs de terceros para poder ingresar los anuncios, siendo la más utilizada, la plataforma AdMob de Google. En su documentación puedes ver cómo y dónde insertar el código para mostrar los anuncios.\nYa sería la plataforma de anuncios escogida la que te mostraría la gestión de dichos anuncios, beneficios, configuración, etc… y tendría sus propios requisitos de pago.\nFreemium #En el modelo Freemium, el usuario descarga la app de forma gratuita.\nA partir de ahí, tienes dos opciones: Dar un periodo por el que el usuario podrá utilizar todas las características y acceder al contenido de toda la app, cuando dicho periodo expire, deberá pagar para continuar usándola. Ofrecer un contenido o características básicas, que puede usar de forma ilimitada mientras quiera, pero el usuario en este caso deberá pagar para acceder a un contenido o características de mayor valor.\nEs decir, el usuario utilizará una parte de la aplicación o por un tiempo delimitado, pero deberá pagar para utilizarla completamente (es decir, por la parte Premium, no incluida en la parte gratuita)\nEn este modelo, es clave mostrar en la parte que el usuario verá gratuitamente, los detalles que mas valor le puedan aportar y solucionen el problema por el que se decidió a descargar tu app, y por lo tanto, que quiera seguir usándola completamente.\nPara este caso, Apple pone a tu disposición las siguientes formas de compras \u0026lsquo;in-app\u0026rsquo;\nConsumibles #El usuario paga, por elementos que puede consumir: como por ejemplo, gemas, vidas o cartas.\nEste tipo es especialmente usado en juegos donde el usuario necesita algún elemento que usará para seguir avanzando.\nNo consumibles #El usuario paga una única vez, y con ello, consigue el nuevo contenido o característica, de forma ilimitada.\nEn este caso, puede utilizarse para otro tipo de aplicaciones que no sean un juego: un nuevo filtro para aplicación de cámara, elementos de adorno para su avatar, etc…\nSuscripciones autorenovables #El usuario pagará por el contenido Premium, que utilizará durante un periodo de tiempo limitado.\nAsí, finalizado el mismo, se renovará automáticamente.\nSuscripciones no renovables #Igual que la anterior, pero en este caso la suscripción no se renovará automáticamente.\nMás información sobre las opciones de cobro en el modelo Freemium #Puedes ver más información y guias muy útiles en la página de desarrollador de Apple sobre modelos de negocio y monetización\nPago único #En este modelo de pago el usuario pagará para poder descargar la aplicación.\nUna vez descargada, el usuario puede acceder a todo el contenido y funciones de tu app, es el modelo de pago directo más sencillo que existe, similar a la compra de un bien físico.\nPara este modelo, lo más importante es que puedas mostrar al usuario las capacidades y beneficios de tu app.\nComo primera opción (la primera impresión cuenta mucho) es fundamental seleccionar cuidadosamente las capturas de pantallas y videos que subirás al App Store, así como saber explicar en la descripción de la app, los problemas que podrá resolver tu usuario.\nOtra alternativa muy recomendable sería tener una landing page para que puedas mostrar más info sobre los beneficios que tú app aporta a los usuarios, tanto en texto, como en imágenes o en vídeo\nLos precios se establecen cuando se sube la aplicación al App Store, en la página de configuración del producto, pudiendo personalizar los distintos precios para los distintos países.\nPaymium #En un modelo Paymium, el usuario paga por descargar la app, y con ello tendrá acceso a determinadas características, pero para poder utilizarla completamente (parte Premium), deberá pagar de nuevo.\nEsta es una forma que se puede aplicar a apps de mayor precio, permitiendo su uso más básico a un precio reducido.\nPuede ser interesante para apps que puedan ser usadas para aficionados y para profesionales, siendo estos últimos los que pagarían por la app completa si ello les supone un beneficio mayor que el gasto que han realizado.\nComo en el caso anterior, una combinación de excelente página de producto en el App Store e información adicional fuera de ella, facilitará las compras.\nEn este modelo, también se configurará en la página de producto de la aplicación en el App Store, utilizando una combinación\nBeneficios e inconvenientes de los modelos # Modelo Ventajas Inconvenientes Gratuito Facilidad de descarga por parte de los usuarios para probarla. Mayor dificultad para retener los usuarios.\nUna excesiva publicidad resulta en peor experiencia de usuario. Freemium Facilidad de descarga, igual que el modelo gratuito, lo que permite validar su aceptación.\nSi el usuario decide pagar, es una forma de costear las futuras actualizaciones. Dificultad para mostrar valor en parte gratuita y que quieran pagar por la premium. Pago único Se obtienen ingresos desde el primer momento. Dificultad para descargar al requerir previo pago, en especial para las más costosas.\nSolo se obtiene ingreso por descargar, pero no por mantener la app. Paymium Se obtienen ingresos desde el primer momento, y también por el desarrollo de nuevas características y actualizaciones. Será más complejo que el usuario acceda a usar la app, sabiendo que para otras opciones, deberá volver a pagar. Modelos de negocio alternativos #Si bien los que has visto anteriormente son los que puedes gestionar más directamente a través de Apple, y por lo tanto, los que te recomiendo. Dispones de otras vías para obtener ingresos de tus más apps\nPatrocinios #Si consigues asociarte con una marca que quiera darse a conocer a través de tu app, podrías organizar activaciones que permitieran tanto a dicha marca como a tus usuarios beneficiarse de dicha acción, por lo que estoy sería una nueva vía de ingresos con los que costear el desarrollo y mantenimiento de tu app.\nCrowdfunding #En este caso, podrías lanzar una campaña de crowfunding, con lo que en un primer momento podrías conseguir la financiación necesaria para poner en marcha el desarrollo de la app. Además, con usuarios habiendo aportado un pago por adelantado antes de hacer la aplicación, podrías validar la idea y confirmar que aporta valor a tus usuarios.\nTambién sería una opción si esto permite escalar la app ofreciendo características que supongan una importante mejora.\nDespués, tus usuarios podrían hacer uso de códigos de descarga o de desbloqueo de características para obtener esa recompensa por la financiación que te han facilitado.\nAfiliación #Un modelo de afiliación que permita “Invitar a un amigo” a probar la aplicación, aunque conllevaría que tuvieras que recompensar a quienes invitan, te podría traer un considerable número de compras o suscripciones.\nConclusión #Apple pone a disposición de desarrolladores y organizaciones las herramientas para sus modelos de negocios recomendados, pero serás tú quién deberá seleccionar el más adecuado para tu app en función de tus usuarios y objetivos.\nNo es una decisión trivial por lo que, dedicarle el tiempo necesario puede repercutir en que el negocio de la aplicación sea viable o un fracase. Como en tantos otros elementos en los que el usuario tiene tanto que decir, recoger feedback y responder rápidamente a la demanda, puede ahorrarte tiempo, dinero y disgustos.\nAdemás, los distintos modelos, cuentan con su configuración para determinar y cobrar los importes de forma segura, nativa y eficiente.\nCada uno de los modelos o estrategias pueden combinarse para alinearse con las necesidades o las estrategias de marketing que determines, pero también será clave poner al usuario en el centro.\nPor último, como seguramente sabrás y quizá estés pensando, ya se pueden integrar tiendas de terceros en iOS en Europa… pero eso ya queda para otro (u otros) artículos.\nY ahora que sabes esto ¿qué modelo te parece más interesante para tu aplicación?\n","date":"4 abril 2024","permalink":"/es/blog/modelos-negocio-apps-apple/","section":"Blog","summary":"La elección del modelo de negocio y monetización de tu app es vital para su éxito y tus beneficios","title":"Modelos de negocio de aplicaciones en Apple: Descubre el perfecto para tu app"},{"content":"Episodio 2 Hoy te cuento por qué es tan importante tus aplicaciones sean de calidad y tengan el menor número de bugs, pero además, desde un punto de vista que no es tan habitual, y que muestra tu valor como profesional.\nDisponible en:\nYoutube\nApple Podcasts\nSpotify\n","date":"1 abril 2024","permalink":"/es/podcast/calidad-apps/","section":"Programando para Apple","summary":"Por qué es tan importante tus aplicaciones sean de calidad","title":"La calidad de tus apps"},{"content":"En el mundo del desarrollo de software con Swift, una de las decisiones fundamentales que enfrentamos es la elección entre estructuras y clases. Ambas son constructos esenciales que nos permiten modelar nuestros datos de manera eficiente, pero sus diferencias son cruciales para escribir código eficiente y fácil de entender.\nLas estructuras y clases en Swift comparten varias similitudes. Ambas pueden definir propiedades para almacenar valores, métodos para añadir funcionalidad, subíndices para acceder a valores con una sintaxis específica, y se pueden extender para aumentar su funcionalidad. Sin embargo, es en sus diferencias donde encontramos las claves para decidir cuándo usar cada una.\n¿Cuándo usar estructuras? #Las estructuras son tipos de valor. Esto significa que se copian cuando se asignan a una nueva variable o se pasan a una función. Son la elección predilecta para representar datos simples y autónomos que no necesitan heredar propiedades de otro lugar. Por ejemplo, para modelar las especificaciones de un videojuego, podrías usar una estructura:\nstruct VideoGame { var name: String var genre: String var platform: String } let halo = VideoGame(name: \u0026#34;Halo Infinite\u0026#34;, genre: \u0026#34;FPS\u0026#34;, platform: \u0026#34;Xbox\u0026#34;) Este modelo es útil cuando los valores copiados son lo que necesitas, como pasar los datos de un videojuego de un lado a otro en tu app sin preocuparte por efectos secundarios no deseados.\n¿Cuándo usar clases? #Las clases son tipos de referencia. A diferencia de las estructuras, si asignas una instancia de una clase a una nueva variable o la pasas a una función, lo que se pasa es una referencia a la misma instancia. Esto es útil cuando necesitas tener un único objeto que se actualice y se acceda desde múltiples lugares. Por ejemplo, podrías querer tener un objeto que represente una sesión de usuario:\nclass UserSession { var user: String var status: String init(user: String, status: String) { self.user = user self.status = status } } let session = UserSession(user: \u0026#34;Oski82\u0026#34;, status: \u0026#34;Active\u0026#34;) Utilizar una clase aquí permite que cualquier cambio en la session se refleje a través de toda la app, lo cual sería crucial para el manejo de estados como el inicio o cierre de sesión.\nDiferencias clave # Herencia: Solo las clases pueden heredar de otra clase. Esto las hace poderosas para casos de uso polimórficos. Tipo de referencia vs. tipo de valor: Este es probablemente el mayor factor diferenciador. Afecta cómo se transmite la información en tu app y puede tener implicaciones significativas en el rendimiento y el uso de la memoria. Conteo de referencias: Solo las clases soportan el conteo de referencias, permitiendo que más de una referencia apunte a la misma instancia de una clase. Esto es útil para manejar la vida útil de los objetos, especialmente en entornos con múltiples hilos. Recomendaciones # Prioriza estructuras sobre clases: Son más rápidas y seguras en un contexto de concurrencia debido a que trabajan con copias de los datos que contienen. Usa clases cuando necesites herencia o manejo de identidad único: Por ejemplo, para controlar una única instancia de un servicio de red o una sesión de usuario compartida a través de tu app. Conclusión #La elección entre estructuras y clases depende de la naturaleza de tus datos y de cómo planeas usarlos en tu aplicación. Si bien las estructuras ofrecen una manera segura y eficiente de trabajar con datos copiados, las clases proporcionan poderosas herramientas para el manejo de estados compartidos y la herencia. Al elegir conscientemente entre estos dos constructos, puedes escribir código más claro, eficiente y adecuado a tus necesidades.\n","date":"28 marzo 2024","permalink":"/es/blog/estructuras-clases/","section":"Blog","summary":"Ambas opciones permiten encapsular y reutilizar valores y comportamientos, pero conocer sus diferencias ayuda a optimizar tu código","title":"Dominando las bases: Estructuras vs. clases"},{"content":"Episodio nº 1 Te cuento los objetivos y cómo será este podcast, enfocado a profesionales y empresas que programan aplicaciones para Apple. Además, te hablo sobre mí y sobre mi carrera profesional.\nDisponible en:\nYoutube\nApple Podcasts\nSpotify\n","date":"25 marzo 2024","permalink":"/es/podcast/presentacion/","section":"Programando para Apple","summary":"Presentación del podcast de desarrollo de aplicaciones para dispositivos Apple.","title":"Presentación"},{"content":"¡Hola! Hoy quiero compartir contigo algunos consejos prácticos y directrices fundamentales para ayudarte a superar con éxito el proceso de revisión en el App Store de Apple. Si eres desarrollador y buscas lanzar tu aplicación en esta plataforma, sabrás que el detalle marca la diferencia. Así que, vamos a adentrarnos juntos en este camino hacia el éxito.\nPreparación antes de la publicación #El primer paso es asegurarte de que estás completamente preparado. Esto significa tener una cuenta de desarrollador activa con Apple y asegurarte de que tu aplicación cumpla con todas sus directrices, tanto técnicas como visuales. Recuerda, la preparación es la clave.\nAspectos técnicos y de diseño #Apple pone un gran énfasis en la calidad y la experiencia de usuario. Tu aplicación debe ser libre de errores, funcionar de manera fluida en todos los dispositivos y ofrecer una experiencia de usuario intuitiva. Cada detalle cuenta en la interfaz y la usabilidad, no solo para superar la revisión, sino para destacar en el mercado.\nUtilizar las herramientas proporcionadas por Apple #Aprovecha las herramientas que Apple pone a tu disposición. Xcode Cloud y TestFlight son indispensables en tu arsenal de desarrollo. Xcode Cloud facilita el desarrollo colaborativo, mientras que TestFlight es esencial para las pruebas beta y la recopilación de feedback antes de tu lanzamiento final.\nPersonalización y pruebas A/B #Personalizar la página de tu aplicación para diferentes audiencias y evaluar el rendimiento de distintos elementos puede marcar la diferencia en cómo conectas con tu audiencia. Esta flexibilidad es clave para optimizar tu presentación y lograr un mayor impacto.\nContenido y funcionalidad de la aplicación #Tu aplicación debe ofrecer un contenido completo y valioso. Evita publicar con errores, enlaces rotos o descripciones imprecisas. Una experiencia rica y sin fisuras es fundamental no solo para la aprobación, sino también para el éxito en el App Store.\nAtención al detalle en la presentación #Desde el nombre y la descripción de tu aplicación hasta las capturas de pantalla y el icono, cada elemento debe ser cuidadosamente considerado. Estos materiales deben cumplir con las especificaciones de Apple y comunicar efectivamente lo que ofrece tu aplicación.\nSoporte y asistencia continua #Utiliza los recursos y el soporte que Apple ofrece. Documentos técnicos, códigos de muestra y la posibilidad de colaborar directamente con ingenieros de Apple son fundamentales para resolver cualquier desafío durante el desarrollo de tu aplicación.\nCumplimiento de las políticas de Apple #Es esencial que tu aplicación cumpla con todas las políticas de Apple. Esto incluye normas sobre privacidad, seguridad y contenido. Para asegurarte de que tu aplicación se alinea con estas políticas, revisa los siguientes enlaces oficiales:\nApp Store Review Guidelines Apple Developer Program License Agreement Siguiendo estos consejos y haciendo uso de los recursos proporcionados por Apple, mejorarás significativamente tus posibilidades de éxito en el App Store. El detalle define el éxito, y cada paso que tomas es crucial. Con dedicación, atención al detalle y una actitud proactiva hacia el aprendizaje y la mejora continua, no hay duda de que puedes crear experiencias excepcionales que cautivarán a usuarios de todo el mundo.\nRecuerda, mientras el camino hacia la aprobación en el App Store puede parecer desalentador, cada desafío es una oportunidad para aprender y crecer. Con la preparación adecuada, el uso efectivo de las herramientas de Apple, y una atención meticulosa a las políticas y directrices de la plataforma, estarás bien equipado para superar la revisión de publicación en el App Store. Y no olvides, en este viaje no estás solo. La comunidad de desarrolladores y los recursos proporcionados por Apple están aquí para apoyarte en cada paso del camino.\nEspero que este artículo te haya sido útil y te haya proporcionado una buena base sobre la que construir y lanzar tu aplicación con éxito. Recuerda que la comunidad de desarrolladores es un gran recurso, y nunca está de más buscar consejo o compartir tus propias experiencias. ¡Juntos hacemos crecer esta increíble plataforma!\n","date":"18 marzo 2024","permalink":"/es/blog/revision-publicacion-app-store/","section":"Blog","summary":"Te cuento las claves para superar rápida y eficazmente la revisión de publicación de tu app en el App Store","title":"Claves para superar la revisión de publicación en el App Store"},{"content":"Las enumeraciones, o simplemente enums como las conocemos en Swift, son esa herramienta imprescindible en tu kit de desarrollo, permitiéndote definir un tipo común para un grupo de valores relacionados. Esto no solo va a mejorar la legibilidad de tu código, sino que también facilitará su mantenimiento y te ayudará a evitar esos errores comunes que a todos nos gusta evitar. Si estás empezando en Swift y aún te estás familiarizando con la creación de funciones, entender las enumeraciones puede ser realmente revelador.\n¿Qué son las enumeraciones? #Imagina que estás trabajando en una app sobre series de televisión. Tienes diferentes géneros como drama, comedia, terror, etc. En lugar de gestionar estos géneros como cadenas de texto (lo que podría llevar a errores de escritura) puedes definir una enumeración:\nenum TVShowGenre { case drama case comedy case horror case sciFi } Con esta definición, puedes usar TVShowGenre de manera segura y controlada, mejorando así la legibilidad y la consistencia de tu código.\n¿Cuándo usar enums? #Las enumeraciones son increíblemente útiles cuando necesitas agrupar conjuntos de valores relacionados que ya conoces. Por ejemplo, en una app para seguir las temporadas de Fórmula 1, podrías tener una enumeración para los equipos:\nenum F1Team { case mercedes case ferrari case redBull case mclaren } Este enfoque garantiza que solo puedas asignar pilotos a los equipos que existen en tu enumeración, evitando asignaciones incorrectas.\nValores asociados #Swift lleva las enumeraciones aún más allá, permitiendo casos con valores asociados. Esto significa que puedes almacenar valores adicionales de otros tipos junto con los casos de la enumeración. Imagina que estás creando un videojuego y quieres definir diferentes tipos de enemigos, algunos con atributos especiales:\nenum Enemy { case soldier case wizard(magicStrength: Int) case boss(isFinal: Bool, lives: Int) } Aquí, wizard tiene un valor asociado magicStrength, y boss tiene dos valores asociados, indicando si es el jefe final y cuántas vidas tiene. Esto te permite manejar cada tipo de enemigo de forma más específica y detallada en tu juego.\nRaw Values y la herencia del protocolo String #Las enumeraciones en Swift pueden tener raw values, que son valores predefinidos que puedes asociar con cada caso de la enumeración. Esto es especialmente útil cuando tu enumeración necesita representar un valor de cadena o numérico específico para cada caso.\nPor ejemplo, podrías tener una enumeración que represente los pilotos de Fórmula 1, donde cada piloto se asocia con su nombre completo correspondiente:\nenum Drivers: String { case verstappen = \u0026#34;Max Verstappen\u0026#34; case alonso = \u0026#34;Fernando Alonso\u0026#34; case leclerc = \u0026#34;Charles Leclerc\u0026#34; } Aquí, Drivers es una enumeración que hereda del protocolo String. Esto significa que cada caso tiene un raw value de tipo String que coincide con su nombre. Por ejemplo, puedes acceder al raw value de un piloto de la siguiente manera:\nlet driver = Drivers.verstappen print(driver.rawValue) // Print \u0026#34;Max Verstappen\u0026#34; Esto es particularmente útil cuando necesitas trabajar con datos que provienen de una fuente externa que utiliza representaciones de cadena, como un servidor web o una base de datos.\nAdemás, cuando una enumeración hereda del protocolo String, Swift automáticamente asigna a cada caso un raw value que coincide con el nombre del caso, lo que te ahorra la necesidad de asignar explícitamente un raw value a cada caso.\nenum Track: String { case monaco case spa } let track = Track.monaco.rawValue // track is a String with value \u0026#34;monaco\u0026#34; En resumen, el uso de raw values y la herencia del protocolo String en tus enumeraciones puede mejorar la legibilidad de tu código, facilitar la interacción con otras partes de tu código que utilizan cadenas y números, y ayudarte a evitar errores al manejar datos externos. ¡Espero que esto te ayude a entender aún más el poder de las enumeraciones en Swift!\nConclusión #Las enumeraciones en Swift son una forma potente y segura de trabajar con conjuntos de valores relacionados.\nFacilitan la escritura de código más limpio y mantenible, al tiempo que previenen errores comunes limitando los valores a los definidos en la enumeración. Los valores asociados ofrecen una flexibilidad adicional, permitiéndote incluir información específica directamente en tus tipos de datos. Los valores raw te permiten usar cadenas de tus casos. Al dominar las enumeraciones, estarás dando un paso enorme hacia el desarrollo de software más robusto y eficiente. ¡Es tu turno de experimentar con ellas y ver todo lo que pueden hacer por tus proyectos!\n","date":"11 marzo 2024","permalink":"/es/blog/enums-swift/","section":"Blog","summary":"Las enumeraciones permiten defininir un tipo común para unos valores asociados","title":"Enumeraciones"},{"content":"Los closures son un concepto fundamental en Swift. Son herramientas poderosas que te permiten definir y manipular bloques de código, por eso se les considera ciudadanos de primera clase. En este artículo, exploraremos los closures, los closures finales, la captura de valores y el hecho de que los closures son tipos por referencia\nClosures #Un closure es un bloque de código autónomo que se puede pasar y utilizar en el código, como cualquier otra constante o variable. En Swift, puedes definir closures usando las llaves {}. Este sería un ejemplo sencillo:\nlet greet = { print(\u0026#34;Hello, world!\u0026#34;) } Closures finales #Los closures finales son una forma conveniente de incluir un closure como último argumento de una función. Esto hace que tu código sea más legible. Supongamos que tienes una función que toma un closure como argumento:\nfunc performAction(action: () -\u0026gt; Void) { // Perform some setup action() } // Using a trailing closure performAction { print(\u0026#34;Action performed!\u0026#34;) } Capturando valores #Los closures pueden capturar y almacenar referencias a variables y constantes del contexto en el que se definen. Esto significa que pueden \u0026ldquo;recordar\u0026rdquo; y manipular esos valores incluso si ya no están dentro de su ámbito. Mira este ejemplo:\nfunc makeIncrementer(incrementAmount: Int) -\u0026gt; () -\u0026gt; Int { var total = 0 let incrementer: () -\u0026gt; Int = { total += incrementAmount return total } return incrementer } // Usage example: let incrementByTwo = makeIncrementer(incrementAmount: 2) let incrementByFive = makeIncrementer(incrementAmount: 5) print(incrementByTwo()) // Output: 2 print(incrementByTwo()) // Output: 4 print(incrementByTwo()) // Output: 6 print(incrementByFive()) // Output: 5 print(incrementByFive()) // Output: 10 print(incrementByFive()) // Output: 15 En este ejemplo, definimos la función makeIncrementer, que toma un incrementAmount como argumento y devuelve un closure de tipo () -\u0026gt; Int. Cada vez que llama al closure devuelto, incrementa la variable total en el valor de incrementAmount especificado y devuelve el total actualizado. Creamos dos closures separados, incrementByTwo e incrementByFive, cada uno con su propio total capturado y su incrementAmount. Cuando llamamos a estos closures varias veces, puedes ver cómo mantienen su estado individual y aumentan en sus respectivos cantidades.\nLos closures son tipos por referencia #Los closures son más que simples bloques de código, son tipos por referencia. Puedes declarar un closure y las variables de ese tipo pueden contener closures con las mismas firmas. Esto te permite definir funciones que toman closures como parámetros, o que los devuelven como resultados, proporcionando flexibilidad y reutilización en tu código.\nConclusión #En resumen, los closures son un concepto clave en Swift y comprenderlos es esencial para cualquier desarrollador de iOS. Proporcionan una forma flexible de trabajar con código y datos, ya sea que estés creando funciones simples u operaciones asíncronas avanzadas. Al dominar los closures, rastrearlos, capturar valores y reconocer que los closures son tipos por referencia, estarás mejor capacitado para escribir código Swift eficiente y legible.\n","date":"5 septiembre 2023","permalink":"/es/blog/closures-en-swift/","section":"Blog","summary":"Un closure es un bloque que puede ser usado en tu código","title":"Entendiendo los closures en Swift"},{"content":"","date":null,"permalink":"/es/apps/shary/","section":"Apps","summary":"Shary es una aplicación fácil e intuitiva para compartir gastos.","title":"Shary"},{"content":"Como desarrolladores, a menudo manejamos situaciones en las que necesitamos trabajar con funciones en nuestras aplicaciones iOS. Las funciones son una parte integral del lenguaje de programación Swift y nos proporcionan un conjunto de herramientas poderosas para construir código flexible y modular. En este artículo, exploraremos el concepto de usar tipos de funciones y cómo puede beneficiar nuestro proceso de desarrollo.\nDeterminar el tipo de función #En Swift, las funciones se consideran ciudadanos de primera clase, lo que significa que pueden asignarse a variables o constantes y también pueden usarse como tipos. Para determinar el tipo de una función, podemos usar la firma de la función. La firma consta de los tipos de parámetros y el tipo de retorno. Consideremos un ejemplo:\nfunc add(_ a: Int, _ b: Int) -\u0026gt; Int { return a + b } El tipo de esta función puede representarse como (Int, Int) -\u0026gt; Int, donde (Int, Int) representa los tipos de parámetros e Int representa el tipo de retorno.\nUsar tipos de funciones como parámetros #Una de las ventajas de usar tipos de funciones es la capacidad de pasarlas como parámetros a otras funciones. Esto nos permite crear funciones de orden superior que pueden aceptar diferentes comportamientos según las funciones proporcionadas. Tomemos un ejemplo donde tenemos una función que aplica una operación dada en una matriz de enteros:\nfunc applyOperation(_ numbers: [Int], operation: (Int) -\u0026gt; Int) -\u0026gt; [Int] { var result = [Int]() for number in numbers { let transformedNumber = operation(number) result.append(transformedNumber) } return result } En el código anterior, la función applyOperation toma una matriz de enteros y una función operation como parámetros. El parámetro operation representa una función que toma un entero y devuelve un entero. Podemos usar esta función de orden superior para realizar varias operaciones en nuestra matriz de números.\nUsar tipos de funciones como retorno #Otro aspecto poderoso de usar tipos de funciones es la capacidad de usarlos como valores de retorno. Esto nos permite crear funciones que generan y devuelven dinámicamente otras funciones según ciertas condiciones o requisitos. Consideremos un ejemplo:\nfunc operationFactory() -\u0026gt; (Int) -\u0026gt; Int { if condition { return { number in number * 2 } } else { return { number in number / 2 } } } En este ejemplo, la función operationFactory devuelve una función del tipo (Int) -\u0026gt; Int basada en una cierta condición. Podemos aprovechar este comportamiento para crear un código más flexible y adaptable.\nConclusión #El uso de tipos de funciones en el desarrollo de iOS nos proporciona un mecanismo poderoso para crear código modular y flexible. Al tratar las funciones como ciudadanos de primera clase, podemos pasarlas como parámetros a otras funciones, usarlas como tipos de retorno y generarlas dinámicamente cuando sea necesario. Este enfoque mejora la reutilización del código, promueve la modularidad y permite la creación de funciones de orden superior. Al aprovechar estas capacidades, los desarrolladores pueden construir aplicaciones iOS robustas y adaptables. Así que, la próxima vez que te encuentres en una situación donde necesites incorporar diferentes comportamientos en tu código, considera usar tipos de funciones para una solución más elegante.\n","date":"10 julio 2023","permalink":"/es/blog/uso-funciones-swift/","section":"Blog","summary":"Como las funciones son ciudadanos de primera clase en Swift, puedes aprovechar sus beneficios","title":"Usando funciones en Swift"},{"content":"Comprender las complejidades de las etiquetas de argumentos de funciones y los nombres de parámetros es esencial para aprovechar al máximo el lenguaje de programación Swift. En este artículo, exploraremos estos conceptos con un enfoque en la simplicidad, atendiendo a desarrolladores con experiencia limitada en la creación de funciones. ¡Así que, comencemos!\nEtiquetas de argumentos de función #Las etiquetas de argumentos proporcionan un contexto descriptivo al llamar a una función, haciendo que el código sea más expresivo y legible. En Swift, las etiquetas de argumentos se especifican antes de los nombres de parámetros y están separadas por un espacio. Consideremos un ejemplo donde calculamos la puntuación de un nivel de videojuego:\nfunc calculateScore(forLevel level: Int) -\u0026gt; Int { // Function body goes here } Aquí, forLevel es la etiqueta del argumento, y level es el nombre del parámetro. Al llamar a esta función, usamos la etiqueta del argumento para proporcionar claridad:\nlet finalScore = calculateScore(forLevel: 5) Al usar etiquetas de argumentos, podemos transmitir el propósito de cada parámetro, mejorando la comprensión de nuestro código.\nAdemás, puedes omitir una etiqueta de argumento. Simplemente debes escribir un guion bajo en lugar de una etiqueta de argumento:\nfunc addStamina(_ stamina: Int) -\u0026gt; Int { // Function body goes here } Y solo necesitarás pasar el valor cuando llames a la función.\nlet totalStamina = addStamina(100) Valores de parámetros predeterminados #En Swift, tenemos la flexibilidad de asignar valores predeterminados a los parámetros de funciones. Esto significa que al llamar a una función, podemos optar por omitir argumentos específicos, y en su lugar se utilizarán los valores predeterminados. Continuando con nuestro tema de videojuegos, modifiquemos nuestra función anterior para incluir un valor predeterminado para el parámetro bonusPoints:\nfunc calculateScore(level: Int, bonusPoints: Int = 500) -\u0026gt; Int { return level * bonusPoints } Ahora, podemos llamar a la función y usar los dos parámetros pero, si llamamos a la función sin proporcionar un valor para bonusPoints, automáticamente se utilizará el valor predeterminado de 500:\nlet totalScore = calculateScore(level: 2, bonusPoints: 100) // totalScore is equal to 200 let finalScore = calculateScore(level: 5) // finalScore is equal to 2500 Parámetros variádicos #A veces, podemos encontrarnos con situaciones donde el número de argumentos de la función no es fijo. Para manejar tales escenarios, Swift nos permite usar parámetros variádicos. Estos parámetros pueden aceptar cero o más valores de un tipo especificado. Para demostrarlo, imagina una función que calcula la puntuación total de varios videojuegos:\nfunc calculateTotalScore(scores: Int...) -\u0026gt; Int { // Function body goes here } Aquí, scores es un parámetro variádico. Podemos pasar cualquier número de argumentos separados por comas al llamar a la función:\nlet totalScore = calculateTotalScore(scores: 100, 250, 500, 750) Parámetros de entrada-salida #Por último, Swift proporciona el modificador de parámetro in-out, que permite a una función modificar el valor de una variable desde fuera de su propio ámbito. Los parámetros de entrada-salida se prefijan con la palabra clave \u0026ldquo;inout\u0026rdquo;. Considera un escenario donde necesitamos actualizar los puntos de salud de un personaje de juego:\nfunc updateHealthPoints(_ hp: inout Int) { // Function body goes here } Para pasar una variable como un parámetro in-out, antecedemos un ampersand antes del nombre de la variable:\nvar characterHP = 100 updateHealthPoints(\u0026amp;characterHP) Conclusión #En este artículo, hemos cubierto los fundamentos de las etiquetas de argumentos de funciones y los nombres de parámetros en Swift. Exploramos el uso de etiquetas de argumentos, valores de parámetros predeterminados, parámetros variadicos y parámetros de in-out. Al dominar estos conceptos, podrás escribir código limpio, expresivo y flexible en tus proyectos de iOS. Sigue practicando e incorporando estas técnicas en tu viaje de desarrollo, y pronto podrías estar creando videojuegos retro notables que dejen a los jugadores nostálgicos por la edad de oro de los videojuegos.\n","date":"26 junio 2023","permalink":"/es/blog/etiquetas-argumentos-funcion-parametros/","section":"Blog","summary":"Descubriendo las bases sobre parámetros de entrada en las funciones","title":"Etiquetas de argumentos de función y nombres de parámetros"},{"content":"Como desarrolladores de iOS, a menudo nos encontramos con escenarios donde necesitamos devolver múltiples valores de una función. Swift nos ofrece dos enfoques útiles para lograr esto: utilizando tuplas y colecciones. En este artículo, exploraremos ambos métodos y entenderemos cuándo usar cada uno.\nUsando Tuplas #Las tuplas son estructuras de datos ligeras que nos permiten agrupar múltiples valores juntos. Proporcionan una forma sencilla de devolver múltiples valores de una función. Considera el siguiente ejemplo:\nfunc getMovieDetails(movieId: Int) -\u0026gt; (String, String) { // Retrieve movie details from the database let movieTitle = \u0026#34;Back to the Future\u0026#34; let director = \u0026#34;Robert Zemeckis\u0026#34; return (movieTitle, director) } let movieDetails = getMovieDetails(movieId: 1) print(\u0026#34;Title: \\(movieDetails.0)\u0026#34;) print(\u0026#34;Director: \\(movieDetails.2)\u0026#34;) En este ejemplo, la función getMovieDetails devuelve una tupla que contiene el título de la película y el director. Podemos acceder a valores individuales usando la sintaxis de punto y el índice correspondiente. Las tuplas son útiles cuando tenemos un número fijo de valores para devolver.\nUsando colecciones #Las colecciones, como arrays o diccionarios, ofrecen un enfoque más flexible para devolver múltiples valores. Veamos cómo podemos modificar nuestro ejemplo anterior para utilizar un array:\nfunc getMovieDetails(movieId: Int) -\u0026gt; [String] { // Retrieve movie details from the database let movieTitle = \u0026#34;Back to the Future\u0026#34; let releaseYear = 1985 let director = \u0026#34;Robert Zemeckis\u0026#34; return [movieTitle, String(releaseYear), director] } let movieDetails = getMovieDetails(movieId: 1) print(\u0026#34;Title: \\(movieDetails[0])\u0026#34;) print(\u0026#34;Release Year: \\(movieDetails[1])\u0026#34;) print(\u0026#34;Director: \\(movieDetails[2])\u0026#34;) Aquí, la función getMovieDetails devuelve un array de strings, conteniendo el título de la película, el año de lanzamiento (convertido a string) y el director. Accedemos a los valores por sus respectivos índices. Las colecciones son ventajosas cuando tenemos un número variable de valores para devolver o si el número de valores puede cambiar en el futuro.\nElegir entre Tuplas y Colecciones #Al decidir entre tuplas y colecciones, considera las siguientes pautas:\nUsa tuplas cuando tengas un número fijo de valores que no cambiará. Usa colecciones cuando el número de valores pueda variar o cuando necesites agregar o eliminar valores fácilmente. Conclusión #Devolver múltiples valores de una función en Swift es esencial en muchos escenarios de programación. Al utilizar tuplas o colecciones, podemos manejar eficientemente estas situaciones. Las tuplas son adecuadas para devolver un número fijo de valores, mientras que las colecciones ofrecen flexibilidad cuando el número de valores puede variar. Entender estas técnicas nos empodera para escribir un código más limpio y expresivo.\nRecuerda experimentar con estos conceptos usando ejemplos del mundo real y explorar cómo pueden ser aplicados a tus propios proyectos.\n","date":"12 junio 2023","permalink":"/es/blog/devolviendo-multiples-valores-desde-funciones/","section":"Blog","summary":"Aprende como puedes devolver multiples valores desde una función","title":"Devolviendo múltiples valores desde una función: Tuplas vs. Colecciones"},{"content":"Como desarrollador, es esencial entender los conceptos fundamentales de la programación. Uno de esos conceptos es las funciones, las cuales desempeñan un papel crucial en la organización y reutilización del código. En este artículo, exploraremos los conceptos básicos de las funciones en Swift. Ya seas un principiante o estés buscando una revisión, esta guía te ayudará a comprender los aspectos esenciales de las funciones de manera simple y directa.\n¿Qué son las Funciones? #Una función es un bloque de código que realiza una tarea específica. Te permite encapsular un conjunto de instrucciones bajo un nombre significativo, haciendo que tu código sea más organizado y modular. Las funciones pueden aceptar valores de entrada, llamados parámetros, y devolver valores de salida. Proporcionan una forma de descomponer la lógica compleja en partes más pequeñas y manejables.\nSintaxis y Estructura: #En Swift, la declaración de una función comienza con la palabra clave func, seguida del nombre de la función y paréntesis. Si la función acepta parámetros, se especifican dentro de los paréntesis. El tipo de retorno se indica con una flecha -\u0026gt; seguida del tipo. Aquí tienes un ejemplo:\nfunc greet(name: String) -\u0026gt; String { return \u0026#34;Hello, \\(name)!\u0026#34; } En este ejemplo, tenemos una función llamada greet que acepta un parámetro llamado name de tipo String. Devuelve un valor String que contiene un mensaje de saludo con el nombre proporcionado.\nEscenario de ejemplo #Imaginemos que estamos construyendo una aplicación relacionada con programas de televisión. Podemos crear una función para recomendar un programa en función de las preferencias del usuario. Aquí tienes un ejemplo:\nfunc recommendShow(userPreference: String) -\u0026gt; String { if userPreference == \u0026#34;action\u0026#34; { return \u0026#34;You should watch \u0026#39;Game of Thrones\u0026#39;!\u0026#34; } else if userPreference == \u0026#34;comedy\u0026#34; { return \u0026#34;I recommend \u0026#39;Friends\u0026#39;!\u0026#34; } else { return \u0026#34;I\u0026#39;m sorry, I don\u0026#39;t have a recommendation for your preference.\u0026#34; } } Cuando llamas a esta función con diferentes preferencias, como \u0026ldquo;acción\u0026rdquo; o \u0026ldquo;comedia\u0026rdquo;, devolverá una recomendación apropiada. Si la preferencia del usuario no coincide con ningún caso específico, se devuelve un mensaje predeterminado.\nCuándo Usar Funciones #Las funciones son particularmente útiles en los siguientes escenarios:\nReusabilidad #Si te encuentras realizando la misma tarea o cálculo en múltiples lugares de tu código, es una buena indicación para crear una función para esa tarea. De esta manera, puedes reutilizar el código sin duplicarlo.\nModularidad #Las funciones ayudan a organizar el código en unidades más pequeñas y autocontenidas. Esto mejora la legibilidad y mantenibilidad del código.\nAbstracción #Al encapsular la lógica compleja dentro de las funciones, puedes abstraer los detalles de implementación y centrarte en la funcionalidad de nivel superior.\nConclusión #Comprender los conceptos básicos de las funciones es esencial para cualquier desarrollador. Te permiten escribir código limpio y reutilizable, y mejorar la estructura de tus programas. En este artículo, exploramos la sintaxis y la estructura de las funciones en Swift, junto con un escenario de ejemplo utilizando las preferencias de programas de televisión. Al aprovechar las funciones de manera efectiva, puedes crear un código más modular y mantenible.\n","date":"29 mayo 2023","permalink":"/es/blog/entendiendo-basico-funciones/","section":"Blog","summary":"Las funciones nos permiten organizar el códgo, reusarlo y evitar duplicados","title":"Entendiendo lo básico de las funciones en Swift"},{"content":"En Swift, hay varios constructores del lenguaje que hacen la programación más eficiente y robusta.\nUno de estos constructores es la declaración defer, que permite a los desarrolladores ejecutar un bloque de código más tarde en el flujo del programa. Este artículo tiene como objetivo explicar cómo funciona defer en Swift, proporcionar ejemplos de su uso y destacar los escenarios en los cuales puede ser beneficioso.\nSe utiliza para definir un bloque de código que se ejecuta cuando se sale del ámbito actual, independientemente de cómo se salga del ámbito, ya sea mediante una declaración de retorno, un error o un break. Ten en cuenta que, en caso de que tu aplicación deje de funcionar debido a un error en tiempo de ejecución, el código diferido no se ejecuta.\nAsegura que se ejecute un código de limpieza o finalización específico antes de salir del ámbito, independientemente del camino de ejecución.\nSintaxis de defer #La sintaxis es simple. Comienzas con la palabra clave defer seguido por el bloque de código que quieres ejecutar más tarde. Aquí un ejemplo:\nfunc processFile() { print(\u0026#34;Opening file...\u0026#34;) defer { print(\u0026#34;Closing file...\u0026#34;) } // Code for processing the file goes here // This code will be executed before the file is closed } En este ejemplo, el mensaje Opening file... se imprime primero, y luego se define el bloque defer.\nEl bloque defer contiene el código que se ejecutará al final, justo antes de salir del ámbito. En este caso, el mensaje Closing file... siempre se imprimirá, asegurando que el archivo se cierre correctamente.\nCasos de uso de defer #defer es particularmente útil en escenarios donde necesitas asegurarte de que los recursos sean liberados correctamente o que se realicen acciones independientemente del camino de ejecución. Algunos casos de uso comunes incluyen:\nLimpieza de recursos #Cuando trabajas con archivos, bases de datos o conexiones de red, puedes usar defer para asegurar que los recursos se liberen, las conexiones se cierren o las transacciones se confirmen.\nLiberación de bloqueos #Si haces uso de un bloqueo o un semáforo, la declaración defer puede ayudar a liberarlo incluso si ocurre una excepción o si el bloque de código se sale de la ejecución antes de tiempo.\nRestauración de estado #En flujos de trabajo complejos o operaciones asíncronas, puedes usar la declaración defer para restaurar el estado a una condición consistente o inicial antes de salir del ámbito.\nRegistro y depuración #defer se puede emplear para registrar o informar información con fines de depuración antes de salir del ámbito actual.\nConclusión #defer en Swift es un constructo del lenguaje poderoso que permite a los desarrolladores diferir la ejecución de código hasta el final de un ámbito. Asegura que se ejecute un código específico de limpieza o finalización, independientemente de cómo se salga del ámbito.\nAl aprovechar la declaración defer, los desarrolladores podemos escribir código más resiliente y organizado, facilitando la gestión de la limpieza de recursos y asegurando el comportamiento deseado en varios escenarios.\nRecuerda, la declaración defer puede ser particularmente útil cuando trabajas con recursos, bloqueos, gestión de estado y depuración.\n","date":"15 mayo 2023","permalink":"/es/blog/descubriendo-defer-swift/","section":"Blog","summary":"Ejecuta un bloque de código al finalizar un flujo del programa","title":"Descubriendo defer en Swift"},{"content":"En la programación iOS, una construcción poderosa que ayuda a mejorar la legibilidad del código y a mejorar el flujo de control es la sentencia guard. Esta declaración actúa como un guardián, permitiéndonos manejar de manera elegante los escenarios excepcionales y salir temprano de un bloque de código.\nEn este artículo, descubrirás los beneficios de la sentencia guard, explorarás su uso y proporcionarás ejemplos para ilustrar su efectividad.\nEntendiendo la sentencia guard #La sentencia guard sirve como un mecanismo de salida anticipada condicional en Swift, el lenguaje de programación para el desarrollo de iOS.\nPermite verificar condiciones específicas y asegurar que se cumplan antes de continuar con la ejecución de un bloque de código.\nSi las condiciones no se cumplen, la sentencia guard termina el ámbito actual, permitiéndonos manejar los escenarios de fallo de manera elegante.\nLa sintaxis para una sentencia guard es la siguiente:\nguard condition else { // Code to handle the failure case // Return, throw, or perform any necessary cleanup } // Code to execute when the condition is successfully met Cuando se encuentra una sentencia guard, se evalúa la condición especificada.\nSi la condición se evalúa como falsa, se ejecuta el código dentro del bloque else.\nEste bloque típicamente contiene código para manejar el caso de fallo, como retornar de la función, lanzar un error, o realizar cualquier limpieza necesaria. Si la condición se evalúa como verdadera, el código continúa ejecutándose normalmente después de guard.\nSalida anticipada para condiciones inaceptables #Las sentencias guard pueden ayudar a evitar declaraciones condicionales anidadas proporcionando salidas tempranas para condiciones que se consideran inaceptables. Esto simplifica el código y mejora la legibilidad. Por ejemplo:\nlet amount = 500 let accountBalance = 1000 guard amount \u0026lt;= accountBalance else { print(\u0026#34;Insufficient funds!\u0026#34;) return } // Perform payment operation Otros casos de uso #Hay otros casos de uso para guard, específicamente relacionados con los Opcionales y el manejo de errores. Sin embargo, dado que estos son temas más avanzados, en mi opinión, es mejor solo mencionarlos ahora y explorarlos en detalle en publicaciones avanzadas futuras.\nValidación de entradas #La sentencia guard se utiliza a menudo para validar los parámetros de entrada, asegurando que cumplan con ciertos requisitos antes de proceder. Este caso se utiliza manejando opcionales.\nDesasignación de recursos #En este caso, guard es útil al tratar con recursos que requieren limpieza. Asegura que el código de limpieza se ejecute siempre que se encuentre una condición de fallo.\nConclusión #La sentencia guard es una herramienta poderosa en la programación de iOS que permite un código limpio, conciso y eficiente. Proporciona una manera elegante de manejar escenarios de fallo y salir graciosamente de un bloque de código cuando ciertas condiciones no se cumplen.\nAl usar la sentencia guard de manera efectiva, puedes mejorar la legibilidad y mantenibilidad de tu código.\nAdopta esta construcción en tus proyectos y disfruta de los beneficios de un proceso de desarrollo más eficiente.\n","date":"2 mayo 2023","permalink":"/es/blog/guard-salida-anticipada-swift/","section":"Blog","summary":"Saliendo antes de tiempo en un bloque de código","title":"Entendiendo la sentencia guard para una salida anticipiada"},{"content":"Las sentencias de traspaso de control son herramientas esenciales en programación que te permiten alterar el flujo de ejecución dentro de tu código.\nEn Swift, tres sentencias de traspaso de control de uso común son continue, break, y fallthrough.\nEn este artículo, examinaremos cada una de estas sentencias, dando ejemplos y explicando los escenarios en los que es más apropiado utilizarlas.\nContinue #continue se usa principalmente dentro de bucles (como for-in o while) para omitir el código restante dentro de la iteración actual y pasar a la siguiente. Te permite omitir selectivamente partes específicas de un bucle sin terminarlo por completo. Aquí un ejemplo para ilustrar su uso:\nfor number in 1...10 { if number % 2 == 0 { continue } print(number) } Resultado\n1 3 5 7 9 En este ejemplo, la instrucción continue se utiliza para omitir la impresión de números pares. Cuando la condición number % 2 == 0 es verdadera, se ejecuta la instrucción continue, omitiendo la instrucción print y pasando a la siguiente iteración.\nBreak #break se utiliza para finalizar prematuramente la ejecución de un bucle o una sentencia de cambio. Te permite salir de un bucle o bloque switch antes de llegar a su final natural.\nFñijate el siguiente ejemplo:\nlet cars = [“Red Bull\u0026#34;, “Aston Martin\u0026#34;, “Ferrari\u0026#34;, \u0026#34;Mercedes\u0026#34;, \u0026#34;McClaren\u0026#34;] for name in names { if name == \u0026#34;Mercedes\u0026#34; { break } print(name) } Resultado\nRed Bull Aston Martin Ferrari En este caso, la sentencia break se utiliza para salir del bucle una vez que la condición name == \u0026quot;Mercedes\u0026quot; es verdadera. Como resultado, el bucle termina antes de tiempo y los elementos restantes del array cars no se imprimen.\nFallthrough #fallthrough se usa exclusivamente dentro de las sentencias de cambio. Permite que el flujo de control pase al siguiente caso sin realizar una \u0026ldquo;interrupción\u0026rdquo; implícita.\nEste comportamiento es distinto del comportamiento predeterminado de un switch, donde el control de la ejecución sale automáticamente del bloque después de que coincida un caso.\nVeamos el siguiente ejemplo:\nlet grade = \u0026#34;A\u0026#34; switch grade { case \u0026#34;A\u0026#34;: print(\u0026#34;Excellent\u0026#34;) fallthrough case \u0026#34;B\u0026#34;: print(“You have approved\u0026#34;) case \u0026#34;C\u0026#34;: print(\u0026#34;Average\u0026#34;) default: print(\u0026#34;Incomplete\u0026#34;) } Resultado\nExcellent Good En este ejemplo, cuando la calificación es A, la instrucción fallthrough se utiliza para continuar la ejecución al siguiente caso sin salir del bloque de cambio. Como resultado, se imprimirán Excellent y You have approved.\nConclusión #Entender las sentencias de traspaso de control como continue, break, and fallthrough es crucial para una programación en Swift eficaz.\ncontinue te permite omitir iteraciones específicas dentro de los bucles, break resultará en la terminación prematura de bucles o switches, y fallthrough hará que el control fluya al siguiente caso en un switch.\nAl aprovechar estas sentencias de manera adecuada, puedes mejorar la flexibilidad y el control de la ejecución de tu código desarrollando iOS.\n","date":"17 abril 2023","permalink":"/es/blog/sentencias-transpaso-control-swift/","section":"Blog","summary":"Alterar el flujo de control dentro del código","title":"Explorando las sentencias de traspaso de control en Swift"},{"content":"Comprender las bases de la programación Swift es crucial para crear aplicaciones sólidas y eficientes.\nUno de los conceptos clave que debes comprender son las sentencias condicionales. En este artículo, navegaremos hacia el mundo de los condicionales en Swift, explorando su sintaxis, ejemplos y mejores prácticas para usarlas de manera efectiva. ¡A ello!\nSentencias condicionales: Tomando decisiones en Swift #En programación, a menudo hay situaciones en las que necesitas que tu aplicación tome decisiones basadas en ciertas condiciones. Aquí es donde entran en juego las se condicionales, que le permiten ejecutar bloques de código específicos dependiendo de si una condición se evalúa como verdadera o falsa.\nSwift ofrece tres sentencias condicionales principales: sentencias if, sentencias if-else y sentencias switch.\nCada sentencia tiene un propósito distinto, y comprender cuándo usar cada una es esencial para escribir código limpio y fácil de mantener.\nLa sentencia if #La sentencia if es la forma más simple de sentencia condicional en Swift. Te permite ejecutar un bloque de código solo si una condición específica es verdadera.\nPor ejemplo, digamos que quieres mostrar un mensaje si la edad de un usuario es mayor o igual a 18 años:\nlet userAge = 20 if userAge \u0026gt;= 18 { print(\u0026#34;Welcome! You can access.\u0026#34;) } } ```swift ### La sentencia `if`-`else` La sentencia `if`-`else` amplía la sentencia `if` al facilitar un bloque de código alternativo para ejecutar cuando la condición que se evalúa resulta falsa. Considera el siguiente ejemplo que verifica si un número es positivo o negativo: ```swift let number = -5 if number \u0026gt; 0 { print(\u0026#34;The number is positive.\u0026#34;) } else { print(\u0026#34;The number is negative.\u0026#34;) } ```swift ### La sentencia `switch` La sentencia `switch` ofrece una forma más concisa de manejar múltiples condiciones posibles. Evalúa un valor determinado frente a varios casos y ejecuta el bloque de código asociado con el primer caso coincidente. Supongamos que quieres mostrar un mensaje según el rol de un usuario: ```swift let userRole = \u0026#34;admin\u0026#34; switch userRole { case \u0026#34;admin\u0026#34;: print(\u0026#34;Welcome, administrator!\u0026#34;) case \u0026#34;user\u0026#34;: print(\u0026#34;Welcome, user!\u0026#34;) default: print(\u0026#34;Unknown role.\u0026#34;) } ```swift ## Mejores prácticas para utilizar condicionales: ### Mantenlo simple Trata de escribir código conciso y legible. Evita condiciones anidadas complejas que puedan dificultar la comprensión y el mantenimiento del código. ### Utiliza los operadores oportunos Swift proporciona una variedad de operadores lógicos y de comparación, como `\u0026lt;`, `\u0026gt;`, `==`, `\u0026amp;\u0026amp;`, `||`, para construir condiciones más complejas. ### Planifica todas las posibilidades Asegúrate de tener en cuenta todos los escenarios posibles en tus sentencias condicionales. El caso `default` en `switch` actúa como un comodín para el resto de condiciones que no hayas tenido en cuenta. ### Prueba tu código Valida tus condicionales con diferentes entradas para asegurarte de que se comporten como esperas. Las pruebas unitarias son una práctica muy valiosa para identificar y solucionar cualquier problema desde el principio. ## Conclusión Las sentencias condicionales son herramientas imprescindibles para el desarrollo con Swift, ya que te permiten tomar decisiones y controlar el flujo de tu código en función de situaciones específicas. Al dominar las sentencias `if`, `if`-`else` y `switch`, obtendrás la capacidad de crear aplicaciones dinámicas y personalizadas. Recuerda utilizar estas sentencias con prudencia, manteniendo tu código limpio y comprensible. 😉 ","date":"3 abril 2023","permalink":"/es/blog/sentencias-condicionales-swift/","section":"Blog","summary":"Controlando el comportamiento de la aplicación basándose en condiciones","title":"Condicionales como base de Swift"},{"content":"En el desarrollo de iOS, las sentencias de control de flujo juegan un papel crucial en dirigir la ejecución del código.\nPermiten a los desarrolladores iterar sobre colecciones, realizar tareas repetitivas y controlar el comportamiento del programa basado en ciertas condiciones. En esta publicación, nos sumergiremos en tres sentencias de control de flujo esenciales en Swift: for-in, while, y repeat-while.\nYa seas un desarrollador iOS junior o alguien que busca refrescar su conocimiento, entender estas sentencias es esencial para construir aplicaciones iOS robustas y eficientes.\nBucles for-in: Simplificando la iteración #El bucle for-in es particularmente útil cuando quieres iterar sobre una colección de elementos, como un array o un diccionario. Simplifica el proceso de acceder a cada elemento sin la necesidad de indexación manual. Veamos un ejemplo:\nlet books = [“A Game of Thrones”, “A Clash of Kings”, “A Storm of Swords”, ”A Feast for Crows”, “A Dance with Dragons”] for book in books { print(book) } En este ejemplo, el bucle for-in itera sobre cada elemento en el array de libros e imprime su título. El bucle asigna automáticamente cada elemento a la constante libro, permitiéndote realizar operaciones sobre él dentro del ámbito del bucle.\nEste bucle es ideal para escenarios tales como:\nEnumerar a través de un array para realizar operaciones en cada elemento. Iterar sobre un diccionario para acceder tanto a las llaves como a los valores. Iterar sobre un rango de números o caracteres. Bucles while: Ejecutando código condicionalmente #El bucle while ejecuta un bloque de código repetidamente mientras una condición dada permanezca verdadera. Esto es particularmente útil cuando no conoces el número exacto de iteraciones de antemano. Aquí hay un ejemplo para ilustrar su uso:\nvar count = 0 while count \u0026lt; 5 { print(\u0026#34;Count: \\(count)\u0026#34;) count += 1 } En este ejemplo, el bucle while seguirá ejecutándose mientras la variable count sea menor que 5. Imprime el valor actual de count y lo incrementa en 1 en cada iteración. Ten cuidado al usar bucles while para asegurarte de que la condición eventualmente se vuelva falsa; de lo contrario, puede resultar en un bucle infinito.\nConsidera usar el bucle while en las siguientes situaciones:\nRealizar repetidamente una acción hasta que se cumpla una condición específica. Implementar validación de entrada y pedir continuamente la entrada del usuario hasta que se proporcione datos válidos. Interactuar con sistemas o procesos externos que requieren monitoreo continuo. Bucle repeat-while: Asegurando la primera ejecución del código #El bucle repeat-while es similar al bucle while, pero con una diferencia crucial: la condición se evalúa al final del bucle. Esto garantiza que el bloque de código se ejecute al menos una vez, incluso si la condición es inicialmente falsa. Aquí hay un ejemplo:\nvar number = 10 repeat { print(number) number -= 2 } while number \u0026gt; 0 En este ejemplo, el bucle repeat-while imprime el valor de number y le resta 2 hasta que number se convierte en 0 o menos. A diferencia del bucle while, el bucle repeat-while ejecuta el bloque de código primero y luego verifica la condición.\nEs adecuado para escenarios como:\nImplementar sistemas basados en menús donde quieres asegurar la ejecución antes de verificar las elecciones del usuario. Manejar la lógica de juegos donde una acción debe realizarse al menos una vez antes de verificar las condiciones de finalización del juego. Repetir una operación hasta que se cumpla una condición específica. Conclusión #Entender las sentencias de control de flujo como for-in, while y repeat-`while es fundamental para cualquier desarrollador de iOS.\nEstas sentencias te permiten controlar el flujo del programa, iterar sobre colecciones y ejecutar código condicionalmente. Al dominar estas sentencias de control de flujo, tendrás la capacidad de construir aplicaciones iOS más eficientes y dinámicas.\nUtiliza estas sentencias sabiamente, prestando atención a las condiciones de terminación de los bucles para evitar bucles infinitos. Sigue explorando sus capacidades y experimentando con diferentes escenarios para mejorar tus habilidades de programación.\n","date":"20 marzo 2023","permalink":"/es/blog/bucles-swift/","section":"Blog","summary":"Iterando y realizando tareas repetitivas","title":"Explorando los bucles en Swift"},{"content":"Las colecciones son una de las estructuras de datos más utilizadas cuando programas, por lo tanto, es extremadamente importante conocer los diferentes enfoques que dispones para trabajar con ellas.\nLos tipos de colección son tipos de datos complejos, y Swift permite usar tres tipos de colección: Arrays, Sets y Diccionarios para gestionar valores relacionados.\nLa fiabilidad de estas colecciones se basa en los tipos de valores y claves que puedes almacenar. Cuando creas una instancia de una colección, necesitas confirmar el tipo de valores que gestiona. Esto significa que: no puedes almacenar diferentes tipos a los que definiste previamente, y puedes estar seguro del tipo de datos que recuperarás cuando manejas una colección.\nAdemás, gracias a la inferencia de tipo, puedes especificar el tipo, o Swift inferirá el tipo.\nMutabilidad de las colecciones #Así como las variables y constantes, las colecciones pueden ser mutables o inmutables dependiendo de cómo fueron creadas.\nSi almacenas un array, set o un diccionario en una variable, puedes mutar la colección, porque puedes agregar, remover o cambiar un único o múltiples valores en estas colecciones.\nPero, si lo almacenas en una constante, no puedes añadir nuevos elementos o modificar los que fueron instanciados.\nDiferencias entre arrays, sets y diccionarios #Los arrays son colecciones ordenadas, donde las duplicaciones están permitidas y los valores pueden ser accedidos por un índice numérico (posición en el array)\nLos sets son colecciones desordenadas donde las duplicaciones no están permitidas, y los valores pueden ser iterados, pero no se pueden acceder por un índice o clave.\nLos diccionarios son colecciones desordenadas compuestas por asociaciones de clave-valor.\nFundamentos de los diferentes tipos de colección #Arrays #Si quieres crear un array vacío, necesitarás especificar el tipo de dato. Hay diferentes maneras de crear un array vacío, este es un ejemplo.\nvar numbers = [Int]() Pero, si quieres crearlo con valores, no necesitas especificar los tipos. A continuación, puedes ver cómo crear un array de strings\nvar tutorials = [\u0026#34;SwiftUI\u0026#34;, \u0026#34;Combine\u0026#34;, \u0026#34;AsyncAwait\u0026#34;] Y, si necesitas acceder a un valor, debes indicar la posición del valor en el array. Pero, recuerda que el índice de las colecciones comienza por 0.\nlet firstCourse = tutorials[0] El código anterior almacenará SwiftUI en la constante firstCourse.\nSets #Nuevamente, necesitarás especificar el tipo de dato para crear un set vacío.\nvar numbers = Set\u0026lt;Int\u0026gt;() Crear un set con valores es similar a crear un array pero, en este caso, necesitarás especificar que es un set para no crear un array\nvar tutorials = [\u0026#34;SwiftUI\u0026#34;, \u0026#34;Combine\u0026#34;, \u0026#34;AsyncAwait\u0026#34;] Pero, en este caso, como los sets no tienen índice, no puedes usarlo para acceder a los datos. Al menos, puedes comprobar si el valor existe.\nvar swiftuiExists = tutorials.contains(\u0026#34;SwiftUI\u0026#34;) El código anterior almacenará true en la variable swiftuiExists\nDiccionarios #Y, por último, puedes crear un diccionario vacío especificando tanto el tipo de clave como el tipo de valor\nvar nameOfNumbers = [Int: String]() Para crear un diccionario con valores, también es similar a un array, pero tienes que escribir la clave de cada valor. Recuerda que las claves deben ser únicas.\nvar requirements = [\u0026#34;View\u0026#34;:\u0026#34;SwiftUI\u0026#34;, \u0026#34;Database\u0026#34;:\u0026#34;CoreData\u0026#34;, \u0026#34;AugmentedReality\u0026#34;:\u0026#34;ARKit\u0026#34;] Y, si quieres acceder a un valor, solo necesitas conocer el índice\nlet database = requirements[\u0026#34;Database\u0026#34;] En las próximas publicaciones, escribiré sobre métodos útiles en tipos de colección para gestionar arrays, sets y diccionarios.\n","date":"6 marzo 2023","permalink":"/es/blog/colecciones-swift/","section":"Blog","summary":"Swift tiene tres tipos de colecciones y su uso depende de cómo quieres gestionar sus valores","title":"Colecciones en Swift"},{"content":"Esta publicación es un complemento para la anterior sobre Cadenas en Swift.\nEn proyectos del mundo real, puedes almacenar muchas cadenas, pero es importante que sepas cómo transformar esas cadenas para mostrarlas según tu vista.\nPor esta razón, veamos los métodos habituales que puedes usar para esto.\nContar caracteres #Dado que una cadena es una colección de caracteres, puedes usar un método muy común en Arrays: count()\nPuedes usarlo en una constante/variable o en una cadena.\nlet starWarsIntro = \u0026#34;A long time ago...\u0026#34; let numberOfCharacters = starWarsIntro.count() // numberOfCharacters value 18 let numberOfCharactersOfGreet = \u0026#34;Hello World!\u0026#34;.count() // numberOfCharactersOfGreet value is 12 Incluso puedes combinar valores en la misma cadena a través de la interpolación de cadenas:\nlet plotTwist = \u0026#34;I am your father\u0026#34; print(\u0026#34;The number of character in \\(plotTwist) is \\(plotTwist).count()\u0026#34;) // It will print \u0026#34;The number of character in I am your father is 16\u0026#34; Insertar o eliminar #También es importante agregar o eliminar caracteres o subcadenas.\nInsertar #Para insertar, puedes:\nInsertar un carácter con el método .insert(_ newElement:at:) Insertar una subcadena con el método .insert(contentsOf:at:) En at, deberás escribir un índice. Puedes obtener más información sobre los índices en Documentación oficial de Swift - Índices de cadenas\nvar warning = \u0026#34;we have a problem\u0026#34; warning.insert(contentsOf: \u0026#34;Houston, \u0026#34;, at: warning.startIndex) print(warning) // It will print \u0026#34;Houston, we have a problem\u0026#34; Eliminar #Similar a insertar, para eliminar Swift permite eliminar caracteres o subcadenas:\nEliminar un carácter con el método .remove(at:) Eliminar una subcadena con el método removeSubrange(_ bounds:) Ten cuidado de no salirte de los límites.\nvar greeting = \u0026#34;Hello World!\u0026#34; greeting.remove(at: greeting.index(before: greeting.endIndex)) print(greeting) // It will print \u0026#34;Hello World\u0026#34; Modificar cadenas #Mayúsculas y minúsculas #Los métodos que puedes usar para esto son .uppercased(), .lowercased() o .capitalized()\nEjemplos:\nlet lordOfTheRings = \u0026#34;A ring to rule them all\u0026#34; print(lordOfTheRings.uppercased()) // It will print \u0026#34;A RING TO RULE THEM ALL\u0026#34; print(lordOfTheRings.lowercased()) // It will print \u0026#34;a ring to rule them all\u0026#34; print(lordOfTheRings.capitalized) // It will print \u0026#34;A Ring To Rule Them All\u0026#34; Extraer una cadena a un array #Para este objetivo, puedes usar .components(separatedBy: \u0026quot; \u0026quot;)\nlet et = “E.T. phone home.” let etWords = et.components(separatedBy: \u0026#34; \u0026#34;) // etWords value is equal to [\u0026#34;E.T.\u0026#34;, \u0026#34;phone\u0026#34;, \u0026#34;home.\u0026#34;] Reemplazar ocurrencias #En este caso, un método útil es .replacingOccurrences(of:, with:), puedes reemplazar un carácter o una cadena con otro carácter o cadena\nlet darkKnight = \u0026#34;I am Batman\u0026#34; let coded = darkKnight.replacingOccurrences(of: \u0026#34;a\u0026#34;, with: \u0026#34;4\u0026#34;) // coded value is equal to \u0026#34;I 4m B4tm4n\u0026#34; ","date":"20 febrero 2023","permalink":"/es/blog/metodos-utiles-cadenas-swift/","section":"Blog","summary":"Aprende métodos útiles para cadenas en Swift y muestra la información que necesites","title":"Métodos útiles para cadenas en Swift"},{"content":"Cuando guardas un texto en una constante o una variable, estás guardando una cadena en Swift. Además, puedes ver una cadena como una serie de caracteres. Por esa razón, puedes acceder al contenido de una cadena de varias maneras, como una Colección (Array, por ejemplo) de caracteres.\nInicializar una Cadena #Un literal de cadena es un texto escrito con comillas dobles al principio y al final. Entonces, si necesitas guardar un texto en una constante o una variable, solo debes asignar un literal de cadena a ella.\nlet coach = \u0026#34;Ted Lasso\u0026#34; var team = \u0026#34;AFC Richmond\u0026#34; NOTA: Es fundamental recordar que las cadenas distinguen entre mayúsculas y minúsculas. Por lo tanto, \u0026ldquo;una cadena simple\u0026rdquo; es diferente de \u0026ldquo;Una cadena simple\u0026rdquo;.\nConcatenando cadenas #Si necesitas guardar el valor de dos cadenas en otra constante o variable, puedes concatenarlas.\nEs tan fácil como usar el operador + entre los dos valores cuando tienes que asignarlo.\nlet name = \u0026#34;Michael\u0026#34; let lastName = \u0026#34;Scott\u0026#34; let funnyBoss = name + lastName Otra forma es usar el operador += para agregar texto a una cadena previamente inicializada.\nvar spy = \u0026#34;Bond\u0026#34; spy += \u0026#34;, James Bond\u0026#34; En el ejemplo anterior, el valor final de spy es Bond, James Bond\nY, como una String es una Colección de caracteres, también puedes usar el método .append()\nvar greet = \u0026#34;Hello, world\u0026#34; greet.append(\u0026#34;!\u0026#34;) En el último código, el valor de saludo es Hello, world!\nInterpolación de cadenas #Pero quizás la característica más utilizada en las cadenas podría ser la interpolación de cadenas. Permite usar valores de constantes o variables dentro de una cadena.\nEn este caso, puedes hacerlo escribiendo el nombre de la constante o variable, dentro de paréntesis \u0026ldquo;()\u0026rdquo;, y comenzando con una barra invertida \u0026ldquo;\u0026quot;. Es decir, \\(nombreDeVariable)\nlet name = \u0026#34;Forest\u0026#34; let fullName = \u0026#34;Forest Gump\u0026#34; let introduction = \u0026#34;Hello, I am \\(name), \\(fullName)\u0026#34; El valor final de introduction es \u0026quot;Hello, I am Forest, Forest Gump\u0026quot;\nCadena de varias líneas #Para terminar (aunque no se utiliza a menudo en aplicaciones del mundo real), tal vez a veces necesites guardar textos más largos en una cadena, y podría ser difícil leer el valor para otros programadores o para ti mismo. En este caso, puedes usar una cadena de varias líneas.\nPara guardar una cadena de varias líneas, solo necesitas escribir tres comillas al principio, y terminar con otras tres en una sola línea. Por ejemplo:\nlet text = \u0026#34;\u0026#34;\u0026#34; To be, or not to be, that is the question: Whether \u0026#39;tis nobler in the mind to suffer The slings and arrows of outrageous fortune, Or to take arms against a sea of troubles, And by opposing end them? To die, to sleep; \u0026#34;\u0026#34;\u0026#34; First triple double quotes doesn\u0026rsquo;t need to be in a single line, but it helps to focus in text value.\nEl primer conjunto de tres comillas dobles no necesita estar en una sola línea, pero ayuda a centrarse en el valor del texto. Puedes ver métodos útiles en la publicación. Métodos útiles para cadenas\n","date":"6 febrero 2023","permalink":"/es/blog/cadenas-swift/","section":"Blog","summary":"Como en otros lenguajes, las cadenas son un tipo básico que permite guardar texto","title":"Cadenas en Swift"},{"content":"La programación ha sido utilizada a menudo para procesar números y obtener resultados difíciles de calcular para los humanos: distancias del universo, radios de planetas, pi\u0026hellip;\nAsí, es parte del aprendizaje fundamental, en Swift en particular y en programación en general.\nBásicamente hay 2 tipos de números en Swift: Enteros y números de coma flotante. Cada uno representa un rango diferente y se utiliza para diferentes objetivos.\nEnteros #Un número entero (también llamado int, abreviado) es posiblemente el número más utilizado. Podríamos decir que es el más simple, porque no tiene componente fraccional.\nPuede ser positivo, cero o negativo. Por ejemplo, números enteros son: 5, -3, 99, -256\u0026hellip;\nAdemás, Swift proporciona enteros con signo y sin signo para 8,16, 32 y 64 bits. Siguiendo la convención de nombres de C, el tipo de número sin signo de 8 bits es UInt8, mientras que el de 16 bits con signo es Int16. Pero, no se utiliza frecuentemente en la mayoría de las aplicaciones desarrolladas.\nRango de enteros #Depende del número de bits, pero cada uno tiene un número máximo y mínimo para almacenar. Puedes comprobarlo en la siguiente lista.\nUInt8: de 0 a 255 UInt16: de 0 a 65535 UInt32: de 0 a 4294967295 UInt64: de 0 a 18446744073709551615 Int8: de -128 a 127 Int16: de -32768 a 32767 Int32: de -2147483648 a 2147483647 Int64: de -9223372036854775808 a 9223372036854775807 Pero, si no recuerdas los valores, puedes usar los métodos .max o .min\nlet minValue = Int.min //minValue is equal to let maxValue = Int.max //maxValue is equal to Números de coma flotante #A diferencia de los enteros, los números de coma flotante tienen un componente fraccional. Pero, al igual que los enteros, pueden ser positivos o negativos. Existen dos tipos de números de punto flotante con signo\nDoble #Los números Double representan un número de punto flotante de 64 bits y tienen una precisión de al menos 15 dígitos decimales.\nFlotante #Los números Float representan un número de punto flotante de 32 bits y tienen una precisión de al menos 6 dígitos decimales.\nNOTA: Necesitarás Double o Float dependiendo de múltiples factores, pero si cualquiera de los dos fuera apropiado, la documentación de Swift recomienda usar Double.\n","date":"30 enero 2023","permalink":"/es/blog/numeros-swift/","section":"Blog","summary":"Programar ha sido a menudo para procesar números y obtener resultados demasiado difíciles de calcular por humanos","title":"Números en Swift"},{"content":"La programación es una forma de gestionar datos y, normalmente, es necesario guardar varios valores temporalmente: para hacer uso de ellos después de otras operaciones, para mostrarlos, transformarlos\u0026hellip;\nPor este motivo, igual que otros lenguajes de programación, Swift es capaz de almacenar valores en constantes y variables.\nGracias a ellas, puedes asociar un nombre que elijas a un valor.\nConstantes #Un valor constante se guarda en un espacio de memoria y no se puede modificar. Una vez que un valor se establece en una constante, permanece inmutable.\nCómo declarar una constante #Para declarar una constante debes comenzar con la palabra reservada let, seguida del nombre que elijas. Luego, debes usar el operador = y asignar un valor.\nEn el siguiente ejemplo, let es la palabra reservada para constantes, survivor el nombre de la constante y el valor asignado a survivor es Jack Shepard.\nlet survivor = “Jack Shepard” El valor está entre comillas dobles porque es un tipo de valor cadena o String. Puedes leer sobre Strings en la documentación oficial: Cadenas y caracteres\n¿Sabes por qué Swift usa let en lugar de const o similar a otros idiomas? Viene del mundo de las matemáticas en inglés, donde dicen cosas como:\nlet x be equal to 5.\nVariables #Una variable es un valor que puedes modificar una vez declarado. Por lo que es un valor mutable.\nCómo declarar una variable #Para declarar una variable, la estructura es la misma que una constante, pero debes usar la palabra reservada var\nPor lo que, para declarar una variable debes escribir\nvar videogame = “Metal Gear Solid” Ok, pero si queremos cambiar el valor de var, ¿cómo deberíamos hacerlo? Fácil, sólo necesitas asignar un nuevo valor y no escribir la palabra reservada var.\nvideogame = “Uncharted” Nombrar una constante, varialbe o valor #Puedes utilizar casi cualquier carácter para el nombre de una constante o variable, incluidos los caracteres Unicode. Lo que significa que puedes usar, por ejemplo, emojis.\nPero es algo que no recomiendo. ¿Por qué? Porque el nombre de una constante o de una variable, debe explicar sin dejar lugar a dudas lo que se guarda en su interior.\nPor ejemplo, ¿que significa el valor 10?\nlet times = 10 let numberOfTimesIHaveSeenBackToTheFutureTrilogy = 10 En el segundo caso caso es más fácil saberlo.\nConclusión #Por lo tanto, no te preocupes por la cantidad de caracteres del nombre. Es más recomendable utilizar un nombre grande (pero descriptivo) que utilizar otro más corto que no especifique qué almacena. Y, hoy en día, los IDEs se encargan de autocompletar los nombres, así que no será tan difícil escribirlos 😉\n","date":"16 enero 2023","permalink":"/es/blog/constantes-variables-swift/","section":"Blog","summary":"Como guardar y gestionar valores de datos en Swift","title":"Constantes y variables para guardar datos"},{"content":"¡Hola! Hoy estoy muy contento porque, he refactorizado mi blog 😉\nEsta no es mi primera experiencia escribiendo en mi blog pero, 2022 fue un año con cambios y nuevos desafíos en mi vida laboral, así que, decidí reiniciar mi blog para alinearlo con lo que estoy haciendo en mi día a día.\nPor esta razón, este es mi primer post, pero solo en esta nueva versión de mi blog.\nSobre mí #Si tengo que hablar de mí en una frase, me gusta decir que soy un apasionado de la programación y la tecnología.\nActualmente, trabajo como Desarrollador iOS en Hiberus, una consultora tecnología fundada en España, pero que crece rápidamente y está abriendo nuevas oficinas en lugares como Berlín, Londres, México DF o Miami.\nMi experiencia laboral ha estado principalmente enfocada en IT y, además de en programación, tengo experiencia previa trabajando como QA o DevOps.\nDebido a que soy un entusiasta de los productos de Apple, decidí aprender Swift y especializarme en el desarrollo de aplicaciones para su ecosistema. No solo para dispositivos iOS, sino también para MacOS o el resto de los sistemas operativos de Apple.\nMi vida personal #Nací en Valencia (España), donde vivo actualmente. Y nací en los 80’s, la época del Spectrum, Atari y las primeras videoconsolas de Sega o Nintendo. Así que crecí y disfruté jugando videojuegos con mi Sega Megadrive, y viendo dibujos animados como He-man, Oliver y Benji o Bola de Dragón.\nSoy el orgulloso padre de Lucas 👶🏻, mi hijo de 3 años que se ha convertido en el CEO de casa, y el orgulloso marido de Lorena, la mejor compañera de vida que podría tener. Una mujer maravillosa, con un poder especial para tratar con la infancia (Y conmigo 😅)\nActualmente, paso mis horas fuera del trabajo con mi familia o mis aficiones, como: disfrutar de series de TV, ver Fórmula 1, leer o jugar al ajedrez.\nPor qué escribo en este blog #Conocimiento #La primera razón (y la más importante) es para aprender. Para mí, hay 3 niveles de conocimiento:\n1º: Cuando alguien te enseña algo, o lo aprendes viendo un video, leyendo un libro\u0026hellip; 2º: Cuando eres capaz de hacer lo que has aprendido. 3º: Cuando eres capaz de enseñar a alguien lo que sabes. Y, por esta razón, escribir en un blog me ayuda a aprender enseñando a otros.\nPara ayudar #La segunda, es ayudar a otros en lo que hoy disfruto cada vez más: programar. Creo que a todos les gusta ayudar a los demás, y además, esta es mi manera de extender la ayuda que recibo de otros.\nExpresar mi opinión #Otra razón es que, como Desarrollador iOS, necesito tener un profundo entendimiento sobre todo el ecosistema de Apple, así que, este será un lugar para organizar mis pensamientos sobre las noticias, productos, eventos como la WWDC\u0026hellip; pero siempre enfocado en la programación.\nPracticar inglés #Y la última razón, (pero no menos importante), practicar escribir documentación técnica en inglés. Mi lengua materna es el español, pero la globalización y el trabajo remoto han abierto muchas oportunidades. Y el inglés es hoy el idioma clave para aprender y trabajar.\nSi quieres saber más sobre mí, no dudes en consultar mis enlaces de redes sociales\n¡Así que, espero que disfrutes de mis posts! 🙂\n","date":"2 enero 2023","permalink":"/es/blog/mi-nuevo-primer-post/","section":"Blog","summary":"Quién soy y por qué he relanzado mi blog","title":"Mi (nuevo) primer post"},{"content":"Puedes encontrarme en las siguientes redes sociales:\n@oscarmorenodev\nOscar Moreno\nO si prefieres, puedes escribirme un email a oscar@oscarmoreno.com\n","date":null,"permalink":"/es/contacto/","section":"Oscar Moreno | Desarrollador iOS ","summary":"\u003cp\u003ePuedes encontrarme en las siguientes redes sociales:\u003c/p\u003e\n\u003cp\u003e\n\n  \u003cspan class=\"icon relative inline-block align-text-bottom\"\u003e\n    \u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 512 512\"\u003e\u003cpath fill=\"currentColor\" d=\"M389.2 48h70.6L305.6 224.2 487 464H345L233.7 318.6 106.5 464H35.8L200.7 275.5 26.8 48H172.4L272.9 180.9 389.2 48zM364.4 421.8h39.1L151.1 88h-42L364.4 421.8z\"/\u003e\u003c/svg\u003e\n\n  \u003c/span\u003e\n\n \u003ca href=\"https://twitter.com/oscarmorenodev\" target=\"_blank\" rel=\"noreferrer\"\u003e@oscarmorenodev\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\n\n  \u003cspan class=\"icon relative inline-block align-text-bottom\"\u003e\n    \u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 448 512\"\u003e\u003cpath fill=\"currentColor\" d=\"M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z\"/\u003e\u003c/svg\u003e\n\n  \u003c/span\u003e\n\n \u003ca href=\"https://linkedin.com/in/oscarmorenodev\" target=\"_blank\" rel=\"noreferrer\"\u003eOscar Moreno\u003c/a\u003e\u003c/p\u003e","title":"Contacto"},{"content":"Un email. Uno esencial. Cada semana. #¿Buscas una newsletter Swift que te ahorre tiempo y te mantenga al día con lo más relevante del desarrollo en plataformas Apple?\nOne Swift Thing es para ti.\nCada semana, reviso las newsletters Swift más destacadas —sobre Swift, SwiftUI, Xcode, frameworks, productividad y nuevas herramientas— y selecciono un solo artículo. El más valioso. El que merece tu atención.\n🧭 ¿Por qué una sola cosa? #Porque creo en la constancia.\nEs mejor aprender una idea útil cada semana que devorar veinte y luego pasar meses sin tocar nada nuevo.\nOne Swift Thing nace de esa filosofía: menos ruido, más intención.\nUna newsletter Swift que te ayuda a avanzar poco a poco, sin agobios.\n💡 ¿Y si tengo tiempo para más? #Te animo a que te suscribas a varias newsletters Swift si puedes. Yo mismo lo hago. Hay mucho contenido de calidad ahí fuera.\nPero si no puedes dedicar tiempo a revisar qué leer, si no sabes qué es realmente importante esta semana…\nAhí es donde entra esta newsletter Swift.\n✅ ¿Qué obtendrás? # 📌 Una selección personal, semanal y sin automatismos. 🧠 Un solo artículo, con contexto: por qué lo he elegido y qué puedes aprender. ✉️ En tu bandeja cada lunes. 🚫 Sin listas interminables. 🎯 ¿Para quién es? # Para desarrolladores Apple que valoran su tiempo. Para quienes quieren seguir aprendiendo, pero de forma sostenible. Para quienes ya no pueden revisar todas las newsletters Swift… pero no quieren perderse lo esencial. 📩 Suscríbete gratis #Solo una cosa útil a la semana. Una newsletter Swift pensada para desarrolladores como tú.\nOne Swift Thing * indica que es obligatorio Dirección de email * /* real people should not fill this in and expect good things - do not remove this or risk form bot signups */ 🔒 100% privacidad. No comparto tus datos con nadie.\n🔁 Puedes darte de baja en cualquier momento, sin preguntas.\n","date":null,"permalink":"/es/newsletter/","section":"Oscar Moreno | Desarrollador iOS ","summary":"\u003ch2 id=\"un-email-uno-esencial-cada-semana\" class=\"relative group\"\u003eUn email. Uno esencial. Cada semana. \u003cspan class=\"absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100\"\u003e\u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\" style=\"text-decoration-line: none !important;\" href=\"#un-email-uno-esencial-cada-semana\" aria-label=\"Ancla\"\u003e#\u003c/a\u003e\u003c/span\u003e\u003c/h2\u003e\u003cp\u003e¿Buscas una \u003cstrong\u003enewsletter Swift\u003c/strong\u003e que te ahorre tiempo y te mantenga al día con lo más relevante del desarrollo en plataformas Apple?\u003cbr\u003e\n\u003cstrong\u003eOne Swift Thing\u003c/strong\u003e es para ti.\u003c/p\u003e\n\u003cp\u003eCada semana, reviso las newsletters Swift más destacadas —sobre Swift, SwiftUI, Xcode, frameworks, productividad y nuevas herramientas— y selecciono \u003cstrong\u003eun solo artículo\u003c/strong\u003e. El más valioso. El que merece tu atención.\u003c/p\u003e","title":"One Swift Thing"},{"content":"Recopilo datos de uso utilizando Google Analytics con el fin de visualizar el tráfico en este sitio web.\nTodos los datos son anónimos y no vendo ni comparto ningún dato con terceros.\nSi decides rechazarlo, no se recopilará ninguna información.\n","date":null,"permalink":"/es/privacidad/","section":"Oscar Moreno | Desarrollador iOS ","summary":"\u003cp\u003eRecopilo datos de uso utilizando Google Analytics con el fin de visualizar el tráfico en este sitio web.\u003c/p\u003e\n\u003cp\u003eTodos los datos son anónimos y no vendo ni comparto ningún dato con terceros.\u003c/p\u003e\n\u003cp\u003eSi decides rechazarlo, no se recopilará ninguna información.\u003c/p\u003e","title":"Privacidad"},{"content":"Si tengo que hablar sobre mí en una frase, me gusta decir que soy un apasionado de la programación y del mundo tecnológico.\nMi vida profesional #Actualmente, trabajo como Desarrollador iOS en Openbank, el banco online de Grupo Santander, que disponde de aplicaciones usadas por millones de personas a lo largo de Europa y América.\nPero, mi experiencia laboral ha estado principalmente enfocada en IT. Además de programar, tengo experiencia previa trabajando como ingeniero QA o DevOps.\nRecientemente, debido a que soy un usuario entusiasta de los productos de Apple, decidí aprender Swift y especializarme en el desarrollo de su ecosistema. No solo para dispositivos iOS, sino para MacOS o el resto de los sistemas operativos de Apple.\nMi vida personal #Nací en Valencia (España), donde vivo actualmente,. Y nací en los 80, la época del Spectrum, Atari y las primeras videoconsolas de Sega o Nintendo. Así que crecí y disfruté jugando videojuegos con mi Sega Megadrive, viendo dibujos animados como He-man, Dragon Ball o Capitán Tsubasa.\nSoy el orgulloso padre de Lucas y Vega, los pequeños que se han convertido en los reyes de la casa, y marido de Lorena, la mejor compañera de vida que podría tener. Una mujer maravillosa, con un poder especial para tratar con la infancia (Y conmigo 😅)\nActualmente, paso mis horas fuera del trabajo con mi familia o mis aficiones, como: disfrutar de series de TV o ver carreras de Fórmula 1.\n","date":null,"permalink":"/es/sobre-mi/","section":"Oscar Moreno | Desarrollador iOS ","summary":"\u003cp\u003eSi tengo que hablar sobre mí en una frase, me gusta decir que soy un apasionado de la programación y del mundo tecnológico.\u003c/p\u003e\n\u003ch3 id=\"mi-vida-profesional\" class=\"relative group\"\u003eMi vida profesional \u003cspan class=\"absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100\"\u003e\u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\" style=\"text-decoration-line: none !important;\" href=\"#mi-vida-profesional\" aria-label=\"Ancla\"\u003e#\u003c/a\u003e\u003c/span\u003e\u003c/h3\u003e\u003cp\u003eActualmente, trabajo como Desarrollador iOS en \u003ca href=\"https://www.openbank.com\" target=\"_blank\" rel=\"noreferrer\"\u003eOpenbank\u003c/a\u003e, el banco online de \u003ca href=\"https://santander.com\" target=\"_blank\" rel=\"noreferrer\"\u003eGrupo Santander\u003c/a\u003e, que disponde de aplicaciones usadas por millones de personas a lo largo de Europa y América.\u003c/p\u003e\n\u003cp\u003ePero, mi experiencia laboral ha estado principalmente enfocada en IT. Además de programar, tengo experiencia previa trabajando como ingeniero QA o DevOps.\u003c/p\u003e","title":"Sobre mí"},{"content":"","date":null,"permalink":"/es/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":null,"permalink":"/es/tags/","section":"Tags","summary":"","title":"Tags"}]