[{"content":"","date":null,"permalink":"/es/apps/","section":"Apps","summary":"","title":"Apps"},{"content":"","date":null,"permalink":"/es/","section":"Oscar Moreno | Desarrollador iOS Ô£ø","summary":"","title":"Oscar Moreno | Desarrollador iOS Ô£ø"},{"content":"Aprende Swift jugando. Avanza cada d√≠a en solo unos minutos.\nQuizzySwift es un juego de preguntas divertido y eficaz que te ayuda a aprender a programar en Swift ‚Äî el potente lenguaje que utilizan los desarrolladores de Apple en todo el mundo.\nTanto si est√°s empezando desde cero como si quieres repasar tus conocimientos, QuizzySwift hace que aprender a programar sea f√°cil y entretenido. Solo necesitas unos minutos al d√≠a para adquirir conocimientos reales de programaci√≥n.\nAprende sin esfuerzo #Convierte sesiones cortas de pr√°ctica en avances reales en Swift ‚Äî casi sin darte cuenta.\nMejora cada semana #Desarrolla habilidades s√≥lidas con pr√°ctica diaria constante. Observa c√≥mo aumenta tu confianza mientras subes de nivel.\nPrep√°rate para desaf√≠os reales #Refuerza tus conocimientos para entrevistas, proyectos personales o tu pr√≥ximo trabajo como desarrollador Swift.\nQuizzySwift es ideal para cualquiera que quiera dominar Swift de forma inteligente ‚Äî mediante repetici√≥n divertida, feedback claro y resultados reales.\n","date":null,"permalink":"/es/apps/quizzyswift/","section":"Apps","summary":"QuizzySwift es un juego de preguntas divertido y eficaz que te ayuda a aprender a programar en Swift","title":"QuizzySwift"},{"content":"NSBuddy es una app exclusiva para macOS dise√±ada para desarrolladores Swift que quieren mejorar su eficiencia al programar y ahorrar un tiempo valioso. Tanto si eres un desarrollador con experiencia como si est√°s empezando, NSBuddy re√∫ne todas las herramientas esenciales en un solo lugar, permiti√©ndote mantener el foco y la productividad.\nPensada espec√≠ficamente para proyectos con Swift y SwiftUI, NSBuddy ofrece un conjunto de utilidades pr√°cticas creadas para simplificar el trabajo diario de quienes desarrollan para plataformas Apple.\nPor qu√© elegir NSBuddy: # Gesti√≥n eficiente del disco: Elimina f√°cilmente archivos temporales programando o limpiando manualmente Derived Data y las previsualizaciones de Xcode, liberando espacio importante en disco.\nGeneraci√≥n de c√≥digo Swift: Acelera tu flujo de trabajo generando structs en Swift y consultas de Core Data directamente desde JSON u otros modelos.\nConversi√≥n de formatos sin esfuerzo: Convierte archivos JSON en modelos Swift, transforma formatos de color o genera representaciones listas para usar en c√≥digo en segundos.\nC√≥digo m√°s legible: Da formato y embellece autom√°ticamente JSON para que tu c√≥digo est√© limpio y listo para el desarrollo.\nValidaci√≥n r√°pida: Verifica y prueba al instante tus expresiones regulares y estructuras JSON para evitar errores antes de que ocurran.\nRecursos personalizados: Organiza tus herramientas y documentaci√≥n favoritas con enlaces personalizados, accediendo r√°pidamente a los recursos que m√°s utilizas.\nEspacio de trabajo a medida: Personaliza tu experiencia eligiendo solo las herramientas que necesitas, manteniendo tu entorno limpio y enfocado en lo importante.\nHaz tu proceso de desarrollo m√°s fluido con NSBuddy, donde cada herramienta est√° dise√±ada para acompa√±arte en tu camino como desarrollador Swift.\nPronto en la App Store.\n","date":null,"permalink":"/es/apps/nsbuddy/","section":"Apps","summary":"NSBuddy es una app exclusiva para macOS dise√±ada para desarrolladores Swift que quieren mejorar su eficiencia al programar y ahorrar un tiempo valioso.","title":"NSBuddy"},{"content":"","date":null,"permalink":"/es/blog/","section":"Blog","summary":"","title":"Blog"},{"content":"Una de mis caracter√≠sticas favoritas en Swift son los enums.\nSon f√°ciles de entender y de utilizar.\nPero en ocasiones, no les sacamos el provecho que podr√≠amos.\nY eso se puede conseguir (entre otras formas) con los valores asociados.\nLos valores asociados te permiten recoger valores de distintos tipos, asociados a los distintos casos de la enumeraci√≥n.\nSi lo necesitas, tambi√©n escrib√≠ un art√≠culo sobre las enumeraciones\nAs√≠ que hoy, te muestro como poder sacarles partido, y en qu√© ocasiones es una ventaja utilizarlos.\nC√≥mo definir los valores asociados en tus enumeraciones #Solo debes incluir a continuaci√≥n de cada caso, el tipo del valor que quieres asociar.\nPuedes definir la cantidad de valores que quieras.\nAunque, como en otros casos, no es recomendable que sea un n√∫mero alto de valores.\nDe esta forma, mejorar√°s la legibilidad y reducir√°s la complejidad.\nAdem√°s, opcionalmente, tambi√©n puedes indicar el nombre del par√°metro.\nstruct User { let name: String } enum Resolution { case completed case dropped } enum State { case toDo(estimatedDate: Date) case inProgress(assignee: User) case done(time: Int) case close(Resolution) } Como puedes ver, cada caso del enum State tiene un valor asociado.\nTodos cuentan con el nombre del par√°metro, excepto el caso de cierre.\nAsignar valores asociados a un caso de una enumeraci√≥n #Una vez definido el enum, cuando escojas un caso, debes asignarle un valor del tipo especificado.\nlet state = State.toDo(estimatedDate: Date.now.addingTimeInterval(86400)) let state2 = State.inProgress(assignee: .init(name: \u0026#34;John\u0026#34;)) let state3 = State.done(time: 10) let state4 = State.close(.completed) Adem√°s, esto tambi√©n ocurre cuando utilizar un switch para manejar las distintas situaciones.\nPero, de esta forma, el par√°metro que asignas en cada caso del switch , no tiene por qu√© tener el mismo nombre que en la definici√≥n.\nNi est√°s obligado a llamar al par√°metro si no lo necesitas para la gesti√≥n.\nLo puedes ver mejor en este ejemplo.\nfunc manageTask(_ task: State) { switch task { case .toDo: print(\u0026#34;Task is not started yet.\u0026#34;) case .inProgress(let assignee): print(\u0026#34;\\(assignee) is working on it\u0026#34;) case .done(var duration): duration /= 60 print(\u0026#34;Task was completed in \\(duration) hours\u0026#34;) case .close(let finalState): print(\u0026#34;Task is finished. It was \\(finalState)\u0026#34;) } } manageTask(.toDo(estimatedDate: Date.now.addingTimeInterval(172.800))) let user = User(name: \u0026#34;Erlich Bachman\u0026#34;) manageTask(.inProgress(assignee: user)) manageTask(.done(minutes: 90.0)) Como puedes ver, en el caso del toDo no se utiliza la fecha estimada de inicio, as√≠ que no necesitas recuperar ese valor.\nMientras que en los casos done y close, no coincide el nombre del par√°metro de la definici√≥n, con el del switch.\nVentajas de usar tipos asociados para las enumeraciones #Mejora de la legibilidad #S√© que lo digo en muchas ocasiones, pero pasamos m√°s tiempo leyendo c√≥digo que escribi√©ndolo.\nAs√≠ que mejor que esa actividad sea lo m√°s sencilla posible.\nGracias a los valores asociados, no hace falta que crees estructuras externas con las que asociar a los casos.\nAdem√°s, tambi√©n se mantendr√≠a m√°s simple la jerarqu√≠a del c√≥digo sin esas clases.\nMayor estabilidad #El tipado fuerte una de las mayores ventajas de Swift.\nY se refuerza con esta caracter√≠stica.\nDebes definir el tipo de cada valor asociado.\nY solo puedes asignar un valor de ese tipo, con lo que podr√°s evitar valores por un tipado incorrecto.\nAdem√°s, si est√°s usando un switch para gestionar las acciones seg√∫n el caso, est√°s obligado a indicar todos los casos.\nY el mismo Xcode, te ayuda a a√±adir los valores asociados si los necesitas necesitas.\nEjemplos de uso de valores asociados #Manejo de errores #Es f√°cil que para complementar la informaci√≥n de un error, necesites datos adicionales.\nEsta informaci√≥n podr√≠a ser el mensaje que debes mostrar, o algo que necesites para solucionarlo.\nenum ArcadeMachineError: Error { case invalidSelection case insufficientFunds(coinsNeeded: Int) case userUnknown(user: String) } func displayError(_ error: ArcadeMachineError) { switch error { case .invalidSelection: print(\u0026#34;Invalid selection\u0026#34;) case .insufficientFunds(let coinsNeeded): print(\u0026#34;Insufficient funds. You need \\(coinsNeeded) coins\u0026#34;) case .userUnknown(let user): print(\u0026#34;User \\(user) is unknown\u0026#34;) } } displayError(.userUnknown(user: \u0026#34;pacman\u0026#34;)) Definir acciones de la vista #Las acciones que se ejecutan a raiz de la interacci√≥n del usuario, suelen requerir valores relacionados:\nenum UserAction { case login(username: String, password: String) case logout case updateProfile(name: String, age: Int) } func performAction(_ action: UserAction) { switch action { case .login(let username, let password): print(\u0026#34;Logging in with \\(username) and \\(password)\u0026#34;) case .logout: print(\u0026#34;Logging out\u0026#34;) case .updateProfile(let name, let age): print(\u0026#34;Updating profile with name: \\(name), age: \\(age)\u0026#34;) } } performAction(.updateProfile(name: \u0026#34;grogu\u0026#34;, age: 50) Modelar datos complejos #Por ejemplo, cuando tratas con elementos multimedia.\n√âstos, suelen llevar asociados distintos tipos de datos.\nCon una enumeraci√≥n y valores asociados, es tan sencillo definirlo como gestionarlo.\nenum MediaType { case image(url: String, resolution: (width: Int, height: Int)) case video(url: String, duration: TimeInterval) case audio(url: String, bitrate: Int) } func handleMedia(_ media: MediaType) { switch media { case .image(let url, let resolution): print(\u0026#34;Image URL: \\(url), Resolution: \\(resolution.width)x\\(resolution.height)\u0026#34;) case .video(let url, let duration): print(\u0026#34;Video URL: \\(url), Duration: \\(duration) seconds\u0026#34;) case .audio(let url, let bitrate): print(\u0026#34;Audio URL: \\(url), Bitrate: \\(bitrate) kbps\u0026#34;) } } handleMedia(.video(url: \u0026#34;R.Astley-never_gonna_give_you_up.mp4\u0026#34;, duration: 213)) Gestionar estados #√âste es, posiblemente, el uso m√°s extendido de los valores asociados en las enumeraciones.\nY es que, los estados de una app, suelen conllevar otro dato relacionado con el usuario, la vista que se muestra, etc\u0026hellip;\nenum AppState { case onboarding(step: Int) case loggedIn(userID: String) case loggedOut } func handleAppState(_ state: AppState) { switch state { case .onboarding(let step): print(\u0026#34;Onboarding step \\(step)\u0026#34;) case .loggedIn(let userID): print(\u0026#34;User logged in with ID \\(userID)\u0026#34;) case .loggedOut: print(\u0026#34;User logged out\u0026#34;) } } handleAppState(.onboarding(step: 1)) Filtros avanzados #Los valores asociados tambi√©n pueden ser muy √∫tiles con los filtros.\nYa que, cuando los utilizas, necesitas definir el valor de dichos filtros.\nAs√≠, podr√°s establecerlos f√°cilmente.\nenum Filter { case priceRange(min: Double, max: Double) case category(name: String) case availability(isInStock: Bool) } func applyFilter(_ filter: Filter) { switch filter { case .priceRange(let min, let max): print(\u0026#34;Filter by price range: \\(min) - \\(max)\u0026#34;) case .category(let name): print(\u0026#34;Filter by category: \\(name)\u0026#34;) case .availability(let isInStock): print(\u0026#34;Filter by availability: \\(isInStock ? \u0026#34;In stock\u0026#34; : \u0026#34;Out of stock\u0026#34;)\u0026#34;) } } applyFilter(.priceRange(min: 10.0, max: 20.0)) Conclusiones #Has podido ver lo sencillo que es asociar valores a los distintos casos de un enum:\n√önicamente debes definirlos a continuaci√≥n de cada caso Aprovecha el autocompletado de XCode para a√±adir los valores que necesites Te ayudan a tener un c√≥digo m√°s estable, legible y seguro. Como ejemplos donde los puedes utilizar tienes:\nManejo de errores Definici√≥n de acciones de la vista Modelado de datos complejos Gesti√≥n de estados Filtros avanzados Y si quieres practicar, aqu√≠ te dejo un playground con los ejemplos: enum-associated-values.playground.zip Fuente #Valores asociados de Enumeraciones - Documentaci√≥n oficial de Swift\n","date":"15 octubre 2024","permalink":"/es/blog/valores-asociados-enum/","section":"Blog","summary":"Descubre c√≥mo gestionar m√∫ltiples tipos de datos en una sola enumeraci√≥n","title":"Mejora tus enumeraciones con los valores asociados"},{"content":"Hace unas semanas escribiendo sobre los key-path me llam√≥ la atenci√≥n el uso de los subscripts.\nEn espa√±ol lo podr√≠amos traducir como sub√≠ndices.\nAs√≠, que segu√≠ investigando sobre ello, y como he visto las ventajas que ofrecen, te explico como aprovecharlos para tener un c√≥digo m√°s personalizado y legible.\nQu√© son los subscripts en Swift #Los subscripts en Swift te facilitan una forma flexible de acceder a elementos que se encuentran en colecciones, secuencias o tipos personalizados.\nEsos tipos personalizados podr√≠an ser clases, estructuras o enumeraciones.\nOfrecen una sintaxis sencilla para establecer y recuperar valores sin necesidad de m√©todos separados para getters y/o setters.\nLos subscripts son m√©todos especiales que permiten acceder a elementos en un tipo similar a una colecci√≥n.\nY para ello, se hace uso de la misma notaci√≥n que los arrays. Es decir, mediante corchetes [ ].\nC√≥mo se crean subscripts #Para crear un subscript, simplemente debes crear un m√©todo con el nombre subscript.\nsubscript(index: Index) -\u0026gt; OutputType { get { // Return a value } set(newValue) { // Set a value } } No es obligadorio usar el set, podr√≠as simplemente devolver el valor, por lo que tampoco ser√≠a necesario indicar expl√≠citamente el get.\nsubscript(index: Index) -\u0026gt; OutputType { // Return a value } C√≥mo acceder a elementos mediante subscripts en Swift #Siguiendo la sintaxis explicada, aqu√≠ puedes ver como crear un m√©todo subscript para una estructura que te devuelva el elemento que le pidas de la secuencia Fibonacci.\nstruct Fibonacci { subscript(position: Int) -\u0026gt; Int { guard n \u0026gt; 1 else { return n } var a = 0, b = 1 for _ in 2...n { let temp = a + b a = b b = temp } return b } } Como ves, al m√©todo subscript, se le puedes pasar un par√°metro position para saber la posici√≥n del elemento que quieres obtener.\nComo tambi√©n puedes comprobar, no necesitas un setter para establecer un valor.\nAs√≠ que si le indicas la posici√≥n que quieres, podr√°s tener el valor de esa posici√≥n.\nlet fib = Fibonacci() // Prints \u0026#34;13\u0026#34; print(fib[7]) Subscripts con m√∫ltiples par√°metros #Los subscripts pueden tomar m√∫ltiples par√°metros, permitiendo formas de acceso m√°s complejas.\nAqu√≠ puedes ver un ejemplo de una estructura para formar un cubo en 3D.\nstruct Cube3D { private var cells: [[[Int]]] let size: Int init(size: Int, defaultValue: Int = 0) { self.size = size self.cells = Array(repeating: Array(repeating: Array(repeating: defaultValue, count: size), count: size), count: size) } subscript(x: Int, y: Int, z: Int) -\u0026gt; Int { get { guard isValidIndex(x: x, y: y, z: z) else { fatalError(\u0026#34;Index out of range\u0026#34;) } return cells[x][y][z] } set { guard isValidIndex(x: x, y: y, z: z) else { fatalError(\u0026#34;Index out of range\u0026#34;) } cells[x][y][z] = newValue } } subscript(xRange: Range\u0026lt;Int\u0026gt;, yRange: Range\u0026lt;Int\u0026gt;, z: Int) -\u0026gt; [[Int]] { guard isValidRange(xRange: xRange, yRange: yRange, z: z) else { fatalError(\u0026#34;Range out of cube bounds\u0026#34;) } return xRange.map { x in yRange.map { y in cells[x][y][z] } } } private func isValidIndex(x: Int, y: Int, z: Int) -\u0026gt; Bool { return x \u0026gt;= 0 \u0026amp;\u0026amp; x \u0026lt; size \u0026amp;\u0026amp; y \u0026gt;= 0 \u0026amp;\u0026amp; y \u0026lt; size \u0026amp;\u0026amp; z \u0026gt;= 0 \u0026amp;\u0026amp; z \u0026lt; size } private func isValidRange(xRange: Range\u0026lt;Int\u0026gt;, yRange: Range\u0026lt;Int\u0026gt;, z: Int) -\u0026gt; Bool { return xRange.lowerBound \u0026gt;= 0 \u0026amp;\u0026amp; xRange.upperBound \u0026lt;= size \u0026amp;\u0026amp; yRange.lowerBound \u0026gt;= 0 \u0026amp;\u0026amp; yRange.upperBound \u0026lt;= size \u0026amp;\u0026amp; z \u0026gt;= 0 \u0026amp;\u0026amp; z \u0026lt; size } } Tras los par√°metros y el inicializador, cuenta con dos m√©todos subscript.\nEl primero toma tres par√°metros de posici√≥n, para determinar el lugar en el cubo 3D, y tiene tanto un getter como un setter.\nEl segundo tambi√©n toma varios par√°metros, de tipo Range.\nEste segundo subscript, permitir√≠a obtener una porci√≥n en 2D, del cubo.\nComo est√°s tratando con colecciones y secuencias, es muy importante comprobar que nunca se accede a posiciones fuera del √≠ndice para evitar crashes. Por eso los m√©todos isValidIndex e isValidRange. Y ahora, podr√°s asignar y recuperar los valores del cubo.\nvar cube = Cube3D(size: 5, defaultValue: 0) cube[0, 0, 0] = 1 cube[1, 2, 3] = 5 cube[4, 4, 4] = 9 // Prints \u0026#34;1\u0026#34; print(cube[0, 0, 0]) // Prints \u0026#34;5\u0026#34; print(cube[1, 2, 3]) // Prints \u0026#34;9\u0026#34; print(cube[4, 4, 4]) let slice = cube[0..\u0026lt;2, 0..\u0026lt;3, 0] // Prints [[1, 0, 0], [0, 0, 0]] print(slice) Subscripts de Tipo #Tambi√©n puedes definir subscripts en el tipo mismo, en lugar de en las instancias.\nPara ello, simplemente indica la palabra clave static antes de subscript, de igual forma que har√≠as cualquier m√©todo est√°tico.\nenum DayOfWeek: Int { case monday = 1 case tuesday case wednesday case thursday case friday case saturday case sunday static subscript(index: Int) -\u0026gt; DayOfWeek? { return DayOfWeek(rawValue: index) } } Y ahora, si quieres acceder a cualquier d√≠a de la semana de la enumeraci√≥n, solo debes indicar su √≠ndice.\n// day is equal to .wednesday let day = DayOfWeek[3] F√≠jate que al lunes se le ha asignado 1 ya que, al menos en Espa√±a, el lunes es el primer d√≠a de la semana. Y queda m√°s natural acceder a √©l de esa forma. Si no se hubiera indicado, en el ejemplo anterior, day ser√≠a igual a thursday y al caso monday se acceder√≠a a trav√©s del √≠ndice 0. Conclusiones #Resumiendo, sobre los subscripts, los puntos m√°s importantes:\nProporcionan acceso abreviado a elementos de colecciones. Se pueden usar tanto para obtener, como para establecer valores. Se pueden definir m√∫ltiples subscripts para un solo tipo. Los subscripts pueden tener m√∫ltiples par√°metros de entrada. Puedes crear subscripts est√°ticos que no pertenecen a la instancia sino al tipo. Pero, ten en cuenta lo siguiente para aprovecharlos al m√°ximo:\n√ösalos cuando te faciliten una sintaxis m√°s natural para acceder a elementos en tus tipos personalizados. Recuerda manejar los errores y verificar los l√≠mites en los subscripts. Aseg√∫rate cuando debes utilizar subscripts de solo lectura o de lectura/escritura. Usa subscripts de tipo √∫nicamente cuando tenga sentido acceder a valores directamente en el tipo en lugar de en las instancias. Y como es habitual, te dejo el playground para que practiques. Subscripts.playground.zip Sources #Subscripts - Documentaci√≥n oficial de Swift\n","date":"8 octubre 2024","permalink":"/es/blog/subscripts-en-swift/","section":"Blog","summary":"Los subscripts te permiten acceder de forma m√°s flexible y personalizada a distintos datos","title":"Accede a elementos de colecciones de forma sencilla"},{"content":"A medida que la complejidad de los proyectos crecen, es habitual crear c√≥digo muy similar.\nYa sabes que la mejor forma de optimizarlo es no repetirlo.\nO al menos, aprovechar los puntos comunes.\nPues para ese caso te puede ser de gran ayuda utilizar gen√©ricos.\nPueden parecer complejos al principio.\nPero si te acostumbras a usarlos, tendr√°s un c√≥digo m√°s limpio y reutilizable.\n¬øPor qu√© usar los gen√©ricos en Swift? #Imagina que tienes un m√©todo tan sencillo como el siguiente que muestra un mensaje con un valor que pasas como par√°metro.\nfunc logString(value: String) { print(\u0026#34;INFO - Value recorded: \\(value)\u0026#34;) } // Prints \u0026#34;INFO - Value recorded: RandomResult\u0026#34; logString(value: \u0026#34;RandomResult\u0026#34;) Pero ¬øy su necesitas pasar tambi√©n un valor de tipo entero?\nEse m√©todo tambi√©n ser√≠a sencillo.\nfunc logInt(value: Int) { print(\u0026#34;INFO - Value recorded: \\(value)\u0026#34;) } // Prints \u0026#34;INFO - Value recorded: 10\u0026#34; logInt(value: 10) Pero, c√≥mo seguramente te has dado cuenta, es pr√°cticamente igual que el primero.\nAdem√°s ¬øy si quisieras capturar valores del resto de tipos de datos? Double, Bool, Float\u0026hellip;\nPosiblemente, ya has adivinado el problema que esto te puede traer.\nHabr√≠a una cantidad importante de c√≥digo duplicado, y por lo tanto, ineficiente.\nEste es el problema que resuelven los gen√©ricos.\nPermiten crear funciones y tipos, que trabajen con distintos tipos sin tener que repetir c√≥digo tan similar.\n¬øC√≥mo se crean los gen√©ricos en Swift? #Swift te permite crear tanto funciones gen√©ricas, como tus propios tipos gen√©ricos.\nNombres de par√°metros de tipos #Antes de crear gen√©ricos, es importante entender como nombrarlos.\nAunque no te hayas dado cuenta, ya has utilizado los gen√©ricos previamente.\nComo por ejemplo, cuando has utilizado un array, que se define como Array\u0026lt;Element\u0026gt;.\nSiendo Element cualquier tipo que componga el array: String, Int, Double\u0026hellip;\nLo mismo ocurre con los diccionarios, ya que en este caso se definen como Dictionary\u0026lt;Key, Value\u0026gt;.\nPor eso los diccionarios trabajan con dos elementos: una clave y un valor.\nEn algunos casos, se usan este tipo de nombres descriptivos en los gen√©ricos: Element, Key, Value\u0026hellip;\nPero en otros, cuando no hay una relaci√≥n que tenga sentido, se suele usar simplemente una letra may√∫scula.\nLa convenci√≥n, en este √∫ltimo caso, es usar T, U o V.\n¬øY si necesitas m√°s? Bueno, en ese caso\u0026hellip; igual deber√≠as revisar ese c√≥digo para evitar tantos par√°metros üòâ\nFunciones gen√©ricas #Tomando el ejemplo anterior sobre mensajes de log, podr√≠as crear una funci√≥n gen√©rica de la siguiente forma:\nfunc log\u0026lt;T\u0026gt;(value: T) { print(\u0026#34;INFO - Value recorded: \\(value)\u0026#34;) } La primera diferencia, es sustituir el tipo de los par√°metros de entrada de la funci√≥n.\nEs decir, el tipo del par√°metro value es T, en lugar de String o Int.\nT se refiere a cualquier tipo de Swift.\nY la segunda diferencia, es incluir a continuaci√≥n del nombre de la funci√≥n, el tipo gen√©rico que se va a utilizar, entre los signos \u0026lt; y \u0026gt;.\nTipos gen√©ricos #Los gen√©ricos no se limitan solo a las funciones.\nImagina que quieres crear un almacen para guardar valores de tipo String.\nPodr√≠a ser una estructura como la siguiente:\nstruct StringsStore { var content: [String] mutating func add(string: String) { content.append(string) } mutating func clear() { content.removeAll() } } Pero de nuevo, tendr√≠as la limitaci√≥n anterior si quisieras aceptar tambi√©n enteros.\nAs√≠ que, como en el caso de las funciones, habr√≠a que sustituir el tipo de los par√°metros, usando por ejemplo Element.\nY a continuaci√≥n del nombre del tipo, es donde incluir√≠as el tipo con los signos\u0026lt;Element\u0026gt;.\nstruct ValuesStore\u0026lt;Element\u0026gt; { var content: [Element] mutating func add(value: Element) { content.append(value) } mutating func clear() { content.removeAll() } } Y ahora s√≠, puedes usarlo con distintos tipos:\nvar intsStore = ValuesStore(content: [2,4,5]) intsStore.add(value: 10) // Prints \u0026#34;[2, 4, 5, 10]\u0026#34; print(intsStore.content) var doublesStore = ValuesStore(content: [2.5, 4.7, 5.8]) doublesStore.add(value: 4.7) // Prints \u0026#34;[2.5, 4.7, 5.8, 4.7]\u0026#34; print(doublesStore.content) Extensiones de gen√©ricos #Puedes crear tambi√©n extensiones de tipos gen√©ricos.\nY no necesitas indicar de nuevo el tipo de par√°metro.\nEs decir, puedes usar el mismo de su definici√≥n.\nEn el caso de ValuesStore, ser√≠a de la siguiente forma:\nextension ValuesStore { var lastElement: Element? { content.last } } // Prints \u0026#34;10\u0026#34; print(intsStore.lastElement ?? \u0026#34;Empty store\u0026#34;) Limitar los gen√©ricos con Where #Pueden haber situaciones donde necesites hacer un gen√©rico para varios tipos\u0026hellip; pero no para todos los tipos.\nImagina el siguiente caso:\nfunc sumTwoValues\u0026lt;T\u0026gt;(valueA: T, valueB: T) -\u0026gt; T { // ERROR: Binary operator \u0026#39;+\u0026#39; cannot be applied to two \u0026#39;T\u0026#39; operands valueA + valueB } En el ejemplo anterior, podr√≠as usar enteros, dobles, o cualquier tipo de n√∫mero, ya que se va a realizar una suma.\nPero no podr√≠as pasar dos valores Bool porque no pueden sumarse.\n¬øSoluci√≥n? Restringir T para que solo puedan ser tipos que conformen el protocolo Numeric.\nPara ello, simplemente usa la cla√∫sula where, para indicar los tipos de T.\nfunc sumTwoValues\u0026lt;T\u0026gt;(valueA: T, valueB: T) -\u0026gt; T where T: Numeric { valueA + valueB } Y ahora s√≠, podr√≠as ejecutar las operaciones que desearas.\n// Returns 7 sumTwoValues(valueA: 2, valueB: 5) // Returns 31.1 sumTwoValues(valueA: 10.5, valueB: 20.6) Usar m√∫ltiples gen√©ricos #En los ejemplos anteriores, has visto como usar un tipo gen√©rico: T, o Element.\nLo que significa que pod√≠a admitir cualquier tipo, pero con la limitaci√≥n que, dicho tipo siempre fuera el mismo.\nEn el ejemplo anterior, en que se sumaban dos valores, podr√≠as sumar dos enteros, o dos dobles, etc\u0026hellip; Pero siempre, el mismo valor\nUsar varios tipos, es muy sencillo, simplemente debes declarar otros tipos gen√©ricos, separ√°ndolos por comas. Y teniendo en cuenta el est√°ndar de nombres mencionado antes.\nAqu√≠ tienes otro ejemplo:\nfunc displayTemp\u0026lt;City,Temp\u0026gt;(city: City, temp: Temp) where City: StringProtocol, Temp: Numeric { print(\u0026#34;\\(city):\\(temp)\u0026#34;) } El c√≥digo anterior no es √≥ptimo, ya que se podr√≠a simplificar si los par√°metros conformaran los protocolos StringProtocol y Numeric (displayTemp(city: String, temp: any Numeric)) pero se ha usado para mostrar un ejemplo sencillo. Y ya podr√≠as usar distintos tipos de gen√©ricos\n// Prints \u0026#34;Valencia:20\u0026#34; displayTemp(city: \u0026#34;Valencia\u0026#34;, temp: 20) // Prints \u0026#34;Munich:5.5\u0026#34; displayTemp(city: \u0026#34;Munich\u0026#34;, temp: 5.5) Conclusiones #As√≠ que resumiendo lo m√°s importante:\nDebes utilizar gen√©ricos para unificar c√≥digo muy similar que realice operaciones con distintos tipos Puedes usarlos en funciones o en tipos Puedes utilizar: Palabras como Element, Key o Value si tienen relaci√≥n que tenga sentido. Letras como T, U o V para casos m√°s abrastactos. Si quieres acotar los tipos de un gen√©rico, usa la cl√°usula where para especificar un protocolo. Si solo indicas un tipo gen√©rico, siempre deber√°s usar siempre el mismo tipo en la funci√≥n o tipo. Y si quieres practicar, te dejo aqu√≠ el playground con ejemplos üôÇ\ngenerics-swift.playground.zip Fuente #Gen√©ricos - Documentaci√≥n de Swift\n","date":"1 octubre 2024","permalink":"/es/blog/genericos-swift/","section":"Blog","summary":"Los gen√©ricos en Swift permiten utilizar c√≥digo muy similar para operaciones con distintos tipos","title":"Optimizar c√≥digo en Swift gracias a los gen√©ricos"},{"content":"La pasada semana pude asistir a un evento que significaba mucho para m√≠ y al que ten√≠a muchas ganas de asistir por primera vez.\nAntes de ir, pregunt√© a las distintas personas que conoc√≠a y hab√≠an estado en a√±os anteriores.\nA√∫n as√≠, lo que pude ver super√≥ mis expectativas.\nAs√≠ que hoy, te cuento c√≥mo lo viv√≠ y por qu√© pienso que deber√≠as ir si te interesa el desarrollo para entornos Apple.\nNo sin antes dar las gracias a hiberus, que ha hecho posible que varios compa√±eros del equipo iOS hayamos podido asistir.\nUn poco de historia #NSSpain ha sido un evento notable en el calendario de los desarrolladores Apple desde su inicio en 2013.\nCreado por Luis Ascorbe y Borja Reinares el evento ya ha completado su decimosegunda edici√≥n y todo apunta (y espero) a que le quedan muchas m√°s.\nA lo largo de los a√±os, ha ganado popularidad, no solo en Espa√±a, sino a nivel internacional.\nSu ambiente colaborativo ha sido clave para construir una comunidad tan importante y cercana dentro del ecosistema Apple.\nNSSpain 2024 #La edici√≥n de 2024 se celebr√≥ del 17 al 19 de septiembre en Logro√±o, atrayendo a profesionales de todo el mundo para compartir experiencias y aprender sobre las √∫ltimas novedades en el desarrollo de iOS, macOS, watchOS y tvOS.\naaand we are open!@NSSpain XII, our 12th edition üè¥‚Äç‚ò†Ô∏è #nsspain2024 pic.twitter.com/sPAfM2Yvhd\n\u0026mdash; NSSpain XII (@NSSpain) September 18, 2024 A punto ya de empezar en #NSSpain pic.twitter.com/y2rIIxiU4Q\n\u0026mdash; √ìscar Moreno (@oscarmorenodev) September 18, 2024 Otro hecho que en mi opini√≥n favorece su √©xito es la fecha elegida.\nTras una reciente WWDC con novedades y el lanzamiento de la nueva versi√≥n de iOS, es accesible iniciar nuevas conversaciones o charlas.\nOrganizaci√≥n #Este a√±o, los talleres (opcionales, a los que no pude asistir) se realizaron el 17 de septiembre, y las conferencias principales tuvieron lugar los d√≠as 18 y 19.\nDesde el primer momento se nota que los organizadores se han preocupado por crear un entorno acogedor, promoviendo un espacio para la colaboraci√≥n y el intercambio de ideas.\nAdem√°s, se han cuidado detalles para que en los descansos, desplazamientos y horarios, tengas todo lo que necesites y en el menor tiempo posible.\nEjemplos de ello son pedir un caf√© en el break, a penas sin hacer cola, hasta la facilidad para desplazarnos a la bodega.\nLa calidad de los ponentes fue notable tambi√©n, contando con expertos que aportaron tanto conocimientos t√©cnicos como su visi√≥n del futuro del desarrollo Apple.\nCharlas #Las charlas ofrecieron un enfoque profundo sobre tecnolog√≠as como Swift, SwiftUI, Testing y Vision Pro.\nSe discutieron arquitecturas de software, accesibilidad y seguridad, proporcionando las herramientas necesarias para mejorar las aplicaciones.\nEn las charlas hubieron enfoques de todo tipo, desde m√°s divertidos, hasta m√°s inspiradores o reflexivos.\nLas sesiones tambi√©n destacaron por su diversidad tem√°tica, asegurando que tanto desarrolladores principiantes como experimentados pudieran llevarse algo valioso.\nNo voy a hablar en detalle de las charlas, ni revelar√© los aspectos t√©cnicos, ya que se publicar√°n en el canal de Vimeo de NSSpain, y te recomiendo verlas.\nPero s√≠ que quiero darte algunas claves que me parecieron importantes. Tanto desde el punto t√©cnico de desarrollo Apple, como si quieres dar charlas en este tipo de eventos.\nTampoco te cuento aqu√≠ sobre todas las charlas, no significa que las no est√°n no fueran interesantes, pero extender√≠a demasiado el art√≠culo.\nAs√≠ que cuando te recomiendo que las veas, te recomiendo que sean todas, y que t√∫ decidas las que m√°s te gustaron.\nPreparing Your App For Apple Intelligence - Matthew Cassinelli #Fue la primera de las charlas. Tenia bastante inter√©s en ella porque Apple Intelligence es una novedad muy importante para m√≠ a la que auguro (con el tiempo) un gran potencial.\nMathew plante√≥ una clave importante: Dise√±a para Apple Intelligence no para Siri Shortcuts.\nSo You Think You Know Swift? - Nick Lockwood #La expectaci√≥n de la segunda charla era alta, su t√≠tulo (So You Think You Know Swift?) planteaba un importante reto.\nSi planteas esta pregunta en un evento lleno de desarrolladores Apple, o traes algo bueno, o pierdes credibilidad, y Nick no defraud√≥.\nNos ofreci√≥ una charla muy t√©cnica con una recopilaci√≥n de trucos para escribir c√≥digo m√°s eficiente, muy bien organizada por las distintas caracter√≠sticas del lenguaje.\nBroken isolation - draining your credentials from popular macOS password managers - Wojciech Regu≈Ça #La siguiente charla, confieso que en principio no era una de las que m√°s esperaba ver.\nPero Wojciech la llev√≥ de una forma excelente, haci√©ndola f√°cil de seguir, y con un resultado sorprendente.\nNo me esperaba ver lo que ense√±√≥ y c√≥mo las aplicaciones m√°s populares de gesti√≥n de contrase√±as en macOS guardan las contrase√±as.\nCreeme, te sorprender√°.\nGetting the most from Swift Macros - Daniel Steinberg #Otra charla destacada fue la de Daniel Steinberg, quien cuenta con un importante n√∫mero de libros publicados sobre desarrollo con Swift en Editors Cut\nDaniel plante√≥ la cuesti√≥n sobre si debemos crear nuestras propias macros. Y viendo su charla tengo clara la respuesta üòÇ, as√≠ que t√∫ tampoco te la pierdas.\nFue envidiable como supo mostrar los entresijos de las Macros.\nY aunque son complejos, conocerlos es imprescindibles para aprovechar todo su potencial.\nTraining, Using, Distributing and Managing Machine Learning models for your iOS app - Felix Krause #Alguien que tambi√©n levant√≥ mucha expectaci√≥n fue Felix Krause, fundador de fastlane, la herramienta open source utilizada en numerosos proyectos iOS y Android para construir y desplegar.\nY no solo eso, porque ahora est√° inmerso en el proyecto ContextSDK, que descubre la mejor manera de monetizar tus usuarios por medio de inteligencia artificial.\nAs√≠ que como apasionado de la tecnolog√≠a, y cada vez m√°s de la IA, es una suerte poder escuchar a Felix c√≥mo enfocar un negocio basado en el ML para conseguir la informaci√≥n que necesitan tus usuarios.\nSin duda un ejemplo inspirador sobre c√≥mo aprovechar la tecnolog√≠a para aportar valor a tus usuarios.\nChasing Fun: Creating a Career You Love - Michael Flarup #Una charla que tambi√©n me impact√≥ positivamente fue la de Michael Flarup.\nTen√≠a muchas ganas de escucharle, porque el desarrollo profesional es otro de los campos que me interesan.\nMichael es un ejemplo de c√≥mo dar una charla en este tipo de eventos, no solo por lo que nos cont√≥, sino sobretodo por C√ìMO lo cont√≥.\nY es que supo captar la atenci√≥n en todo momento, mezclando su recorrido profesional con momentos muy divertidos, destacando la importancia de trabajar en aquello que amas y seguir avanzando sin decaer.\nAdem√°s, al estar m√°s centrado en dise√±o, me ha sentir m√°s curiosidad por sus libros sobre iconos para apps\nBest-in-class Pull Request - Danijela Vrzan #Tambi√©n ten√≠a ganas de ver a Danijela.\nDesde hace un tiempo sigo su blog, en el que ofrece recursos muy interesantes, no solo de Swift, sino tambi√©n de desarrollo en general o dise√±o.\nDanijela habl√≥ de un tema tan pr√°ctico como las PRs, y mostr√≥ de forma sencilla las diferencias entre una buena PR y otra que no lo es.\nHay que tener en cuenta que una Pull Request no solo afecta a quien la crea, sino tambi√©n a quien la revisar√° o qui√©n la tomar√° como ejemplo.\nDestacar√≠a el ejemplo que dio sobre como afrontar las PRs de gran de tama√±o.\nTest your apps! How testing can make you more efficient and what are best practices for maintainable tests - Krzysztof Zablocki #El segundo d√≠a empez√≥ fuerte (y no por el vino de la noche anterior en la bodega üòâ)\nEmpez√≥ hablando Krzysztof Zablocki, alguien que ha desarrollado librer√≠as y herramientas utilizadas en Apple, Disney, Airbnb, The New York Times o Vinted.\nY si con ese portfolio se a√±ade que el tema es testing, ten√≠a toda mi atenci√≥n.\nKrzysztof nos ense√±√≥ las mejores pr√°cticas que ha aprendido a lo largo de este tiempo para hacer tests, poniendo √©nfasis en que sean mantenibles.\nLo que sin duda nos puede ahorrar mucho tiempo.\nLo que me pareci√≥ mas importante es que plante√≥ en varias ocasiones la importancia de probar implementaciones, no comportamientos.\nAccessibility and the Vision Pro - Robin Kanatzar #Si te interesa la accesibilidad (y deber√≠a interesarte) tampoco puedes perderte la charla de Robin.\nTe vendr√° genial una buena base, pero si no la tienes, no te preocupes, lo explica muy bien y es f√°cil de seguir.\nExplic√≥ las diferencias y novedades con las que contamos en este campo, para el nuevo dispositivo de computaci√≥n espacial.\nY es que, en este nuevo hardware, hay muchos detalles que a√∫n no tenemos en cuenta.\nDetalles que pueden marcar la diferencia en la experiencia que tengan los usuarios que utilicen caracter√≠sticas de accesibilidad.\nSwift Server-Side. The Apple Last Frontier - Adolfo Vera #Otra de las charlas que tambi√©n me gust√≥ mucho fue la de Adolfo con el que, aunque hab√≠a escrito por RRSS previamente, conoc√≠ all√≠ por primera vez.\nAdolfo habl√≥ sobre Vapor, un herramienta para m√≠ todav√≠a infravalorada, y que aporta muchas ventajas a los desarrollos de aplicaciones, especialmente para Apple.\nNos ofreci√≥ una visi√≥n general de qu√© podemos hacer, y cual es la mejor manera, facilitando consejos que ser√°n de gran ayuda para tus primeros desarrollos con Vapor.\nPero sin duda, destacar√≠a como supo captar la atenci√≥n del p√∫blico a lo largo de la charla üôÇ.\nUna charla muy divertida y recomendable.\nThe Date-ing Game - Ellen Shapiro #Ellen tambi√©n trajo una charla muy interesante, aunque el tema no lo pudiera parecer en un primer momento: las fechas.\nFue tambi√©n muy ameno y divertido seguir la charla y descubrir la cantidad de elementos que podemos (y debemos) tener en cuenta a la hora de trabajar con fechas.\nEspecialmente si debemos trabajar con varios formatos.\nImprescindible si es tu caso.\nWarp Speed with Metal Performance Shaders - Francesco Marini #Francesco nos regal√≥ una masterclass sobre el hardware de Apple y c√≥mo aprovecharlo para mejorar el rendimiento gr√°fico de juegos o apps.\nFue una charla muy profunda, que sin duda volver√© a ver (poniendo el video en pausa por momentos üòÖ) para poder profundizar y buscar informaci√≥n relativa.\nMucha informaci√≥n y de calidad.\nMuy importante tambi√©n verla si trabajas con gr√°ficos.\n‚ÄúIt Scrolls Like Butter‚Äù Part 2: Implementing High Performance Scrolling in Threads - Tim Oliver #Tambi√©n levant√≥ gran expectaci√≥n la charla de Oliver, y es que no todos los d√≠as puedes ver en directo a un ingeniero iOS en Instagram.\nY si hay algo que haces en Instagram, es el scroll.\nAs√≠ que fue genial escuchar tantos detalles, y de una forma tan divertida y amena, que mejoran sin duda la experiencia del usuario.\nBuilding amazing user experiences using SharePlay - Vanessa Furtado #Finalizando el segundo d√≠a, me sorprendi√≥ muy gratamente la charla de Vanesa.\nHasta ese momento, pensaba que SharePlay se limitaba a compartir video y audio.\nPero nos mostr√≥ como lo aprovechan en iFood.\nAdem√°s de hacer la charla muy interesante, fue creativa y estoy seguro que a mas de uno (como a m√≠) le ha tra√≠do nuevas ideas para su desarrollo.\nSoftware engineer or code craftsman - Michael Fletcher #Y para cerrar el evento, Michael trajo una interesante cuesti√≥n: ¬øIngeniero de software o artesano de c√≥digo.\nMostrando ejemplos y comparaciones de la vida real, nos invit√≥ a pensar sobre lo que hacemos y lo que nos gustar√≠a hacer.\nOne more thing #He dicho ya en varios momentos que me gust√≥ no solo por el nivel t√©cnico, sino tambi√©n por lo que me divert√≠.\nY uno de esos momentos especiales fue cuando pudimos aprender c√≥mo coger correctamente una copa y probar el vino üòÇ\nNo s√© si saldr√° en los videos, pero desde luego lo merece.\nwe got @facumenzella and @nyeeu hijacking (a bit) the schedule to learn how to properly hold and tate a glass of wine üç∑ #NSSpain2024 pic.twitter.com/IsP8EYU6An\n\u0026mdash; NSSpain XII (@NSSpain) September 18, 2024 No todo es c√≥digo #NSSpain 2024 no fue solo un espacio para aprender sobre tecnolog√≠a, sino tambi√©n para conectar con la comunidad.\nEl networking fue un componente esencial, y las actividades sociales trajeron la oportunidad de conocer a otros profesionales de manera m√°s distendida.\nUna de las experiencias tambi√©n m√°s enriquecedoras fue la visita a una bodega el d√≠a 18 de septiembre, donde despu√©s de las ponencias, pudimos aprender detalles sobre la producci√≥n y almacenamiento de vino, seguidos de una cena tipo c√≥ctel que abri√≥ m√°s oportunidades de conversaci√≥n y colaboraci√≥n.\nVisita a la bodega pic.twitter.com/959T2BDFVi\n\u0026mdash; √ìscar Moreno (@oscarmorenodev) September 18, 2024 Adem√°s, durante las noches, la mayor√≠a de los asistentes se reun√≠an en la famosa Calle Laurel y sus alrededores, un lugar conocido por su ambiente animado y su gastronom√≠a (destacando los pinchos y el vino üç∑).\nEstas salidas nocturnas permitieron seguir compartiendo ideas en un entorno m√°s informal.\nAdem√°s, la visita a Logro√±o en estas fechas tuvo un atractivo a√±adido, y es que el d√≠a 20 de septiembre comenzaron las fiestas locales, creando un ambiente festivo que potenci√≥ la experiencia del evento.\nPor qu√© deber√≠as ir a la pr√≥xima NSSpain #NSSpain sigue siendo una de las mejores oportunidades para desarrolladores de Apple que buscan mejorar sus habilidades.\nAprender de expertos y construir relaciones profesionales s√≥lidas es imprescindible si te preocupa tu desarrollo profesional.\nTanto desde el punto de vista t√©cnico como humano, el evento se supera a s√≠ mismo.\nOfrece no solo contenido t√©cnico valioso, sino tambi√©n una comunidad fuerte y accesible.\nNo hay duda de que futuras ediciones continuar√°n siendo un punto de referencia en el calendario de desarrolladores Apple a nivel internacional.\nSi buscas mejorar en tu carrera como desarrollador, aprender de los mejores y ampliar tu red de contactos, NSSpain es la conferencia a la que debes asistir.\nConclusiones #NSSpain 2024 demostr√≥ una vez m√°s por qu√© es un evento imperdible para los desarrolladores de Apple, no solo de Espa√±a.\nSe ha convertido en un referente internacional donde es importante que vayas si quieres: aprender, conectar con otros profesionales y divertirte (no necesariamente en ese orden üòâ)\n","date":"24 septiembre 2024","permalink":"/es/blog/nsspain-2024-es/","section":"Blog","summary":"NSSpain es una conferencia internacional de ingenier√≠a Apple muy especial","title":"Por qu√© deber√≠as ir a NSSpain"},{"content":"Los key-path son una caracter√≠stica de Swift que resultan confusas al principio.\nPero, con la llegada de SwiftUI, se ha extendido su uso.\nY su uso, no solo se limita al nuevo framework para las interfaces.\nConocerlo, te puede ayudar con alternativas para acceder a datos de los tipos.\nEscribir una expresi√≥n Key-Path #Las expresiones de ruta clave o key-path tienen esta estructura\n\\\u0026lt;#type name#\u0026gt;.\u0026lt;#path#\u0026gt;\nEl type name, es el nombre concreto de un tipo (estructura, clase, enumeraci√≥n\u0026hellip;) incluyendo tipos b√°sicos como Int, [String] o Set\u0026lt;Double\u0026gt;.\nEl path, puede contener una propiedad, un subcript, u opcionales.\nCuando se compila, la expresi√≥n key-path se reemplaza por una instancia de la clase KeyPath Acceder a un valor usando un Key-Path #As√≠ que, si quieres acceder a un valor de ruta clave, puedes hacerlo a trav√©s del subscript que pide un key-path, y que est√° disponible para todos los tipos\nstruct Driver { var name: String } let driver = Driver(name: \u0026#34;Fernando Alonso\u0026#34;) let pathToNameProperty = \\Driver.name let driverName = driver[keyPath: pathToNameProperty] print(driverName) // Prints \u0026#34;Fernando Alonso\u0026#34; Ten en cuenta, que el type name se puede omitir cuando la inferencia de tipos pueda saber el tipo que espera.\nstruct Race { var winner: Driver func displayWinnerProperty(keypath: KeyPath\u0026lt;Driver, String\u0026gt;) { print(\u0026#34;The winner is \\(winner[keyPath: keypath])\u0026#34;) } } let sai = Driver(name: \u0026#34;Carlos Sainz\u0026#34;) let race = Race(winner: sai) race.displayWinnerProperty(keypath: \\.name) // Prints \u0026#34;The winner is Carlos Sainz\u0026#34; Key-Path de identidad #Adem√°s, el path puede hacer referencia a self, en lo que se conoce como key-path de identidad (\\.self)\nEl key-path de identidad se refiere a la instancia en s√≠.\nGracias a eso, puede ser util para cambiar por ejemplo una instancia entera con una l√≠nea.\nvar verstappenPoints = (a: 25, b: 18, c:25) // Equivalent to verstappenPoints = (a: 18, b: 25, c: 25) verstappenPoints[keyPath: \\.self] = (a: 18, b: 25, c: 25) print(verstappenPoints) // Prints \u0026#34;(a: 18, b: 25, c: 25)\u0026#34; Pero donde se suele aprovechar esta caracter√≠stica es en SwitUI, por ejemplo, en un ForEach\nList { ForEach([2, 4, 6, 8, 10], id: \\.self) { Text(\u0026#34;\\($0) is even\u0026#34;) } } Acceder a m√∫ltiples valores de un tipo #Otra de sus caracter√≠sticas es que es posible acceder a propiedades anidadas.\nEs decir, hacer referencia a la propiedad del valor de una propiedad.\nPuedes ver un ejemplo a continuaci√≥n\nstruct Championsip { var winner: Driver init(winnerName: String) { self.winner = Driver(name: winnerName) } } let champion = Championsip(winnerName: \u0026#34;Max Verstappen\u0026#34;) let nestedKeyPath = \\Championsip.winner.name let championName = champion[keyPath: nestedKeyPath] print(championName) // Prints \u0026#34;Max Verstappen\u0026#34; Acceder a subscripts #Otra posibilidad que existe es que el path incluya subscripts usando corchetes.\nlet tracks = [\u0026#34;Spa\u0026#34;, \u0026#34;Monza\u0026#34;, \u0026#34;Montmelo\u0026#34;, \u0026#34;Suzuka\u0026#34;] let fasterTrack = tracks[keyPath: \\[String].[1]] print(fasterTrack) // Prints \u0026#34;Monza\u0026#34; En este caso es imprescindible que el tipo del par√°metro del subscript cumpla con el protocolo Hashable Adem√°s, debes tener en cuenta que en este caso, los valores capturados usan la sem√°ntica por valor, en lugar de por referencia.\nPor lo que una copia, no actualizar√° su propio valor, aunque modifiques el original.\nPuedes verlo m√°s claro en el siguiente ejemplo\nvar index = 1 let pathToTrack = \\[String].[index] let closure: ([String]) -\u0026gt; String = { strings in strings[index] } print(tracks[keyPath: pathToTrack]) // Prints \u0026#34;Monza\u0026#34; print(closure(tracks)) // Prints \u0026#34;bonjour\u0026#34; index += 1 print(tracks[keyPath: pathToTrack]) // Prints \u0026#34;Monza\u0026#34; // Because \u0026#39;fn\u0026#39; closes over \u0026#39;index\u0026#39;, it uses the new value print(closure(greetings)) // Prints \u0026#34;Spa\u0026#34; Acceder a valores opcionales #Para acceder a valores opcionales, simplemente tienes que hacer uso del encadenamiento de opcionales, o forzar el desempaquetado.\nlet firstTrack: String? = tracks.first let count = tracks[keyPath: \\[String].first?.count] print(count as Any) // Prints Montmelo characters number \u0026#34;Optional(8)\u0026#34; Key-Path como alternativa a closures y funciones #Tambi√©n puedes usar los key-path en otros contextos.\nPor ejemplo, en los que tienes que pasar una funci√≥n o un closure.\nstruct Lap { var time: Double var valid: Bool } var timelaps = [ Lap(time: 106.0, valid: true), Lap(time: 99.5, valid: true), Lap(time: 102.0, valid: false) ] // Usual let validLaps1 = timelaps.filter{ $0.valid } print(validLaps1.count) // Prints \u0026#34;2\u0026#34; // Equivalent with key-paths let validLaps2 = timelaps.filter(\\.valid) print(validLaps2.count) // Prints \u0026#34;2\u0026#34; Fijate como al final del ejemplo, puedes filtrar las vueltas v√°lidas con .filter(\\.valid) en lugar de con el habitual .filter{ $0.valid }.\n√Åmbito de los Key-Path #Por √∫ltimo, en relaci√≥n a los key-path, hay algo importante que debes tener en cuenta.\nLos resultados de una expresi√≥n key-path solo se evaluan en el punto en el que dicha expresi√≥n se evalua. Si llamas a una funci√≥n dentro de un subscript en una expresi√≥n key-path, la funci√≥n se llamar√° solo una vez, como parte de la evaluaci√≥n de la expresi√≥n, pero no siempre que se use el key-path.\nPuedes verlo en este ejemplo:\nfunc displayValidLap() -\u0026gt; Int { print(\u0026#34;Valid lap!\u0026#34;) return 0 } let greetingKeyPath = \\[Lap][displayValidLap()] // Prints \u0026#34;Valid lap!\u0026#34; // Using greetingKeyPath doesn\u0026#39;t call displayValidLap again. let someLap = timelaps[keyPath: greetingKeyPath] Conclusi√≥n #Los key-path son complejos, y es una caracter√≠stica que cuesta ver su utilidad.\nNo obstante, son utilizados en SwiftUI, por lo que es importante conocerlos y entenderlos.\nLo m√°s importante, recuerda que:\nSu estructura es \\\u0026lt;#type name#\u0026gt;.\u0026lt;#path#\u0026gt;. El type name es el nombre del tipo y el path es el nombre de la propiedad de dicho tipo. Cuando se compila, se reemplaza por una instancia de la clase KeyPath Puedes acceder a Un par√°metro Una instancia completa (\\.self) Un subscript Un valor opcional Y como la pr√°ctica hace el maestro, te dejo un playground para que puedas jugar üòâ\nkey-paths-swift.playground.zip Fuente #Expresiones Key-path - Documentaci√≥n de Swift\n","date":"17 septiembre 2024","permalink":"/es/blog/expresiones-keypath-swift/","section":"Blog","summary":"Las expresiones key-path ofrecen una alternativa para el acceso a datos de los tipos","title":"C√≥mo funcionan los key-path"},{"content":"La primera vez que vi un property wrapper fue en SwiftUI, pero es una caracter√≠stica de Swift que puedes usar desde la versi√≥n 5.1\nLas propiedades definen caracter√≠sticas de los tipos, pero a menudo tienes que realizar (las mismas) operaciones sobre ellas.\nLa forma m√°s sencilla de realizar estas operaciones es utilizando los observadores de propiedad de los que te habl√© anteriormente.\nPero, ¬øy si debes realizar esas operaciones demasiadas veces? Si solo usas los observadores, enseguida tendr√°s c√≥digo duplicado.\nLa soluci√≥n pasa por utilizar envoltorios de propiedad, o property wrappers.\nProperty Wrappers en Swift #Los property wrappers, a√±aden una capa de separaci√≥n entre el c√≥digo que define una propiedad y el que gestiona como se almacena.\nSu principal ventaja es que escribes el c√≥digo que opera sobre esa propiedad una vez, y lo reutilizas en las propiedades que necesitas.\nC√≥mo crear un property wrapper en Swift #En el siguiente c√≥digo puedes ver c√≥mo se crea\n@propertyWrapper struct DashCase { private var text = \u0026#34;\u0026#34; var wrappedValue: String { get { text } set { text = newValue.lowercased().replacingOccurrences(of: \u0026#34; \u0026#34;, with: \u0026#34;-\u0026#34;) } } } Puedes crear una clase, una estructura o una enumeraci√≥n, y es necesario que vaya precedido por la directiva de atributo @propertyWrapper\nEl tipo, debe tener una propiedad llamada wrappedValue, que devolver√° el valor que definas cuando se acceda a una propiedad con el propertyValue creado.\nAs√≠, podr√≠amos usar el anterior property wrapper de la siguiente manera\nstruct Branch { @DashCase var name: String } var branch = Branch() branch.name = \u0026#34;Random Branch Name\u0026#34; print(branch.name) // Muestra \u0026#34;random-branch-name\u0026#34; De esta forma, no es necesario que Branch tenga que formatear cada vez el nombre. Y por otro lado, podr√°s usar DashCasecada vez que necesites formatear un texto a min√∫sculas y guiones.\nstruct File { @DashCase var name: String } var file = File() file.name = \u0026#34;Random File Name\u0026#34; print(file.name) // Muestra \u0026#34;random-file-name\u0026#34; F√≠jate que si declaras una propiedad adicional en el tipo, es conveniente declararla privada. As√≠ te aseguras que en la implementaci√≥n solo se puede acceder al valor a trav√©s de la wrappedValue\nEstablecer los valores iniciales de un property wrapper #Adem√°s, si lo necesitas, puedes utilizar un inicializador.\nEsto te permitir√≠a crear el property wrapper de la siguiente forma:\n@propertyWrapper struct SnakeCase { var wrappedValue: String init(wrappedValue: String) { self.wrappedValue = wrappedValue.replacingOccurrences(of: \u0026#34; \u0026#34;, with: \u0026#34;_\u0026#34;).lowercased() } } Esto puede suponer una ventaja, cuando necesites por ejemplo que sea obligatorio crear el objeto, con un valor inicial, porque tendr√°s que introducirlo\nstruct Table { @SnakeCase var name: String } var table = Table(name: \u0026#34;hello World\u0026#34;) print(table.name) // Muestra \u0026#34;hello_world\u0026#34; Valor proyectad de un property wrapper #Adem√°s del valor envuelto, que devuelve un property wrapper, como has podido ver en los ejemplos anteriores, tambi√©n permite disponer de un valor proyectado\nEste valor proyectado podr√≠a servir, siguiendo los ejemplos anteriores, para saber si se ha formateado el valor.\n@propertyWrapper struct Capitalized { private var text: String private(set) var projectedValue = false var wrappedValue: String { get { text } set { text = newValue.capitalized } } init(wrappedValue: String) { self.text = wrappedValue.capitalized projectedValue = true } } Con ello, podr√≠as hacer lo siguiente\nstruct CustomText { @Capitalized var title: String } let text = CustomText(title: \u0026#34;One more thing...\u0026#34;) print(text.title) // Muestra \u0026#34;One More Thing...\u0026#34; print(text.$title) // Muestra \u0026#34;true\u0026#34; Conclusi√≥n #Como has visto, utilizar property wrappers trae la principal ventaja de reutilizar c√≥digo entre par√°metros de distintos tipos que sobre los que necesitan realizar las mismas operaciones.\nLo m√°s importante:\nNecesitas usar la directiva @propertyWrapper y que tenga al menos una propiedad llamada wrappedValue Puedes usar si quieres una propiedad projectedValue si quieres exponer alguna funcionalidad adicional Si necesitas un propiedad adicional para realizar las operaciones, declarala como privada para que solo se pueda modificar desde el property wrapper. Si quieres practicar, aqu√≠ tienes un playground con los ejemplos üòâ\nproperty-wrappers-in-swift.playground.zip Fuentes #Property Wrappers - Documentaci√≥n de Swift\nProperty Wrappers en Swift - Swift by Sundell\n","date":"10 septiembre 2024","permalink":"/es/blog/property-wrappers-en-swift/","section":"Blog","summary":"Los property wrappers te permiten encapsular c√≥digo repetitivo para las propiedades","title":"C√≥mo crear property wrappers para reutilizar c√≥digo"},{"content":"En (muchas) ocasiones, debes pasar m√°s tiempo leyendo c√≥digo que escribi√©ndolo, por eso es clave entender lo que lees.\nAdem√°s, es una buena forma de aprender m√°s conceptos de programaci√≥n.\n¬øSabes en qu√© se diferencia open de public?¬øPor qu√© no es lo mismo fileprivate que private?\nSaber esto, evita que pierdas el tiempo con errores en los que a veces no encontrar√°s explicaci√≥n, y te ayudar√° a estructurar mejor tu aplicaci√≥n.\nEl control de acceso permite gestionar el acceso a determinadas partes de tu c√≥digo desde otras partes del mismo. Esto te permite ocultar los detalles de implementaci√≥n de tipos, propiedades, funciones\u0026hellip; (a los que llamaremos entidades)\nNo siempre es necesario utilizarlos, ya que Swift facilita un nivel de acceso predeterminado para los escenarios m√°s b√°sicos.\nFicheros fuente, m√≥dulos y paquetes #Antes de seguir, es importante que conozcas los siguientes elementos para entender desde donde podr√°s acceder.\nFichero fuente #Un fichero fuente (source file) es un fichero con extensi√≥n .swift que se encuentra dentro de un m√≥dulo.\nTen en cuenta que normalmente se define cada tipo (clase, estructura o enumeraci√≥n) en un fichero fuente, pero en ocasiones pueden haber varios relacionados en el mismo.\nM√≥dulo #Un m√≥dulo es una unidad de distribuci√≥n de c√≥digo.\nPuede ser un framework o una aplicaci√≥n, que formar√° una unidad.\nLos m√≥dulos pueden importarte desde otros m√≥dulos usando la palabra clave import\nPaquete #Un paquete es un grupo de modulos que forman una unidad.\nCuando se crea un paquete, se deben especificar los m√≥dulos que va a contener.\nNiveles de acceso en Swift #Ahora puedes ver los distintos niveles ordenados de menor a mayor restricci√≥n.\nopen #Cuando una entidad est√° definida con open, podr√°s acceder a ella desde cualquier fichero fuente que se encuentre en el mismo m√≥dulo.\nY adem√°s, tambi√©n desde ficheros fuente de otros m√≥dulos, que importen el m√≥dulo que contienen dicha entidad.\nPor otro lado, permite acceder desde subclases o sobreescribir m√©todos desde fuera del m√≥dulo (overriding).\nLo debes utilizar cuando crees una interfaz p√∫blica de un framework.\npublic #Utilizar public es casi lo mismo que open.\nLa diferencia es que en el caso de public, no puedes acceder desde subclases ni sobescribir m√©todos.\npackage #Este acceso est√° disponible desde Swift 5.9\nComo habr√°s intuido, permite acceder desde cualquier fichero fuente dentro del mismo paquete\ninternal #El uso de internal permite acceder desde cualquier fichero fuente del mismo m√≥dulo, pero no de distintos m√≥dulos.\nEs habitual utilizarlo cuando se define la estructura de una app o framework sencillo.\nSeguramente apenas lo ver√°s, ya que es el que se utiliza por defecto. Es decir, si no ves ning√∫n control de acceso antes de la palabra clave de la entidad (struct, class, let, var, etc\u0026hellip; ) Es porque est√° utilizando internal.\nfileprivate #En este caso, con fileprivate solo se podr√° acceder a estas entidades desde el mismo fichero fuente que lo contenga.\nDe esta forma, si por ejemplo en un fichero .swift tienes distintas clases y estructuras, la que est√© marcada con fileprivate podr√° ser accedida desde el resto de clases y estructuras de ese mismo fichero.\nprivate #Por √∫ltimo, private solo permite acceder a su contenido desde su declaraci√≥n.\nEs decir, si una clase est√° marcada con este control de acceso, solo se podr√°n acceder a sus entidades, desde dentro de dicha clase.\nC√≥mo usar los niveles de acceso en Swift #Para usar los distintos niveles simplemente tienes que indicarlo delante de la palabra clave de la entidad.\nMira los siguientes ejemplos:\nopen class MyClass {} public struct MyStruct {} internal let myConstant = \u0026#34;Hello World!\u0026#34; fileprivate var myVar = \u0026#34;Hello again!\u0026#34; v private func myMethod() {} Principio de los niveles de acceso #Los distintos niveles de acceso siguen un principio general:\nNo se puede definir ninguna entidad dentro de otra entidad que tenga un nivel de acceso inferior (m√°s restrictivo) Es decir, no puedes definir una variable p√∫blica dentro de una clase privada; ni puedes definir una variable abierta, en un m√©todo interno.\nNivel de acceso predeterminado #El nivel de acceso por defecto es internal, por lo que si no indicas nada antes de la entidad, ser√° √©ste el que tome.\nConclusi√≥n #Has visto los distintos niveles de acceso: open, public, internal, fileprivate y private, y las restricciones que implican cada uno de ello.\nEs importante utilizar el adecuado para mantener un c√≥digo limpio, organizado, y eficiente, permitiendo el acceso √∫nicamente a quien lo necesite.\nRecuerda que si no indicas nada, Swift considerar√° la entidad como internal.\nFuentes #Control de acceso - Documentaci√≥n de Swift\n","date":"3 septiembre 2024","permalink":"/es/blog/niveles-acceso-swift/","section":"Blog","summary":"Los niveles de acceso definen desde d√≥nde se puede acceder a tu c√≥digo","title":"Qu√© significan los distintos niveles de acceso en Swift"},{"content":"Los dispositivos Apple destacan por varios motivos: un dise√±o que los identifica y muchos quieren copiar, durabilidad y fiabilidad, pero sobretodo, un ecosistema que funciona como un todo a la hora de proveer servicios.\nEsto, aunque tiene sus desventajas, la primera ventaja que suele venir a la cabeza es la facilidad para la coordinaci√≥n de todos esos componentes.\nY si hay una materia donde la coordinaci√≥n entre los distintos componentes es clave, es en la seguridad.\nEn este art√≠culo no quiero limitarme a mencionar notificias de mayor o menor actualidad donde \u0026ldquo;se dice\u0026rdquo; que es un sistema seguro. Sino que quiero enumerar, bas√°ndome en la documentaci√≥n oficial de la marca, de las medidas que utilicen para que tus datos y los m√≠os est√©n seguros.\nLos de Cupertino dividen sus medidas de seguridad en varias √°reas, tanto f√≠sicas como l√≥gicas, que abarcan la totalidad de los actores que intervienen en este asunto.\nHardware y biometr√≠a #La base de la seguridad de un dispositivo es su hardware. Poniendo un ejemplo extremo, imagina un dispositivo que no tuviera posibilidad de acceder a internet por no contar con modem o tarjeta de red, o que no permita la entrada de vol√∫menes de datos: tarjetas de memoria, USBs, SSDs\u0026hellip;\nEn este caso, estos dispositivos limitar√≠an la posibilidad de inyecci√≥n de c√≥digo malicioso, o la extracci√≥n de datos del usuario. Lo que podr√≠a suponer un menor riesgo de seguridad.\nPor eso, la seguridad de los dispositivos de Apple empieza en su hardware, y m√°s concretamente en las funciones que tienen sus procesadores.\nDurante los √∫ltimos a√±os, Apple ha invertido grandes esfuerzos en el dise√±o de sus propios chip, y perfeccionando los sistemas alojados en √©stos, llamados System on Chip √≥ SoC\nUn ejemplo de ello es Secure Enclave, un subsistema de seguridad que se encuentra en las versiones m√°s recientes de los dispositivos de Apple.\nSecure Enclave se encuentra a parte del procesador principal, para mantener los datos de seguros, en caso que la seguridad de dicho procesador fuera vulnerada.\nAdem√°s, se ha dise√±ado de la misma forma que el SoC, contando con:\nUna ROM de arranque que establece la raiz de confianza de hardware Un motor AES para criptograf√≠a Memoria protegida Para la identificaci√≥n de usuarios, Apple hace uso de la biometr√≠a.\nEl m√©todo m√°s conocido es FaceID, el sistema mediante el cual, a trav√©s de la mirada, se pueden realizar operaciones como: desbloqueo del dispositivo y confirmaci√≥n de pagos y compras.\nFaceID utiliza redes neuronales para validar la coincidencia y aprender sobre los cambios que hayan en la apariencia del individuo.\nY todo esto, lo consigue a trav√©s de la c√°mara TrueDepth, que destaca por poder hacer escaneos en 3D de nuestro rostro, lo que evita, por ejemplo, que una simple imagen nuestra, pueda servir para suplantar nuestra identidad.\nPor otro lado, los dispositivos m√°s antiguos, as√≠ como los teclados Magic Keyboard, cuentan con TouchID, que se utiliza para los mismos casos que los anteriormente nombrados, pero a trav√©s de nuestras digitales.\nPero no solo se limita a usar la huella grabada en su primera configuraci√≥n, ya que el sensor detectar√° los nuevos nodos que existan con cada uso.\nAdem√°s, es importante que sepas que Apple facilita APIs que permiten a las aplicaciones hacer uso de estos elementos biom√©tricos para desarrollar apps seguras.\nSistema operativo #Los sistemas operativos cuentan con diversos servicios y recursos, a los aplicaciones, usuarios y dem√°s acceden para gestionar la informaci√≥n.\nLa seguridad del sistema, por lo tanto, es la encargada de gestionar estos accesos, √∫nicamente a quien deba hacerlo.\nUn elemento muy importante en este apartado ser√≠a un arranque seguro, lo suficiente como para evitar que cualquier c√≥digo no deseado, se inserte en √©l, y por lo tanto, consiga un alto privilegio pudiendo acceder a cualquier parte del sistema.\nEsto se consigue asegurando que cada paso es seguro, y no se pasa el control al siguiente hasta su completa validaci√≥n.\nUna vez con el sistema funcionando, otro factor que determina la seguridad son las actualizaciones. En este caso, la misi√≥n del sistema ser√° asegurar que no es posible instalar versiones anteriores y en consecuencia, posiblemente vulnerables.\nPor otro lado, los vol√∫menes (dispositivos de almacenamiento de datos), como medios de entrada y salida, tambi√©n pueden ser vulnerados y utilizados para comprometer la seguridad.\nPara evitarlo, Apple en este caso, desde macOS 11, usa a√±ade medidas de encriptaci√≥n para proteger el c√≥digo del sistema, de forma que √©ste no pueda ser modificado.\nEncriptaci√≥n y protecci√≥n de datos #Los iPhone y iPad usan un tipo de encriptaci√≥n llamada Protecci√≥n de datos, mientras que los datos de los equipos Mac basados en Intel se estaban asegurados con un m√©todo de encriptaci√≥n del volumen que llamaron FileVault.\nAs√≠, en los dispositivos m√≥viles (iPhone y iPad), de un uso por espacios de tiempo m√°s breve, se hace uso de c√≥digos, que son m√°s √°giles de introducir. Se pueden usar de cuatro d√≠gitos, de seis, o de longitud indeterminada.\nSin embargo, para el acceso en ordenadores, en los que solemos pasar varias horas frente a ellos, se utilizan contrase√±as\nObviamente, a mayor longitud del c√≥digo o de la contrase√±a, m√°s dif√≠cil ser√° que puedan averiguarlos. Esto es debido a que, adem√°s de necesitar m√°s intentos de fuerza bruta, cuanto m√°s complejo sea, m√°s segura ser√° la clave de encriptaci√≥n.\nComo te contaba antes, esto combinado con el uso de FaceID y TouchID, mejora la experiencia de usuario, sin reducir la seguridad de tus datos.\nComo capa adicional, Apple aplica un tiempo de demora en el caso de fallar.\nPor ejemplo, en dispositivos iOS y iPadOS son los siguientes:\nIntentos Demora 1-4 Ninguna 5 1 minuto 6 5 minutos 7-8 15 minutos 9 1 hora Adem√°s, si despu√©s de 10 intentos, la opci√≥n de \u0026ldquo;Borrar datos\u0026rdquo; est√° activada, el contenido y los ajustes se eliminan del almacenamiento\nY en el caso de macOS, los tiempos de demora coinciden, pero en el caso de superar los 10 intentos, √©ste se desactivar√°.\nPor √∫ltimo, Apple tambi√©n protege los datos, haciendo uso de una t√©cnica que llama almac√©n seguro de datos, que evita que las distintas aplicaciones puedan acceder a nuestros datos de usuario como Calendario, C√°mara, Contactos, Recordatorios, Notas\u0026hellip;\nSeguridad de las apps #Las apps suponen un grave riesgo para la seguridad de tus datos, en cuanto a que es la principal via de entrada de c√≥digo a los mismos.\nSin embargo, resulta posible prescindir de ellas, ya que tambi√©n son la primera fuente de funcionalidad para el hardware.\nUna primera capa ya te he mencionado anteriormente, con el almac√©n seguro de datos.\nEn este caso, se puede diferenciar entre apps del App Store y descargadas de otras fuentes, algo que, hasta hace bien poco, era exclusivo de macOS.\nEn el caso de macOS, a partir de la versi√≥n 10.15, todas las descargas fuera del App Store, deben estar certificadas por Apple, para evitar el mensaje de seguridad y el bloqueo.\nPor otro lado, el mismo sistema de macOS, cuenta con un sistema propio de protecci√≥n antivirus para evitar la ejecuci√≥n de c√≥digo malicioso.\nEn el caso de apps para iOS y iPadOS, todas deben estar firmadas mediante el mecanismo implementado por Apple para subir dichas apps al App Store. Esto se realiza a trav√©s de la validaci√≥n de un certificado que facilita el Apple Developer Program\nEstas validaciones, no solo se realizan por desarrolladores o empresas que distribuyen apps a usuarios finales. Sino que es un proceso por el que tambi√©n se debe pasar por las organizaciones que desarrollen apps internas para sus empleados.\nPero, todo esto se refiere √∫nicamente a la instalaci√≥n.\nApple mejora a√∫n m√°s la seguridad, a√±adiendo una capa adicional al entorno de ejecuci√≥n de las apps, mediante tres elementos.\nEl primero es el aislamiento, y es que, todas las apps de terceros, se ejecutan en un entorno aislado, para evitar que puedan acceder a archivos almacenados por otras apps, o que modifiquen el contenido del sistema.\nPor lo que para acceder a informaci√≥n ajena, debe pasar s√≠ o s√≠ por los m√©todos que establece Apple en el sistema.\nEl segundo son las autorizaciones que, mediante pares de clave-valor, permiten la autenticaci√≥n fuera del entorno de ejecuci√≥n, como por ejemplo, un ID de usuario en UNIX. Dichas autorizaciones se aseguran mediante firma digital, por lo que no es posible modificarlas.\nY el tercer y √∫ltimo elemento, es la aleatorizaci√≥n del espacio de direcciones, lo que ayuda a proteger el sistema frente a ataques que hacen uso de fallos por memoria corrupta.\nServicios #El primer componente que nos da acceso a los servicios que facilita Apple en sus dispositivos es el Apple ID. √âste, cuenta con una serie de requisitos habituales para evitar que un tercero consiga acceso a √©ste. Dichos requisitos, a la hora de crear su contrase√±a son:\nAl menos ocho caracteres Combinaci√≥n de n√∫meros y letras No deben tener m√°s de tres caracteres id√©nticos o consecutivos No debe ser de uso com√∫n. Adem√°s, por defecto, Apple cuenta con la autenticaci√≥n de doble factor, lo que evita accesos no deseados en caso que alguien consiga tu contrase√±a.\nPor otro lado, en caso de querer restablecer la contrase√±a, debe hacerse desde otro dispositivo de confianza.\niCloud es probablemente el servicio m√°s usado de la compa√±√≠a, que permite el almacenamiento de datos de las categor√≠as fotos, contactos, email, salud\u0026hellip; por lo que todo esfuerzo es poco para mantener a Apple como un actor comprometido con la seguridad.\nEn este caso, Apple ofrece dos opciones para encriptar su contenido:\nProtecci√≥n est√°ndar: Los datos del usuario se encriptan y sus claves se almacenan en los centros de datos de Apple, quien solo puede ayudar a recuperar datos, pero no dispone de ellos. 14 categor√≠as de datos usar√°n la encriptaci√≥n de punto a punto. Protecci√≥n avanzada: Solo se puede acceder a las claves de encriptaci√≥n desde un dispositivo de confianza, que es donde se protegen por encriptaci√≥n punto a punto. Siendo en este caso, 23 las categor√≠as que har√°n uso de ella. Otro elemento, cada vez m√°s usado, y sin duda al que hay que prestar especial atenci√≥n es a Apple Pay, el cual permite realizar pagos.\nY aqu√≠ Apple protege los pagos mediante: Secure Element y el Controlador NFC.\nEl primero incluye applets (componentes que se ejecutan en el contexto de otro programa) certificados por entidades emisoras de tarjetas o redes de pagos. De esta forma, son √©stas las √∫nicas que conocen las claves de encriptaci√≥n para acceder a los datos de los applets.\nEn el segundo caso, el controlador actua como puerta de enlace, permitiendo al primero poder realizar el pago en un terminal de punto de venta sin contacto. √âste, permite la conexi√≥n, una vez el usuario ha autorizado el pago mediante biometr√≠a o c√≥digo.\nSeguridad en la red #En cuanto a la parte red, y a√∫n siendo el elemento principal de la comunicaci√≥n entre dispositivos, me limitar√© a dar los datos t√©cnicos sin entrar en detalle.\nAs√≠, iOS, iPadOS y macOS con compatibles con las versiones de TLS:\nTLS 1.0 TLS 1.1 TLS 1.2 TLS 1.3 Datagram Transport Layer Security (DTLS) Siendo TLS compatible con AES128 y AES256.\nEn cuanto a las redes privadas virtuales (VPNs), los protocolos compatibles son:\nIKEv2/IPsec con autenticaci√≥n por secreto compartido, certificados RSA certificados de algoritmo de firma digital de curva el√≠ptica (ECDSA), EAP‚ÄëMSCHAPv2 o EAP-TLS. VPN SSL con la app cliente adecuada de App Store. L2TP/IPsec con autenticaci√≥n de usuario mediante contrase√±a de MS-CHAPV2 y autenticaci√≥n de m√°quina mediante secreto compartido (iOS, iPadOS y macOS), y RSA SecurID o CRYPTOCard (solo macOS). Cisco IPsec con autenticaci√≥n de usuario mediante contrase√±a, RSA SecurID o CRYPTOCard, y autenticaci√≥n de m√°quina mediante secreto compartido y certificados (solo macOS). Kit de desarrollo #Por √∫ltimo, Apple te facilita una serie de kits para desarrollas apps que ampl√≠en los servicios de √©stos.\nEstos kits son: HomeKit, CloudKit, SiriKit, DriverKit, ReplayKit y ARKit.\nEn este caso, quiz√° el servicio donde m√°s en juego entra la privacidad, es el caso de HomeKit, encargado de gestionar dispositivos del hogar, tan sensibles como c√°maras de videovigilancia, o de grabaci√≥n de audio como HomePods.\nPara asegurar estos dispositivos, HomeKit se basa en pares de claves Ed25519 constituidos por una clave p√∫blica y una privada.\nDichas claves, se almacenar√°n en el Llavero de iCloud, para poder actualizarse entre dispositivos.\nConclusi√≥n #Los elementos que influyen en la seguridad de los dispositivos Apple, son muchos y de distinta √≠ndole. Pero, tanto como si eres programador, manager o usuario, conocerlos es de gran importancia, principalmente para ser conscientes de los riesgos a los que estamos expuestos.\nY si adem√°s, tu trabajo est√° influido por dicha seguridad, puedes aportar un gran valor a los usuarios de tus apps.\n","date":"9 mayo 2024","permalink":"/es/blog/seguridad-apple/","section":"Blog","summary":"Apple combina numerosos elementos para fomentar y mantener la seguridad en sus dispositivos y apps","title":"Gu√≠a de seguridad aplicada en dispositivos Apple"},{"content":"","date":"2 mayo 2024","permalink":"/es/blog/sesgos-cognitivos-desarrollo-software/","section":"Blog","summary":"Descubre otros factores que pueden afectar a la calidad de tu c√≥digo","title":"C√≥mo afectan los sesgos cognitivos al desarrollo de software"},{"content":"Programando para Apple es el podcast de desarrollo de aplicaciones para dispositivos Apple.\nNoticias de actualidad, an√°lisis, opini√≥n y entrevistas para profesionales y empresas cuyo negocio se basa en la programaci√≥n y distribuci√≥n de aplicaciones para el ecosistema de Apple.\nProgramar apps para iOS, visionOS, MacOS o el resto de sistemas de los de Cupertino, no es solo escribir c√≥digo en Swift y SwiftUI, por eso en este podcast te recopilo la informaci√≥n m√°s relevante para ayudarte a conseguir tus objetivos.\n","date":null,"permalink":"/es/podcast/","section":"Programando para Apple","summary":"\u003cp\u003eProgramando para Apple es el podcast de desarrollo de aplicaciones para dispositivos Apple.\u003c/p\u003e\n\u003cp\u003eNoticias de actualidad, an√°lisis, opini√≥n y entrevistas para profesionales y empresas cuyo negocio se basa en la programaci√≥n y distribuci√≥n de aplicaciones para el ecosistema de Apple.\u003c/p\u003e\n\u003cp\u003eProgramar apps para iOS, visionOS, MacOS o el resto de sistemas de los de Cupertino, no es solo escribir c√≥digo en Swift y SwiftUI, por eso en este podcast te recopilo la informaci√≥n m√°s relevante para ayudarte a conseguir tus objetivos.\u003c/p\u003e","title":"Programando para Apple"},{"content":"Episodio 6 Ya has escrito el c√≥digo de tu app y te dispones a subirla al App Store pero, ¬øcumples todos los requisitos para que la publiquen?¬øSabes cuanto se podr√≠a demorar si no tienes todo en cuenta?\nEn el episodio de hoy te cuento todo lo que revisa Apple para que superes con √©xito la revisi√≥n y se publique lo antes posible.\nDisponible en:\nYoutube\nApple Podcasts\nSpotify\n","date":"30 abril 2024","permalink":"/es/podcast/revision-app-store/","section":"Programando para Apple","summary":"Descubre los detalles que Apple tiene en cuenta para publicar tu aplicaci√≥n en el App Store","title":"Supera la revisi√≥n del App Store"},{"content":"Una de las principales ventajas que tiene desarrollar apps de forma nativa para Apple, es que con el mismo lenguaje (Swift) y el mismo framework de UI (SwiftUI) puedes crear apps para todos sus dispositivos.\nNo obstante, existen sutiles diferencias entre dichos dispositivos. Y a su vez, entre distintas versiones de √©stos.\nPor eso, puedes dar un paso m√°s all√° en el desarrollo de tus productos si tienes en cuenta algunos factores, consiguiendo para tus usuarios una mejor experiencia.\nPor eso, hoy te quiero exponer estos detalles\nDise√±o responsivo #Gracias a SwiftUI, no es necesario realizar los ajustes en las constraints como ocurr√≠a con UIKit, que permit√≠an definir las distancias entre elementos, y con respecto al borde de la pantalla. Por lo que en ese sentido, no debes preocuparte.\nPero, lo que s√≠ debes tener en cuenta, es que utilizar los tama√±os d√≠namicos, y las fuentes facilitadas por Apple, permiten asegurar esa compatibilidad en lo que respecta a la interfaz. Adem√°s, se simplifica y agiliza la parte de desarrollo.\nPuedes encontrar m√°s info, en la documentaci√≥n oficial de SwiftUI: Aplicando a una fuerte soporte de tama√±o din√°mico\nAdem√°s, gracias a la previsualizaci√≥n de SwiftUI, puedes comprobar como quedar√°n las vistas en varios dispositivos de forma simult√°nea.\nCrea una app multiplataforma #Xcode permite la creaci√≥n de apps multiplataforma, de esta forma, no habr√°n targets diferentes para iOS y macOS.\nCrea un dise√±o din√°mico #Existen modificadores de dise√±o en SwiftUI que te permiten ajustar como se mostrar√° la vista, en funci√≥n por ejemplo, del valor de una variable (vinculada por ejemplo a las subvistas que existan)\nUtiliza una versi√≥n m√≠nima de sistema reciente #Apple se preocupa por esta compatibilidad, ya que le supone un enorme beneficio que a sus usuarios les suponga una ventaja tener sus dispositivos. Es de gran comodidad hacer una foto con el iPhone, verla en el iPad, y despu√©s editarla con el Macbook Pro.\nY esto es algo que cada vez tiene m√°s en cuenta, por eso las versiones m√°s recientes facilitar√°n la integraci√≥n y compatibilidad para que una app se pueda usar en todos esos dispositivos.\nNo te olvides del modo oscuro #Otro detalle importante que puedes ver en la previsualizaci√≥n de SwiftUI, es que con simple click puedes comprobar como se ve tu app en modo claro u oscuro.\nEsta es una caracter√≠stica que cada vez se usa m√°s por parte de los usuarios, no solo por elegir el modo que visualmente m√°s le atraiga. Muchas veces viene configurado de forma autom√°tica. De esta forma, de d√≠a veremos el modo claro, y de noche el modo oscuro.\nPor este motivo, tambi√©n es muy importante, utilizar en la medida de lo posible los colores y modificadores que facilita SwiftUI, para que tengan sus distintas versiones de colores.\nPrueba diferentes disposiciones de pantallas #En ocasiones, los usuarios prefieren utilizar el dispositivo en modo vertical, o en modo horizontal.\nS√≠, de nuevo, gracias a SwiftUI y no tener que depender de las constraints, nos ha facilitado los desarrollos. Pero es importante comprobar (tambi√©n en la preview) como se mostrar√°n las vistas en las distintas orientaciones de pantalla.\nConsidera las vistas de iPad #SwiftUI cuenta con el protocolo NavigationSplitViewStyle para poder mostrar vistas divididas en paneles.\nEl ejemplo m√°s claro es en la app de Correo, donde se muestran, de izquierda a derecha:\nLos distintos buzones El contenido del buz√≥n El mensaje seleccionado de ese buz√≥n. Esto es √∫til para colecciones, que tengan a su vez informaci√≥n anidada Pero recuerda comprobar el resultado en la previsualizaci√≥n de cada dispositivo.\nAprovecha las capacidades √∫nicas de cada dispositivo #Aunque desarrollar una app que funcione a trav√©s de m√∫ltiples dispositivos es crucial, tambi√©n es esencial aprovechar las capacidades √∫nicas de cada uno.\nPor ejemplo, el Apple Watch ofrece funcionalidades de salud √∫nicas, mientras que el Apple TV puede centrarse en capacidades multimedia.\nAseg√∫rate de dise√±ar tu app no solo para que sea compatible, sino tambi√©n para que explote al m√°ximo las caracter√≠sticas espec√≠ficas de cada dispositivo.\nGesti√≥n del estado del dispositivo #Es fundamental gestionar el estado del dispositivo al dise√±ar para m√∫ltiples plataformas.\nEsto incluye manejar cambios como la rotaci√≥n de la pantalla, interrupciones como llamadas entrantes o alertas, y ajustes del sistema como los cambios en las configuraciones de accesibilidad.\nEscucha los eventos del sistema y responde adecuadamente para asegurar una experiencia fluida y coherente en todos los dispositivos.\nConclusi√≥n #Como has podido, comprobar todos los aspectos a tener en cuenta, se pueden resumir en dos:\nUtilizar los elementos que facilita Apple de forma nativo Previsualizar los resultados en los distintos dispositivos de destino. Esto har√° que puedas aprovechar una de las fortalezas de la compa√±√≠a de Cupertino: la experiencia de uso de su ecosistema.\n","date":"25 abril 2024","permalink":"/es/blog/compatibilidad-apps-ecosistema-apple/","section":"Blog","summary":"Swift facilita poder crear apps para varios dispositivos, pero debemos asegurar su compatibilidad","title":"Asegurar la compatibilidad de las apps para el ecosistema de Apple"},{"content":"Episodio 5 ¬øEs un buen momento para empezar a crear apps para visionOS?¬øSabes qu√© necesitas para hacerlo? En el episodio de hoy respondemos a estas preguntas y analizamos las apps destacadas ya disponibles.\nDisponible en:\nYoutube\nApple Podcasts\nSpotify\n","date":"23 abril 2024","permalink":"/es/podcast/crear-apps-vision-pro/","section":"Programando para Apple","summary":"¬øEs un buen momento para empezar a crear apps para visionOS?¬øSabes qu√© necesitas para hacerlo?","title":"Crear apps para visionOS"},{"content":"Las propiedades son una caracter√≠stica fundamental en cualquier lenguaje orientado a objetos o, como en el caso de Swift, orientado a protocolos.\nPiensa en un objeto, por ejemplo, un smartphone. Podr√≠as ver que un smarphone tiene:\nComportamientos Caracter√≠sticas Entre los comportamientos podr√≠as identificar: Llamar a un contacto, navegar por internet, hacer una foto\u0026hellip; Es decir, acciones que puedes realizar con el dispositivo, o dicho de otra forma: qu√© puede hacer.\nY sobre las caracter√≠sticas, podr√≠as ver: el tama√±o de la pantalla, el peso, el color\u0026hellip; Es decir, detalles que definen c√≥mo es el objeto, o mejor dicho, propiedades\nY es que, las propiedades, son las que van a almacenar las caracter√≠sticas de los tipos (clases, estructuras, enumeraciones o protocolos) que definan dicha propiedad.\nCon eso, podemos definir las propiedades de 2 formas distintas: mediante propiedades almacenadas, o a trav√©s de propiedades calculadas.\nPropiedades almacenadas #Las propiedades almacenadas son la forma m√°s simple de definir una propiedad. Dentro de un tipo, indicas su propiedad; y para ello, escribe el tipo de valor (constante o variable), junto al nombre de la propiedad.\nA partir, de ah√≠, puedes indicar el tipo de valor (y le asignar√°s el valor cuando lo inicialices) o puedes asignarle un valor, y Swift inferir√° el tipo de dato que est√°s almacenando.\nstruct Movie { let title: String let year: Int var released = false } var theFuture = Movie(title: \u0026#34;The future\u0026#34;, year: 2026) En ese ejemplo, puedes ver 3 propiedades para la estructura Movie.\nEl t√≠tulo y el a√±o, deber√°s indicarlo en la inicializaci√≥n. Mientras que, si no indicas lo contrario, la instancia se crea indicando que la pel√≠cula no ha sido lanzada ya que released se inicializar√° commo false si no has indicado nada.\nPropiedades en instancias constantes #Es importante que tengas en cuenta que si creas un instancia en una constante, pueden ocurrir dos situaciones distintas, dependiendo de si es una estructura o una clase.\nEn el caso de las estructuras, al ser tipos por valor, no podr√°s modificar las propiedades de la instancia (aunque esas propiedades las hayas definido con variables). Y es que, la instancia, se almacenar√° en una ubicaci√≥n constante, y por lo tanto, ser√° inmutable.\nEsto no ocurre con las clases ya que, al ser tipos por referencia, lo que mantienen constante es la referencia a la ubicaci√≥n en memoria. Por lo tanto, s√≠ puedes modificar el contenido y por ello, sus propiedes (siempre y cuando hayas definido esas propiedades como variables)\nstruct VideogameStruct { let title var played } class VideogameClass { let title var played } let videogameInStruct = VideogameStruct(title: \u0026#34;The last of us\u0026#34;, played: false) // ERROR: Change \u0026#39;let\u0026#39; to \u0026#39;var\u0026#39; to make it mutable let videogameInClass = VidegameClass(title: \u0026#34;God of war\u0026#34;, played: false) videogameInStruct.played = true // ERROR: Change \u0026#39;let\u0026#39; to \u0026#39;var\u0026#39; to make it mutable videgameInClass.played = true // You can change de value. Como ves, en caso de la estructura, este c√≥digo no compilar√°. Tanto en la instanciaci√≥n como al intentar modificar el valor, te dir√° que cambies let por var para hacerla mutable.\nPropiedades lazy #Las propiedades lazy, son propiedades perezosas porque su valor inicial no se calcula hasta que no necesitan ser usadas.\nPara definirlas solo hay que utilizar la palabra reservada lazy al inicio de la declaraci√≥n.\nclass Network { var online: Bool = false // Logic to check if internet connection works. } struct Device { let owner: String lazy var network = Network() } Las propiedades lazy son especialmente √∫tiles para optimizar el rendimiento, ya que no se acceder√° al valor si no es necesario.\nEn el ejemplo anterior, puedes instanciar el dispositivo, y asignarle un propietario pero, como saber si dispone de conexi√≥n, es una tarea m√°s compleja que implica otras operaciones, puedes seguir sin comprobarlo hasta que lo necesites.\nSi m√∫tiples hilos acceden simult√°neamente a una propiedad lazy que no ha sido inicializada, Swift no puede garantizar que solo se inicialice una vez. Propiedades calculadas #Los otros tipos de propiedades, las propiedades calculadas, no almacenan un valor directamente, sino que lo calculan y lo devuelven cuando se les llama.\nSon √∫tiles cuando su valor depende por ejemplo, del valor de otras propiedades dentro de ese mismo tipo.\nAqu√≠ puedes ver un ejemplo sencillo:\nstruct TVSeries { var title: String var startYear: Int var endYear: Int? // A nil value indicates the series has not concluded // Computed property to determine if the series is still airing var isAiring: Bool { get { if let endYear = endYear { return false // The series has concluded } else { return true // The series is still airing } } set { let result = newValue ? \u0026#34;is\u0026#34; : \u0026#34;is not\u0026#34; print(\u0026#34;\\(title) \\(result) on air!\u0026#34;) } } } let breakingBad = TVSeries(title: \u0026#34;Breaking Bad\u0026#34;, startYear: 2008, endYear: 2013) let strangerThings = TVSeries(title: \u0026#34;Stranger Things\u0026#34;, startYear: 2016, endYear: nil) print(\u0026#34;\\(breakingBad.title) is still airing?: \\(breakingBad.isAiring)\u0026#34;) print(\u0026#34;\\(strangerThings.title) is still airing?: \\(strangerThings.isAiring)\u0026#34;) En este fragmento de estructura de una serie de televisi√≥n, puedes ver que la propiedad calculada se divide en dos componentes: el get (que se ejecutar√° cuando quieras acceder al valor, es decir, en la l√≠nea del print) y el set (que se ejecuta cuando se ha establecido el valor de la variable calculada, despu√©s de haberse ejecutado el print)\nAs√≠, en el get, puedes ver que cuando necesites el valor la propiedad isAiring (que indica si est√° en emisi√≥n) comprobar√° si tiene fecha de fin (en cuyo caso, ya no estar√° en emisi√≥n).\nSin embargo, el set, imprimir√° un mensaje dependiendo si el valor ha sido establecido a true o false. Como puedes ver tambi√©n, se puede acceder al nuevo valor mediante la variable newValue que Swift crear√° autom√°ticamente.\nPropiedades de solo lectura #Las propiedades calculadas, que solo tienen get pero no tienen set se consider√°n propiedades de solo lectura, ya que no se ejecutar√° nada, cuando se establezca el valor, y por lo tanto, solo se podr√° leer.\nPuedes ver este ejemplo:\nstruct Rectangle { var width: Double var height: Double var area: Double { get { return width * height } } } El √°rea de un rect√°ngulo, solo puede leerse, ya que si la modificas, obligatoriamente modificar√≠as el ancho y/o el alto, por eso en este ejemplo, solo existe el get.\nEl ejemplo anterior, se puede simplicar de dos formas:\nComo solo tiene el get, se puede omitir. Como solo existe una sentencia, se puede omitir el return. struct Rectangle { var width: Double var height: Double var area: Double { width * height } } De esta forma, puedes mejorar la legibilidad de tu c√≥digo\u0026hellip; y qui√©n tenga que mantenerlo te lo agradecer√° üòâ.\nObservadores de propiedad #Los observadores de propiedad, hacen que se puedan realizar acciones, cuando el valor de una propiedad cambia. Es decir, ser√≠a similar al set de una propiedad calculada, pero los observadores te permiten ejecutar acciones:\nAntes de que se cambie el valor (willSet) Cuando se ha cambiado el valor (didSet) Los observadores de propiedad, se ejecutar√°n SIEMPRE que se establezca un valor en una propiedad. Aunque el valor establecido sea el mismo que ya ten√≠a previamente. Los observadores de propiedad se pueden utilizar en:\nPropiedades almacenadas que t√∫ definas Propiedades almacenadas que heredes Propiedades calculadas que heredes Mira este otro ejemplo:\nstruct ProgressTracker { var task: String var percentageComplete: Double { willSet(newPercentage) { print(\u0026#34;Will set percentageComplete for \\(task) to \\(newPercentage)%\u0026#34;) } didSet { print(\u0026#34;Did set percentageComplete for \\(task) from \\(oldValue)% to \\(percentageComplete)%\u0026#34;) if percentageComplete == 100.0 { print(\u0026#34;\\(task) is now complete.\u0026#34;) } } } } var reportProgress = ProgressTracker(task: \u0026#34;Download\u0026#34;, percentageComplete: 0) reportProgress.percentageComplete = 30 reportProgress.percentageComplete = 80 reportProgress.percentageComplete = 100 Como puedes ver, puedes pasar el nombre del valor que podr√°s utilizar en su bloque (como por ejeplo con la constante newPercentaje).\nTambi√©n puedes usar oldValue, que es la constante que crea autom√°ticamente Swift, y que almacena el valor anterior.\nProperty wrappers (envoltorios de propiedad) #Por √∫ltimo, es importante saber que tambi√©n existen property wrappers, permiten separar el c√≥digo que gestiona como una propiedad es almacenada y el c√≥digo que define dicha propiedad, y esto lo consigue, envolviendo el c√°lculo.\nLo podr√≠as hacer de la siguiente forma:\n@propertyWrapper struct NonNegative { private var value: Int var wrappedValue: Int { get { value } set { value = max(0, newValue) } // Ensure the value is never negative } // Initialize with a value that is guaranteed to be non-negative init(wrappedValue: Int) { self.value = max(0, wrappedValue) } } struct InventoryItem { @NonNegative var stock: Int } var item = InventoryItem(stock: 5) print(item.stock) // Prints: 5 item.stock = -3 print(item.stock) // Prints: 2 Con este ejemplo, puedes tratar por una parte como se gestionan las propiedades para comprobar que una propiedad no tenga un valor entero negativo. Y as√≠, reutilizarlo en otras partes del c√≥digo, sin tener que copiar y pegar el contenido de los getters y los setters.\nEl uso de property wrappers, requiere y permite muchos m√°s detalles, as√≠ que si quieres saber m√°s puedes verlo en la documentaci√≥n oficial.\nConclusi√≥n #Has podido ver como las propiedades, b√°sicamente definen las caracter√≠sticas del tipo al que pertenecen.\nPero, para poder aprovecharlas al m√°ximo, y optimizar tu c√≥digo, es clave conocer todas las operaciones que puedes hacer con ellas.\nSwift, como en muchas otras car√°cter√≠sticas, ofrece diferentes m√©todos para acceder, calcular y devolver valores de propiedades, lo que hace que escribir c√≥digo eficiente sea m√°s sencillo.\n","date":"18 abril 2024","permalink":"/es/blog/propiedades-swift/","section":"Blog","summary":"Las propiedades permiten almacenar valores con informaci√≥n sobre el tipo que las define","title":"Definiendo las caracter√≠sticas de los tipos: Las propiedades"},{"content":"Episodio n¬∫ 4 En el episodio de hoy te voy a hablar de mi visi√≥n sobre c√≥mo aprovechar la inteligencia artificial para programar, de c√≥mo la he usado hasta ahora, y c√≥mo espero poder usarla en un futuro.\nDisponible en:\nYoutube\nApple Podcasts\nSpotify\n","date":"15 abril 2024","permalink":"/es/podcast/inteligencia-articifial-para-programar/","section":"Programando para Apple","summary":"Mi visi√≥n y experiencia sobre c√≥mo aprovechar la inteligencia artificial para programar","title":"Usar IA para programar"},{"content":"Episodio n¬∫ 3 Hoy te cuento qu√© me ha supuesto el cambio de trabajar con UIKit a SwiftUI, y las principales ventajas que le veo al nuevo framework para el desarrollo de interfaces en aplicaciones para sistemas de Apple.\nDisponible en:\nYoutube\nApple Podcasts\nSpotify\n","date":"8 abril 2024","permalink":"/es/podcast/uikit-swiftui/","section":"Programando para Apple","summary":"Qu√© me ha supuesto el cambio de trabajar con UIKit a SwiftUI, y las principales ventajas de usarlo","title":"De UIKit a SwiftUI"},{"content":"Existen numerosos tipos de aplicaciones. Me atrever√≠a a decir, que casi tantos, como tipos de empresas o desarrolladores. Y, aunque tenemos un n√∫mero importante en nuestros dispositivos, tambi√©n es cierto que el n√∫mero de las que utilizamos habitualmente se reduce dr√°sticamente.\nEsto muestra la importancia de seleccionar cada uno de los detalles que engloban a una app: UX/UI, contenido, onboarding, accesibilidad‚Ä¶ detalles que cambiar√°n tambi√©n notablemente seg√∫n al p√∫blico que se dirijan, y por lo tanto, tambi√©n podremos decir que existir√°n tantos tipos de cada elemento, como usuarios.\nPero si hay algo que reduce las posibilidades a un n√∫mero m√°s reducido, es el modelo de negocio escogido para, como tanto nos gusta üòâ, que nuestra app sea rentable.\n¬øY sabes que esos beneficios pueden variar considerablemente dependiendo del modelo que escojas?\nPor eso hoy quiero hablarte de los distintos modelos de negocio que puedes utilizar si vas a lanzar una aplicaci√≥n para un dispositivo Apple, y que sea lo m√°s rentable posible.\nModelos de negocio de aplicaciones en App Store #Gratuito #En una aplicaci√≥n gratuita, el usuario podr√° descargar la app y podr√° utilizarla completamente, sin realizar ning√∫n pago.\nEste modelo es utilizado en muchas ocasiones cuando no se buscan beneficios directamente econ√≥micos: mejorar imagen de marca, validaci√≥n de idea de mercado, mostrar un portfolio‚Ä¶\nLa opci√≥n m√°s habitual para generar ingresos directos con este modelo es mediante la inserci√≥n de banners de publicidad.\nDe esta forma, el modelo de negocio ser√° muy similar a sitios webs de contenido que obtienen sus ingresos de la publicidad, por lo que necesitar√°s un importante n√∫mero de usuarios que usen tu app, y adem√°s, que lo hagan de forma recurrente, para que esos ingresos se mantengan a lo largo del tiempo. Adem√°s, es muy importante no saturar al usuario con publicidad para no emprobrecer la experiencia de usuario.\nEn este caso puedes utilizar SDKs de terceros para poder ingresar los anuncios, siendo la m√°s utilizada, la plataforma AdMob de Google. En su documentaci√≥n puedes ver c√≥mo y d√≥nde insertar el c√≥digo para mostrar los anuncios.\nYa ser√≠a la plataforma de anuncios escogida la que te mostrar√≠a la gesti√≥n de dichos anuncios, beneficios, configuraci√≥n, etc‚Ä¶ y tendr√≠a sus propios requisitos de pago.\nFreemium #En el modelo Freemium, el usuario descarga la app de forma gratuita.\nA partir de ah√≠, tienes dos opciones: Dar un periodo por el que el usuario podr√° utilizar todas las caracter√≠sticas y acceder al contenido de toda la app, cuando dicho periodo expire, deber√° pagar para continuar us√°ndola. Ofrecer un contenido o caracter√≠sticas b√°sicas, que puede usar de forma ilimitada mientras quiera, pero el usuario en este caso deber√° pagar para acceder a un contenido o caracter√≠sticas de mayor valor.\nEs decir, el usuario utilizar√° una parte de la aplicaci√≥n o por un tiempo delimitado, pero deber√° pagar para utilizarla completamente (es decir, por la parte Premium, no incluida en la parte gratuita)\nEn este modelo, es clave mostrar en la parte que el usuario ver√° gratuitamente, los detalles que mas valor le puedan aportar y solucionen el problema por el que se decidi√≥ a descargar tu app, y por lo tanto, que quiera seguir us√°ndola completamente.\nPara este caso, Apple pone a tu disposici√≥n las siguientes formas de compras \u0026lsquo;in-app\u0026rsquo;\nConsumibles #El usuario paga, por elementos que puede consumir: como por ejemplo, gemas, vidas o cartas.\nEste tipo es especialmente usado en juegos donde el usuario necesita alg√∫n elemento que usar√° para seguir avanzando.\nNo consumibles #El usuario paga una √∫nica vez, y con ello, consigue el nuevo contenido o caracter√≠stica, de forma ilimitada.\nEn este caso, puede utilizarse para otro tipo de aplicaciones que no sean un juego: un nuevo filtro para aplicaci√≥n de c√°mara, elementos de adorno para su avatar, etc‚Ä¶\nSuscripciones autorenovables #El usuario pagar√° por el contenido Premium, que utilizar√° durante un periodo de tiempo limitado.\nAs√≠, finalizado el mismo, se renovar√° autom√°ticamente.\nSuscripciones no renovables #Igual que la anterior, pero en este caso la suscripci√≥n no se renovar√° autom√°ticamente.\nM√°s informaci√≥n sobre las opciones de cobro en el modelo Freemium #Puedes ver m√°s informaci√≥n y guias muy √∫tiles en la p√°gina de desarrollador de Apple sobre modelos de negocio y monetizaci√≥n\nPago √∫nico #En este modelo de pago el usuario pagar√° para poder descargar la aplicaci√≥n.\nUna vez descargada, el usuario puede acceder a todo el contenido y funciones de tu app, es el modelo de pago directo m√°s sencillo que existe, similar a la compra de un bien f√≠sico.\nPara este modelo, lo m√°s importante es que puedas mostrar al usuario las capacidades y beneficios de tu app.\nComo primera opci√≥n (la primera impresi√≥n cuenta mucho) es fundamental seleccionar cuidadosamente las capturas de pantallas y videos que subir√°s al App Store, as√≠ como saber explicar en la descripci√≥n de la app, los problemas que podr√° resolver tu usuario.\nOtra alternativa muy recomendable ser√≠a tener una landing page para que puedas mostrar m√°s info sobre los beneficios que t√∫ app aporta a los usuarios, tanto en texto, como en im√°genes o en v√≠deo\nLos precios se establecen cuando se sube la aplicaci√≥n al App Store, en la p√°gina de configuraci√≥n del producto, pudiendo personalizar los distintos precios para los distintos pa√≠ses.\nPaymium #En un modelo Paymium, el usuario paga por descargar la app, y con ello tendr√° acceso a determinadas caracter√≠sticas, pero para poder utilizarla completamente (parte Premium), deber√° pagar de nuevo.\nEsta es una forma que se puede aplicar a apps de mayor precio, permitiendo su uso m√°s b√°sico a un precio reducido.\nPuede ser interesante para apps que puedan ser usadas para aficionados y para profesionales, siendo estos √∫ltimos los que pagar√≠an por la app completa si ello les supone un beneficio mayor que el gasto que han realizado.\nComo en el caso anterior, una combinaci√≥n de excelente p√°gina de producto en el App Store e informaci√≥n adicional fuera de ella, facilitar√° las compras.\nEn este modelo, tambi√©n se configurar√° en la p√°gina de producto de la aplicaci√≥n en el App Store, utilizando una combinaci√≥n\nBeneficios e inconvenientes de los modelos # Modelo Ventajas Inconvenientes Gratuito Facilidad de descarga por parte de los usuarios para probarla. Mayor dificultad para retener los usuarios.\nUna excesiva publicidad resulta en peor experiencia de usuario. Freemium Facilidad de descarga, igual que el modelo gratuito, lo que permite validar su aceptaci√≥n.\nSi el usuario decide pagar, es una forma de costear las futuras actualizaciones. Dificultad para mostrar valor en parte gratuita y que quieran pagar por la premium. Pago √∫nico Se obtienen ingresos desde el primer momento. Dificultad para descargar al requerir previo pago, en especial para las m√°s costosas.\nSolo se obtiene ingreso por descargar, pero no por mantener la app. Paymium Se obtienen ingresos desde el primer momento, y tambi√©n por el desarrollo de nuevas caracter√≠sticas y actualizaciones. Ser√° m√°s complejo que el usuario acceda a usar la app, sabiendo que para otras opciones, deber√° volver a pagar. Modelos de negocio alternativos #Si bien los que has visto anteriormente son los que puedes gestionar m√°s directamente a trav√©s de Apple, y por lo tanto, los que te recomiendo. Dispones de otras v√≠as para obtener ingresos de tus m√°s apps\nPatrocinios #Si consigues asociarte con una marca que quiera darse a conocer a trav√©s de tu app, podr√≠as organizar activaciones que permitieran tanto a dicha marca como a tus usuarios beneficiarse de dicha acci√≥n, por lo que estoy ser√≠a una nueva v√≠a de ingresos con los que costear el desarrollo y mantenimiento de tu app.\nCrowdfunding #En este caso, podr√≠as lanzar una campa√±a de crowfunding, con lo que en un primer momento podr√≠as conseguir la financiaci√≥n necesaria para poner en marcha el desarrollo de la app. Adem√°s, con usuarios habiendo aportado un pago por adelantado antes de hacer la aplicaci√≥n, podr√≠as validar la idea y confirmar que aporta valor a tus usuarios.\nTambi√©n ser√≠a una opci√≥n si esto permite escalar la app ofreciendo caracter√≠sticas que supongan una importante mejora.\nDespu√©s, tus usuarios podr√≠an hacer uso de c√≥digos de descarga o de desbloqueo de caracter√≠sticas para obtener esa recompensa por la financiaci√≥n que te han facilitado.\nAfiliaci√≥n #Un modelo de afiliaci√≥n que permita ‚ÄúInvitar a un amigo‚Äù a probar la aplicaci√≥n, aunque conllevar√≠a que tuvieras que recompensar a quienes invitan, te podr√≠a traer un considerable n√∫mero de compras o suscripciones.\nConclusi√≥n #Apple pone a disposici√≥n de desarrolladores y organizaciones las herramientas para sus modelos de negocios recomendados, pero ser√°s t√∫ qui√©n deber√° seleccionar el m√°s adecuado para tu app en funci√≥n de tus usuarios y objetivos.\nNo es una decisi√≥n trivial por lo que, dedicarle el tiempo necesario puede repercutir en que el negocio de la aplicaci√≥n sea viable o un fracase. Como en tantos otros elementos en los que el usuario tiene tanto que decir, recoger feedback y responder r√°pidamente a la demanda, puede ahorrarte tiempo, dinero y disgustos.\nAdem√°s, los distintos modelos, cuentan con su configuraci√≥n para determinar y cobrar los importes de forma segura, nativa y eficiente.\nCada uno de los modelos o estrategias pueden combinarse para alinearse con las necesidades o las estrategias de marketing que determines, pero tambi√©n ser√° clave poner al usuario en el centro.\nPor √∫ltimo, como seguramente sabr√°s y quiz√° est√©s pensando, ya se pueden integrar tiendas de terceros en iOS en Europa‚Ä¶ pero eso ya queda para otro (u otros) art√≠culos.\nY ahora que sabes esto ¬øqu√© modelo te parece m√°s interesante para tu aplicaci√≥n?\n","date":"4 abril 2024","permalink":"/es/blog/modelos-negocio-apps-apple/","section":"Blog","summary":"La elecci√≥n del modelo de negocio y monetizaci√≥n de tu app es vital para su √©xito y tus beneficios","title":"Modelos de negocio de aplicaciones en Apple: Descubre el perfecto para tu app"},{"content":"Episodio 2 Hoy te cuento por qu√© es tan importante tus aplicaciones sean de calidad y tengan el menor n√∫mero de bugs, pero adem√°s, desde un punto de vista que no es tan habitual, y que muestra tu valor como profesional.\nDisponible en:\nYoutube\nApple Podcasts\nSpotify\n","date":"1 abril 2024","permalink":"/es/podcast/calidad-apps/","section":"Programando para Apple","summary":"Por qu√© es tan importante tus aplicaciones sean de calidad","title":"La calidad de tus apps"},{"content":"En el mundo del desarrollo de software con Swift, una de las decisiones fundamentales que enfrentamos es la elecci√≥n entre estructuras y clases. Ambas son constructos esenciales que nos permiten modelar nuestros datos de manera eficiente, pero sus diferencias son cruciales para escribir c√≥digo eficiente y f√°cil de entender.\nLas estructuras y clases en Swift comparten varias similitudes. Ambas pueden definir propiedades para almacenar valores, m√©todos para a√±adir funcionalidad, sub√≠ndices para acceder a valores con una sintaxis espec√≠fica, y se pueden extender para aumentar su funcionalidad. Sin embargo, es en sus diferencias donde encontramos las claves para decidir cu√°ndo usar cada una.\n¬øCu√°ndo usar estructuras? #Las estructuras son tipos de valor. Esto significa que se copian cuando se asignan a una nueva variable o se pasan a una funci√≥n. Son la elecci√≥n predilecta para representar datos simples y aut√≥nomos que no necesitan heredar propiedades de otro lugar. Por ejemplo, para modelar las especificaciones de un videojuego, podr√≠as usar una estructura:\nstruct VideoGame { var name: String var genre: String var platform: String } let halo = VideoGame(name: \u0026#34;Halo Infinite\u0026#34;, genre: \u0026#34;FPS\u0026#34;, platform: \u0026#34;Xbox\u0026#34;) Este modelo es √∫til cuando los valores copiados son lo que necesitas, como pasar los datos de un videojuego de un lado a otro en tu app sin preocuparte por efectos secundarios no deseados.\n¬øCu√°ndo usar clases? #Las clases son tipos de referencia. A diferencia de las estructuras, si asignas una instancia de una clase a una nueva variable o la pasas a una funci√≥n, lo que se pasa es una referencia a la misma instancia. Esto es √∫til cuando necesitas tener un √∫nico objeto que se actualice y se acceda desde m√∫ltiples lugares. Por ejemplo, podr√≠as querer tener un objeto que represente una sesi√≥n de usuario:\nclass UserSession { var user: String var status: String init(user: String, status: String) { self.user = user self.status = status } } let session = UserSession(user: \u0026#34;Oski82\u0026#34;, status: \u0026#34;Active\u0026#34;) Utilizar una clase aqu√≠ permite que cualquier cambio en la session se refleje a trav√©s de toda la app, lo cual ser√≠a crucial para el manejo de estados como el inicio o cierre de sesi√≥n.\nDiferencias clave # Herencia: Solo las clases pueden heredar de otra clase. Esto las hace poderosas para casos de uso polim√≥rficos. Tipo de referencia vs. tipo de valor: Este es probablemente el mayor factor diferenciador. Afecta c√≥mo se transmite la informaci√≥n en tu app y puede tener implicaciones significativas en el rendimiento y el uso de la memoria. Conteo de referencias: Solo las clases soportan el conteo de referencias, permitiendo que m√°s de una referencia apunte a la misma instancia de una clase. Esto es √∫til para manejar la vida √∫til de los objetos, especialmente en entornos con m√∫ltiples hilos. Recomendaciones # Prioriza estructuras sobre clases: Son m√°s r√°pidas y seguras en un contexto de concurrencia debido a que trabajan con copias de los datos que contienen. Usa clases cuando necesites herencia o manejo de identidad √∫nico: Por ejemplo, para controlar una √∫nica instancia de un servicio de red o una sesi√≥n de usuario compartida a trav√©s de tu app. Conclusi√≥n #La elecci√≥n entre estructuras y clases depende de la naturaleza de tus datos y de c√≥mo planeas usarlos en tu aplicaci√≥n. Si bien las estructuras ofrecen una manera segura y eficiente de trabajar con datos copiados, las clases proporcionan poderosas herramientas para el manejo de estados compartidos y la herencia. Al elegir conscientemente entre estos dos constructos, puedes escribir c√≥digo m√°s claro, eficiente y adecuado a tus necesidades.\n","date":"28 marzo 2024","permalink":"/es/blog/estructuras-clases/","section":"Blog","summary":"Ambas opciones permiten encapsular y reutilizar valores y comportamientos, pero conocer sus diferencias ayuda a optimizar tu c√≥digo","title":"Dominando las bases: Estructuras vs. clases"},{"content":"Episodio n¬∫ 1 Te cuento los objetivos y c√≥mo ser√° este podcast, enfocado a profesionales y empresas que programan aplicaciones para Apple. Adem√°s, te hablo sobre m√≠ y sobre mi carrera profesional.\nDisponible en:\nYoutube\nApple Podcasts\nSpotify\n","date":"25 marzo 2024","permalink":"/es/podcast/presentacion/","section":"Programando para Apple","summary":"Presentaci√≥n del podcast de desarrollo de aplicaciones para dispositivos Apple.","title":"Presentaci√≥n"},{"content":"¬°Hola! Hoy quiero compartir contigo algunos consejos pr√°cticos y directrices fundamentales para ayudarte a superar con √©xito el proceso de revisi√≥n en el App Store de Apple. Si eres desarrollador y buscas lanzar tu aplicaci√≥n en esta plataforma, sabr√°s que el detalle marca la diferencia. As√≠ que, vamos a adentrarnos juntos en este camino hacia el √©xito.\nPreparaci√≥n antes de la publicaci√≥n #El primer paso es asegurarte de que est√°s completamente preparado. Esto significa tener una cuenta de desarrollador activa con Apple y asegurarte de que tu aplicaci√≥n cumpla con todas sus directrices, tanto t√©cnicas como visuales. Recuerda, la preparaci√≥n es la clave.\nAspectos t√©cnicos y de dise√±o #Apple pone un gran √©nfasis en la calidad y la experiencia de usuario. Tu aplicaci√≥n debe ser libre de errores, funcionar de manera fluida en todos los dispositivos y ofrecer una experiencia de usuario intuitiva. Cada detalle cuenta en la interfaz y la usabilidad, no solo para superar la revisi√≥n, sino para destacar en el mercado.\nUtilizar las herramientas proporcionadas por Apple #Aprovecha las herramientas que Apple pone a tu disposici√≥n. Xcode Cloud y TestFlight son indispensables en tu arsenal de desarrollo. Xcode Cloud facilita el desarrollo colaborativo, mientras que TestFlight es esencial para las pruebas beta y la recopilaci√≥n de feedback antes de tu lanzamiento final.\nPersonalizaci√≥n y pruebas A/B #Personalizar la p√°gina de tu aplicaci√≥n para diferentes audiencias y evaluar el rendimiento de distintos elementos puede marcar la diferencia en c√≥mo conectas con tu audiencia. Esta flexibilidad es clave para optimizar tu presentaci√≥n y lograr un mayor impacto.\nContenido y funcionalidad de la aplicaci√≥n #Tu aplicaci√≥n debe ofrecer un contenido completo y valioso. Evita publicar con errores, enlaces rotos o descripciones imprecisas. Una experiencia rica y sin fisuras es fundamental no solo para la aprobaci√≥n, sino tambi√©n para el √©xito en el App Store.\nAtenci√≥n al detalle en la presentaci√≥n #Desde el nombre y la descripci√≥n de tu aplicaci√≥n hasta las capturas de pantalla y el icono, cada elemento debe ser cuidadosamente considerado. Estos materiales deben cumplir con las especificaciones de Apple y comunicar efectivamente lo que ofrece tu aplicaci√≥n.\nSoporte y asistencia continua #Utiliza los recursos y el soporte que Apple ofrece. Documentos t√©cnicos, c√≥digos de muestra y la posibilidad de colaborar directamente con ingenieros de Apple son fundamentales para resolver cualquier desaf√≠o durante el desarrollo de tu aplicaci√≥n.\nCumplimiento de las pol√≠ticas de Apple #Es esencial que tu aplicaci√≥n cumpla con todas las pol√≠ticas de Apple. Esto incluye normas sobre privacidad, seguridad y contenido. Para asegurarte de que tu aplicaci√≥n se alinea con estas pol√≠ticas, revisa los siguientes enlaces oficiales:\nApp Store Review Guidelines Apple Developer Program License Agreement Siguiendo estos consejos y haciendo uso de los recursos proporcionados por Apple, mejorar√°s significativamente tus posibilidades de √©xito en el App Store. El detalle define el √©xito, y cada paso que tomas es crucial. Con dedicaci√≥n, atenci√≥n al detalle y una actitud proactiva hacia el aprendizaje y la mejora continua, no hay duda de que puedes crear experiencias excepcionales que cautivar√°n a usuarios de todo el mundo.\nRecuerda, mientras el camino hacia la aprobaci√≥n en el App Store puede parecer desalentador, cada desaf√≠o es una oportunidad para aprender y crecer. Con la preparaci√≥n adecuada, el uso efectivo de las herramientas de Apple, y una atenci√≥n meticulosa a las pol√≠ticas y directrices de la plataforma, estar√°s bien equipado para superar la revisi√≥n de publicaci√≥n en el App Store. Y no olvides, en este viaje no est√°s solo. La comunidad de desarrolladores y los recursos proporcionados por Apple est√°n aqu√≠ para apoyarte en cada paso del camino.\nEspero que este art√≠culo te haya sido √∫til y te haya proporcionado una buena base sobre la que construir y lanzar tu aplicaci√≥n con √©xito. Recuerda que la comunidad de desarrolladores es un gran recurso, y nunca est√° de m√°s buscar consejo o compartir tus propias experiencias. ¬°Juntos hacemos crecer esta incre√≠ble plataforma!\n","date":"18 marzo 2024","permalink":"/es/blog/revision-publicacion-app-store/","section":"Blog","summary":"Te cuento las claves para superar r√°pida y eficazmente la revisi√≥n de publicaci√≥n de tu app en el App Store","title":"Claves para superar la revisi√≥n de publicaci√≥n en el App Store"},{"content":"Las enumeraciones, o simplemente enums como las conocemos en Swift, son esa herramienta imprescindible en tu kit de desarrollo, permiti√©ndote definir un tipo com√∫n para un grupo de valores relacionados. Esto no solo va a mejorar la legibilidad de tu c√≥digo, sino que tambi√©n facilitar√° su mantenimiento y te ayudar√° a evitar esos errores comunes que a todos nos gusta evitar. Si est√°s empezando en Swift y a√∫n te est√°s familiarizando con la creaci√≥n de funciones, entender las enumeraciones puede ser realmente revelador.\n¬øQu√© son las enumeraciones? #Imagina que est√°s trabajando en una app sobre series de televisi√≥n. Tienes diferentes g√©neros como drama, comedia, terror, etc. En lugar de gestionar estos g√©neros como cadenas de texto (lo que podr√≠a llevar a errores de escritura) puedes definir una enumeraci√≥n:\nenum TVShowGenre { case drama case comedy case horror case sciFi } Con esta definici√≥n, puedes usar TVShowGenre de manera segura y controlada, mejorando as√≠ la legibilidad y la consistencia de tu c√≥digo.\n¬øCu√°ndo usar enums? #Las enumeraciones son incre√≠blemente √∫tiles cuando necesitas agrupar conjuntos de valores relacionados que ya conoces. Por ejemplo, en una app para seguir las temporadas de F√≥rmula 1, podr√≠as tener una enumeraci√≥n para los equipos:\nenum F1Team { case mercedes case ferrari case redBull case mclaren } Este enfoque garantiza que solo puedas asignar pilotos a los equipos que existen en tu enumeraci√≥n, evitando asignaciones incorrectas.\nValores asociados #Swift lleva las enumeraciones a√∫n m√°s all√°, permitiendo casos con valores asociados. Esto significa que puedes almacenar valores adicionales de otros tipos junto con los casos de la enumeraci√≥n. Imagina que est√°s creando un videojuego y quieres definir diferentes tipos de enemigos, algunos con atributos especiales:\nenum Enemy { case soldier case wizard(magicStrength: Int) case boss(isFinal: Bool, lives: Int) } Aqu√≠, wizard tiene un valor asociado magicStrength, y boss tiene dos valores asociados, indicando si es el jefe final y cu√°ntas vidas tiene. Esto te permite manejar cada tipo de enemigo de forma m√°s espec√≠fica y detallada en tu juego.\nRaw Values y la herencia del protocolo String #Las enumeraciones en Swift pueden tener raw values, que son valores predefinidos que puedes asociar con cada caso de la enumeraci√≥n. Esto es especialmente √∫til cuando tu enumeraci√≥n necesita representar un valor de cadena o num√©rico espec√≠fico para cada caso.\nPor ejemplo, podr√≠as tener una enumeraci√≥n que represente los pilotos de F√≥rmula 1, donde cada piloto se asocia con su nombre completo correspondiente:\nenum Drivers: String { case verstappen = \u0026#34;Max Verstappen\u0026#34; case alonso = \u0026#34;Fernando Alonso\u0026#34; case leclerc = \u0026#34;Charles Leclerc\u0026#34; } Aqu√≠, Drivers es una enumeraci√≥n que hereda del protocolo String. Esto significa que cada caso tiene un raw value de tipo String que coincide con su nombre. Por ejemplo, puedes acceder al raw value de un piloto de la siguiente manera:\nlet driver = Drivers.verstappen print(driver.rawValue) // Print \u0026#34;Max Verstappen\u0026#34; Esto es particularmente √∫til cuando necesitas trabajar con datos que provienen de una fuente externa que utiliza representaciones de cadena, como un servidor web o una base de datos.\nAdem√°s, cuando una enumeraci√≥n hereda del protocolo String, Swift autom√°ticamente asigna a cada caso un raw value que coincide con el nombre del caso, lo que te ahorra la necesidad de asignar expl√≠citamente un raw value a cada caso.\nenum Track: String { case monaco case spa } let track = Track.monaco.rawValue // track is a String with value \u0026#34;monaco\u0026#34; En resumen, el uso de raw values y la herencia del protocolo String en tus enumeraciones puede mejorar la legibilidad de tu c√≥digo, facilitar la interacci√≥n con otras partes de tu c√≥digo que utilizan cadenas y n√∫meros, y ayudarte a evitar errores al manejar datos externos. ¬°Espero que esto te ayude a entender a√∫n m√°s el poder de las enumeraciones en Swift!\nConclusi√≥n #Las enumeraciones en Swift son una forma potente y segura de trabajar con conjuntos de valores relacionados.\nFacilitan la escritura de c√≥digo m√°s limpio y mantenible, al tiempo que previenen errores comunes limitando los valores a los definidos en la enumeraci√≥n. Los valores asociados ofrecen una flexibilidad adicional, permiti√©ndote incluir informaci√≥n espec√≠fica directamente en tus tipos de datos. Los valores raw te permiten usar cadenas de tus casos. Al dominar las enumeraciones, estar√°s dando un paso enorme hacia el desarrollo de software m√°s robusto y eficiente. ¬°Es tu turno de experimentar con ellas y ver todo lo que pueden hacer por tus proyectos!\n","date":"11 marzo 2024","permalink":"/es/blog/enums-swift/","section":"Blog","summary":"Las enumeraciones permiten defininir un tipo com√∫n para unos valores asociados","title":"Enumeraciones"},{"content":"Los closures son un concepto fundamental en Swift. Son herramientas poderosas que te permiten definir y manipular bloques de c√≥digo, por eso se les considera ciudadanos de primera clase. En este art√≠culo, exploraremos los closures, los closures finales, la captura de valores y el hecho de que los closures son tipos por referencia\nClosures #Un closure es un bloque de c√≥digo aut√≥nomo que se puede pasar y utilizar en el c√≥digo, como cualquier otra constante o variable. En Swift, puedes definir closures usando las llaves {}. Este ser√≠a un ejemplo sencillo:\nlet greet = { print(\u0026#34;Hello, world!\u0026#34;) } Closures finales #Los closures finales son una forma conveniente de incluir un closure como √∫ltimo argumento de una funci√≥n. Esto hace que tu c√≥digo sea m√°s legible. Supongamos que tienes una funci√≥n que toma un closure como argumento:\nfunc performAction(action: () -\u0026gt; Void) { // Perform some setup action() } // Using a trailing closure performAction { print(\u0026#34;Action performed!\u0026#34;) } Capturando valores #Los closures pueden capturar y almacenar referencias a variables y constantes del contexto en el que se definen. Esto significa que pueden \u0026ldquo;recordar\u0026rdquo; y manipular esos valores incluso si ya no est√°n dentro de su √°mbito. Mira este ejemplo:\nfunc makeIncrementer(incrementAmount: Int) -\u0026gt; () -\u0026gt; Int { var total = 0 let incrementer: () -\u0026gt; Int = { total += incrementAmount return total } return incrementer } // Usage example: let incrementByTwo = makeIncrementer(incrementAmount: 2) let incrementByFive = makeIncrementer(incrementAmount: 5) print(incrementByTwo()) // Output: 2 print(incrementByTwo()) // Output: 4 print(incrementByTwo()) // Output: 6 print(incrementByFive()) // Output: 5 print(incrementByFive()) // Output: 10 print(incrementByFive()) // Output: 15 En este ejemplo, definimos la funci√≥n makeIncrementer, que toma un incrementAmount como argumento y devuelve un closure de tipo () -\u0026gt; Int. Cada vez que llama al closure devuelto, incrementa la variable total en el valor de incrementAmount especificado y devuelve el total actualizado. Creamos dos closures separados, incrementByTwo e incrementByFive, cada uno con su propio total capturado y su incrementAmount. Cuando llamamos a estos closures varias veces, puedes ver c√≥mo mantienen su estado individual y aumentan en sus respectivos cantidades.\nLos closures son tipos por referencia #Los closures son m√°s que simples bloques de c√≥digo, son tipos por referencia. Puedes declarar un closure y las variables de ese tipo pueden contener closures con las mismas firmas. Esto te permite definir funciones que toman closures como par√°metros, o que los devuelven como resultados, proporcionando flexibilidad y reutilizaci√≥n en tu c√≥digo.\nConclusi√≥n #En resumen, los closures son un concepto clave en Swift y comprenderlos es esencial para cualquier desarrollador de iOS. Proporcionan una forma flexible de trabajar con c√≥digo y datos, ya sea que est√©s creando funciones simples u operaciones as√≠ncronas avanzadas. Al dominar los closures, rastrearlos, capturar valores y reconocer que los closures son tipos por referencia, estar√°s mejor capacitado para escribir c√≥digo Swift eficiente y legible.\n","date":"5 septiembre 2023","permalink":"/es/blog/closures-en-swift/","section":"Blog","summary":"Un closure es un bloque que puede ser usado en tu c√≥digo","title":"Entendiendo los closures en Swift"},{"content":"","date":null,"permalink":"/es/apps/shary/","section":"Apps","summary":"Shary es una aplicaci√≥n f√°cil e intuitiva para compartir gastos.","title":"Shary"},{"content":"Como desarrolladores, a menudo manejamos situaciones en las que necesitamos trabajar con funciones en nuestras aplicaciones iOS. Las funciones son una parte integral del lenguaje de programaci√≥n Swift y nos proporcionan un conjunto de herramientas poderosas para construir c√≥digo flexible y modular. En este art√≠culo, exploraremos el concepto de usar tipos de funciones y c√≥mo puede beneficiar nuestro proceso de desarrollo.\nDeterminar el tipo de funci√≥n #En Swift, las funciones se consideran ciudadanos de primera clase, lo que significa que pueden asignarse a variables o constantes y tambi√©n pueden usarse como tipos. Para determinar el tipo de una funci√≥n, podemos usar la firma de la funci√≥n. La firma consta de los tipos de par√°metros y el tipo de retorno. Consideremos un ejemplo:\nfunc add(_ a: Int, _ b: Int) -\u0026gt; Int { return a + b } El tipo de esta funci√≥n puede representarse como (Int, Int) -\u0026gt; Int, donde (Int, Int) representa los tipos de par√°metros e Int representa el tipo de retorno.\nUsar tipos de funciones como par√°metros #Una de las ventajas de usar tipos de funciones es la capacidad de pasarlas como par√°metros a otras funciones. Esto nos permite crear funciones de orden superior que pueden aceptar diferentes comportamientos seg√∫n las funciones proporcionadas. Tomemos un ejemplo donde tenemos una funci√≥n que aplica una operaci√≥n dada en una matriz de enteros:\nfunc applyOperation(_ numbers: [Int], operation: (Int) -\u0026gt; Int) -\u0026gt; [Int] { var result = [Int]() for number in numbers { let transformedNumber = operation(number) result.append(transformedNumber) } return result } En el c√≥digo anterior, la funci√≥n applyOperation toma una matriz de enteros y una funci√≥n operation como par√°metros. El par√°metro operation representa una funci√≥n que toma un entero y devuelve un entero. Podemos usar esta funci√≥n de orden superior para realizar varias operaciones en nuestra matriz de n√∫meros.\nUsar tipos de funciones como retorno #Otro aspecto poderoso de usar tipos de funciones es la capacidad de usarlos como valores de retorno. Esto nos permite crear funciones que generan y devuelven din√°micamente otras funciones seg√∫n ciertas condiciones o requisitos. Consideremos un ejemplo:\nfunc operationFactory() -\u0026gt; (Int) -\u0026gt; Int { if condition { return { number in number * 2 } } else { return { number in number / 2 } } } En este ejemplo, la funci√≥n operationFactory devuelve una funci√≥n del tipo (Int) -\u0026gt; Int basada en una cierta condici√≥n. Podemos aprovechar este comportamiento para crear un c√≥digo m√°s flexible y adaptable.\nConclusi√≥n #El uso de tipos de funciones en el desarrollo de iOS nos proporciona un mecanismo poderoso para crear c√≥digo modular y flexible. Al tratar las funciones como ciudadanos de primera clase, podemos pasarlas como par√°metros a otras funciones, usarlas como tipos de retorno y generarlas din√°micamente cuando sea necesario. Este enfoque mejora la reutilizaci√≥n del c√≥digo, promueve la modularidad y permite la creaci√≥n de funciones de orden superior. Al aprovechar estas capacidades, los desarrolladores pueden construir aplicaciones iOS robustas y adaptables. As√≠ que, la pr√≥xima vez que te encuentres en una situaci√≥n donde necesites incorporar diferentes comportamientos en tu c√≥digo, considera usar tipos de funciones para una soluci√≥n m√°s elegante.\n","date":"10 julio 2023","permalink":"/es/blog/uso-funciones-swift/","section":"Blog","summary":"Como las funciones son ciudadanos de primera clase en Swift, puedes aprovechar sus beneficios","title":"Usando funciones en Swift"},{"content":"Comprender las complejidades de las etiquetas de argumentos de funciones y los nombres de par√°metros es esencial para aprovechar al m√°ximo el lenguaje de programaci√≥n Swift. En este art√≠culo, exploraremos estos conceptos con un enfoque en la simplicidad, atendiendo a desarrolladores con experiencia limitada en la creaci√≥n de funciones. ¬°As√≠ que, comencemos!\nEtiquetas de argumentos de funci√≥n #Las etiquetas de argumentos proporcionan un contexto descriptivo al llamar a una funci√≥n, haciendo que el c√≥digo sea m√°s expresivo y legible. En Swift, las etiquetas de argumentos se especifican antes de los nombres de par√°metros y est√°n separadas por un espacio. Consideremos un ejemplo donde calculamos la puntuaci√≥n de un nivel de videojuego:\nfunc calculateScore(forLevel level: Int) -\u0026gt; Int { // Function body goes here } Aqu√≠, forLevel es la etiqueta del argumento, y level es el nombre del par√°metro. Al llamar a esta funci√≥n, usamos la etiqueta del argumento para proporcionar claridad:\nlet finalScore = calculateScore(forLevel: 5) Al usar etiquetas de argumentos, podemos transmitir el prop√≥sito de cada par√°metro, mejorando la comprensi√≥n de nuestro c√≥digo.\nAdem√°s, puedes omitir una etiqueta de argumento. Simplemente debes escribir un guion bajo en lugar de una etiqueta de argumento:\nfunc addStamina(_ stamina: Int) -\u0026gt; Int { // Function body goes here } Y solo necesitar√°s pasar el valor cuando llames a la funci√≥n.\nlet totalStamina = addStamina(100) Valores de par√°metros predeterminados #En Swift, tenemos la flexibilidad de asignar valores predeterminados a los par√°metros de funciones. Esto significa que al llamar a una funci√≥n, podemos optar por omitir argumentos espec√≠ficos, y en su lugar se utilizar√°n los valores predeterminados. Continuando con nuestro tema de videojuegos, modifiquemos nuestra funci√≥n anterior para incluir un valor predeterminado para el par√°metro bonusPoints:\nfunc calculateScore(level: Int, bonusPoints: Int = 500) -\u0026gt; Int { return level * bonusPoints } Ahora, podemos llamar a la funci√≥n y usar los dos par√°metros pero, si llamamos a la funci√≥n sin proporcionar un valor para bonusPoints, autom√°ticamente se utilizar√° el valor predeterminado de 500:\nlet totalScore = calculateScore(level: 2, bonusPoints: 100) // totalScore is equal to 200 let finalScore = calculateScore(level: 5) // finalScore is equal to 2500 Par√°metros vari√°dicos #A veces, podemos encontrarnos con situaciones donde el n√∫mero de argumentos de la funci√≥n no es fijo. Para manejar tales escenarios, Swift nos permite usar par√°metros vari√°dicos. Estos par√°metros pueden aceptar cero o m√°s valores de un tipo especificado. Para demostrarlo, imagina una funci√≥n que calcula la puntuaci√≥n total de varios videojuegos:\nfunc calculateTotalScore(scores: Int...) -\u0026gt; Int { // Function body goes here } Aqu√≠, scores es un par√°metro vari√°dico. Podemos pasar cualquier n√∫mero de argumentos separados por comas al llamar a la funci√≥n:\nlet totalScore = calculateTotalScore(scores: 100, 250, 500, 750) Par√°metros de entrada-salida #Por √∫ltimo, Swift proporciona el modificador de par√°metro in-out, que permite a una funci√≥n modificar el valor de una variable desde fuera de su propio √°mbito. Los par√°metros de entrada-salida se prefijan con la palabra clave \u0026ldquo;inout\u0026rdquo;. Considera un escenario donde necesitamos actualizar los puntos de salud de un personaje de juego:\nfunc updateHealthPoints(_ hp: inout Int) { // Function body goes here } Para pasar una variable como un par√°metro in-out, antecedemos un ampersand antes del nombre de la variable:\nvar characterHP = 100 updateHealthPoints(\u0026amp;characterHP) Conclusi√≥n #En este art√≠culo, hemos cubierto los fundamentos de las etiquetas de argumentos de funciones y los nombres de par√°metros en Swift. Exploramos el uso de etiquetas de argumentos, valores de par√°metros predeterminados, par√°metros variadicos y par√°metros de in-out. Al dominar estos conceptos, podr√°s escribir c√≥digo limpio, expresivo y flexible en tus proyectos de iOS. Sigue practicando e incorporando estas t√©cnicas en tu viaje de desarrollo, y pronto podr√≠as estar creando videojuegos retro notables que dejen a los jugadores nost√°lgicos por la edad de oro de los videojuegos.\n","date":"26 junio 2023","permalink":"/es/blog/etiquetas-argumentos-funcion-parametros/","section":"Blog","summary":"Descubriendo las bases sobre par√°metros de entrada en las funciones","title":"Etiquetas de argumentos de funci√≥n y nombres de par√°metros"},{"content":"Como desarrolladores de iOS, a menudo nos encontramos con escenarios donde necesitamos devolver m√∫ltiples valores de una funci√≥n. Swift nos ofrece dos enfoques √∫tiles para lograr esto: utilizando tuplas y colecciones. En este art√≠culo, exploraremos ambos m√©todos y entenderemos cu√°ndo usar cada uno.\nUsando Tuplas #Las tuplas son estructuras de datos ligeras que nos permiten agrupar m√∫ltiples valores juntos. Proporcionan una forma sencilla de devolver m√∫ltiples valores de una funci√≥n. Considera el siguiente ejemplo:\nfunc getMovieDetails(movieId: Int) -\u0026gt; (String, String) { // Retrieve movie details from the database let movieTitle = \u0026#34;Back to the Future\u0026#34; let director = \u0026#34;Robert Zemeckis\u0026#34; return (movieTitle, director) } let movieDetails = getMovieDetails(movieId: 1) print(\u0026#34;Title: \\(movieDetails.0)\u0026#34;) print(\u0026#34;Director: \\(movieDetails.2)\u0026#34;) En este ejemplo, la funci√≥n getMovieDetails devuelve una tupla que contiene el t√≠tulo de la pel√≠cula y el director. Podemos acceder a valores individuales usando la sintaxis de punto y el √≠ndice correspondiente. Las tuplas son √∫tiles cuando tenemos un n√∫mero fijo de valores para devolver.\nUsando colecciones #Las colecciones, como arrays o diccionarios, ofrecen un enfoque m√°s flexible para devolver m√∫ltiples valores. Veamos c√≥mo podemos modificar nuestro ejemplo anterior para utilizar un array:\nfunc getMovieDetails(movieId: Int) -\u0026gt; [String] { // Retrieve movie details from the database let movieTitle = \u0026#34;Back to the Future\u0026#34; let releaseYear = 1985 let director = \u0026#34;Robert Zemeckis\u0026#34; return [movieTitle, String(releaseYear), director] } let movieDetails = getMovieDetails(movieId: 1) print(\u0026#34;Title: \\(movieDetails[0])\u0026#34;) print(\u0026#34;Release Year: \\(movieDetails[1])\u0026#34;) print(\u0026#34;Director: \\(movieDetails[2])\u0026#34;) Aqu√≠, la funci√≥n getMovieDetails devuelve un array de strings, conteniendo el t√≠tulo de la pel√≠cula, el a√±o de lanzamiento (convertido a string) y el director. Accedemos a los valores por sus respectivos √≠ndices. Las colecciones son ventajosas cuando tenemos un n√∫mero variable de valores para devolver o si el n√∫mero de valores puede cambiar en el futuro.\nElegir entre Tuplas y Colecciones #Al decidir entre tuplas y colecciones, considera las siguientes pautas:\nUsa tuplas cuando tengas un n√∫mero fijo de valores que no cambiar√°. Usa colecciones cuando el n√∫mero de valores pueda variar o cuando necesites agregar o eliminar valores f√°cilmente. Conclusi√≥n #Devolver m√∫ltiples valores de una funci√≥n en Swift es esencial en muchos escenarios de programaci√≥n. Al utilizar tuplas o colecciones, podemos manejar eficientemente estas situaciones. Las tuplas son adecuadas para devolver un n√∫mero fijo de valores, mientras que las colecciones ofrecen flexibilidad cuando el n√∫mero de valores puede variar. Entender estas t√©cnicas nos empodera para escribir un c√≥digo m√°s limpio y expresivo.\nRecuerda experimentar con estos conceptos usando ejemplos del mundo real y explorar c√≥mo pueden ser aplicados a tus propios proyectos.\n","date":"12 junio 2023","permalink":"/es/blog/devolviendo-multiples-valores-desde-funciones/","section":"Blog","summary":"Aprende como puedes devolver multiples valores desde una funci√≥n","title":"Devolviendo m√∫ltiples valores desde una funci√≥n: Tuplas vs. Colecciones"},{"content":"Como desarrollador, es esencial entender los conceptos fundamentales de la programaci√≥n. Uno de esos conceptos es las funciones, las cuales desempe√±an un papel crucial en la organizaci√≥n y reutilizaci√≥n del c√≥digo. En este art√≠culo, exploraremos los conceptos b√°sicos de las funciones en Swift. Ya seas un principiante o est√©s buscando una revisi√≥n, esta gu√≠a te ayudar√° a comprender los aspectos esenciales de las funciones de manera simple y directa.\n¬øQu√© son las Funciones? #Una funci√≥n es un bloque de c√≥digo que realiza una tarea espec√≠fica. Te permite encapsular un conjunto de instrucciones bajo un nombre significativo, haciendo que tu c√≥digo sea m√°s organizado y modular. Las funciones pueden aceptar valores de entrada, llamados par√°metros, y devolver valores de salida. Proporcionan una forma de descomponer la l√≥gica compleja en partes m√°s peque√±as y manejables.\nSintaxis y Estructura: #En Swift, la declaraci√≥n de una funci√≥n comienza con la palabra clave func, seguida del nombre de la funci√≥n y par√©ntesis. Si la funci√≥n acepta par√°metros, se especifican dentro de los par√©ntesis. El tipo de retorno se indica con una flecha -\u0026gt; seguida del tipo. Aqu√≠ tienes un ejemplo:\nfunc greet(name: String) -\u0026gt; String { return \u0026#34;Hello, \\(name)!\u0026#34; } En este ejemplo, tenemos una funci√≥n llamada greet que acepta un par√°metro llamado name de tipo String. Devuelve un valor String que contiene un mensaje de saludo con el nombre proporcionado.\nEscenario de ejemplo #Imaginemos que estamos construyendo una aplicaci√≥n relacionada con programas de televisi√≥n. Podemos crear una funci√≥n para recomendar un programa en funci√≥n de las preferencias del usuario. Aqu√≠ tienes un ejemplo:\nfunc recommendShow(userPreference: String) -\u0026gt; String { if userPreference == \u0026#34;action\u0026#34; { return \u0026#34;You should watch \u0026#39;Game of Thrones\u0026#39;!\u0026#34; } else if userPreference == \u0026#34;comedy\u0026#34; { return \u0026#34;I recommend \u0026#39;Friends\u0026#39;!\u0026#34; } else { return \u0026#34;I\u0026#39;m sorry, I don\u0026#39;t have a recommendation for your preference.\u0026#34; } } Cuando llamas a esta funci√≥n con diferentes preferencias, como \u0026ldquo;acci√≥n\u0026rdquo; o \u0026ldquo;comedia\u0026rdquo;, devolver√° una recomendaci√≥n apropiada. Si la preferencia del usuario no coincide con ning√∫n caso espec√≠fico, se devuelve un mensaje predeterminado.\nCu√°ndo Usar Funciones #Las funciones son particularmente √∫tiles en los siguientes escenarios:\nReusabilidad #Si te encuentras realizando la misma tarea o c√°lculo en m√∫ltiples lugares de tu c√≥digo, es una buena indicaci√≥n para crear una funci√≥n para esa tarea. De esta manera, puedes reutilizar el c√≥digo sin duplicarlo.\nModularidad #Las funciones ayudan a organizar el c√≥digo en unidades m√°s peque√±as y autocontenidas. Esto mejora la legibilidad y mantenibilidad del c√≥digo.\nAbstracci√≥n #Al encapsular la l√≥gica compleja dentro de las funciones, puedes abstraer los detalles de implementaci√≥n y centrarte en la funcionalidad de nivel superior.\nConclusi√≥n #Comprender los conceptos b√°sicos de las funciones es esencial para cualquier desarrollador. Te permiten escribir c√≥digo limpio y reutilizable, y mejorar la estructura de tus programas. En este art√≠culo, exploramos la sintaxis y la estructura de las funciones en Swift, junto con un escenario de ejemplo utilizando las preferencias de programas de televisi√≥n. Al aprovechar las funciones de manera efectiva, puedes crear un c√≥digo m√°s modular y mantenible.\n","date":"29 mayo 2023","permalink":"/es/blog/entendiendo-basico-funciones/","section":"Blog","summary":"Las funciones nos permiten organizar el c√≥dgo, reusarlo y evitar duplicados","title":"Entendiendo lo b√°sico de las funciones en Swift"},{"content":"En Swift, hay varios constructores del lenguaje que hacen la programaci√≥n m√°s eficiente y robusta.\nUno de estos constructores es la declaraci√≥n defer, que permite a los desarrolladores ejecutar un bloque de c√≥digo m√°s tarde en el flujo del programa. Este art√≠culo tiene como objetivo explicar c√≥mo funciona defer en Swift, proporcionar ejemplos de su uso y destacar los escenarios en los cuales puede ser beneficioso.\nSe utiliza para definir un bloque de c√≥digo que se ejecuta cuando se sale del √°mbito actual, independientemente de c√≥mo se salga del √°mbito, ya sea mediante una declaraci√≥n de retorno, un error o un break. Ten en cuenta que, en caso de que tu aplicaci√≥n deje de funcionar debido a un error en tiempo de ejecuci√≥n, el c√≥digo diferido no se ejecuta.\nAsegura que se ejecute un c√≥digo de limpieza o finalizaci√≥n espec√≠fico antes de salir del √°mbito, independientemente del camino de ejecuci√≥n.\nSintaxis de defer #La sintaxis es simple. Comienzas con la palabra clave defer seguido por el bloque de c√≥digo que quieres ejecutar m√°s tarde. Aqu√≠ un ejemplo:\nfunc processFile() { print(\u0026#34;Opening file...\u0026#34;) defer { print(\u0026#34;Closing file...\u0026#34;) } // Code for processing the file goes here // This code will be executed before the file is closed } En este ejemplo, el mensaje Opening file... se imprime primero, y luego se define el bloque defer.\nEl bloque defer contiene el c√≥digo que se ejecutar√° al final, justo antes de salir del √°mbito. En este caso, el mensaje Closing file... siempre se imprimir√°, asegurando que el archivo se cierre correctamente.\nCasos de uso de defer #defer es particularmente √∫til en escenarios donde necesitas asegurarte de que los recursos sean liberados correctamente o que se realicen acciones independientemente del camino de ejecuci√≥n. Algunos casos de uso comunes incluyen:\nLimpieza de recursos #Cuando trabajas con archivos, bases de datos o conexiones de red, puedes usar defer para asegurar que los recursos se liberen, las conexiones se cierren o las transacciones se confirmen.\nLiberaci√≥n de bloqueos #Si haces uso de un bloqueo o un sem√°foro, la declaraci√≥n defer puede ayudar a liberarlo incluso si ocurre una excepci√≥n o si el bloque de c√≥digo se sale de la ejecuci√≥n antes de tiempo.\nRestauraci√≥n de estado #En flujos de trabajo complejos o operaciones as√≠ncronas, puedes usar la declaraci√≥n defer para restaurar el estado a una condici√≥n consistente o inicial antes de salir del √°mbito.\nRegistro y depuraci√≥n #defer se puede emplear para registrar o informar informaci√≥n con fines de depuraci√≥n antes de salir del √°mbito actual.\nConclusi√≥n #defer en Swift es un constructo del lenguaje poderoso que permite a los desarrolladores diferir la ejecuci√≥n de c√≥digo hasta el final de un √°mbito. Asegura que se ejecute un c√≥digo espec√≠fico de limpieza o finalizaci√≥n, independientemente de c√≥mo se salga del √°mbito.\nAl aprovechar la declaraci√≥n defer, los desarrolladores podemos escribir c√≥digo m√°s resiliente y organizado, facilitando la gesti√≥n de la limpieza de recursos y asegurando el comportamiento deseado en varios escenarios.\nRecuerda, la declaraci√≥n defer puede ser particularmente √∫til cuando trabajas con recursos, bloqueos, gesti√≥n de estado y depuraci√≥n.\n","date":"15 mayo 2023","permalink":"/es/blog/descubriendo-defer-swift/","section":"Blog","summary":"Ejecuta un bloque de c√≥digo al finalizar un flujo del programa","title":"Descubriendo defer en Swift"},{"content":"En la programaci√≥n iOS, una construcci√≥n poderosa que ayuda a mejorar la legibilidad del c√≥digo y a mejorar el flujo de control es la sentencia guard. Esta declaraci√≥n act√∫a como un guardi√°n, permiti√©ndonos manejar de manera elegante los escenarios excepcionales y salir temprano de un bloque de c√≥digo.\nEn este art√≠culo, descubrir√°s los beneficios de la sentencia guard, explorar√°s su uso y proporcionar√°s ejemplos para ilustrar su efectividad.\nEntendiendo la sentencia guard #La sentencia guard sirve como un mecanismo de salida anticipada condicional en Swift, el lenguaje de programaci√≥n para el desarrollo de iOS.\nPermite verificar condiciones espec√≠ficas y asegurar que se cumplan antes de continuar con la ejecuci√≥n de un bloque de c√≥digo.\nSi las condiciones no se cumplen, la sentencia guard termina el √°mbito actual, permiti√©ndonos manejar los escenarios de fallo de manera elegante.\nLa sintaxis para una sentencia guard es la siguiente:\nguard condition else { // Code to handle the failure case // Return, throw, or perform any necessary cleanup } // Code to execute when the condition is successfully met Cuando se encuentra una sentencia guard, se eval√∫a la condici√≥n especificada.\nSi la condici√≥n se eval√∫a como falsa, se ejecuta el c√≥digo dentro del bloque else.\nEste bloque t√≠picamente contiene c√≥digo para manejar el caso de fallo, como retornar de la funci√≥n, lanzar un error, o realizar cualquier limpieza necesaria. Si la condici√≥n se eval√∫a como verdadera, el c√≥digo contin√∫a ejecut√°ndose normalmente despu√©s de guard.\nSalida anticipada para condiciones inaceptables #Las sentencias guard pueden ayudar a evitar declaraciones condicionales anidadas proporcionando salidas tempranas para condiciones que se consideran inaceptables. Esto simplifica el c√≥digo y mejora la legibilidad. Por ejemplo:\nlet amount = 500 let accountBalance = 1000 guard amount \u0026lt;= accountBalance else { print(\u0026#34;Insufficient funds!\u0026#34;) return } // Perform payment operation Otros casos de uso #Hay otros casos de uso para guard, espec√≠ficamente relacionados con los Opcionales y el manejo de errores. Sin embargo, dado que estos son temas m√°s avanzados, en mi opini√≥n, es mejor solo mencionarlos ahora y explorarlos en detalle en publicaciones avanzadas futuras.\nValidaci√≥n de entradas #La sentencia guard se utiliza a menudo para validar los par√°metros de entrada, asegurando que cumplan con ciertos requisitos antes de proceder. Este caso se utiliza manejando opcionales.\nDesasignaci√≥n de recursos #En este caso, guard es √∫til al tratar con recursos que requieren limpieza. Asegura que el c√≥digo de limpieza se ejecute siempre que se encuentre una condici√≥n de fallo.\nConclusi√≥n #La sentencia guard es una herramienta poderosa en la programaci√≥n de iOS que permite un c√≥digo limpio, conciso y eficiente. Proporciona una manera elegante de manejar escenarios de fallo y salir graciosamente de un bloque de c√≥digo cuando ciertas condiciones no se cumplen.\nAl usar la sentencia guard de manera efectiva, puedes mejorar la legibilidad y mantenibilidad de tu c√≥digo.\nAdopta esta construcci√≥n en tus proyectos y disfruta de los beneficios de un proceso de desarrollo m√°s eficiente.\n","date":"2 mayo 2023","permalink":"/es/blog/guard-salida-anticipada-swift/","section":"Blog","summary":"Saliendo antes de tiempo en un bloque de c√≥digo","title":"Entendiendo la sentencia guard para una salida anticipiada"},{"content":"Las sentencias de traspaso de control son herramientas esenciales en programaci√≥n que te permiten alterar el flujo de ejecuci√≥n dentro de tu c√≥digo.\nEn Swift, tres sentencias de traspaso de control de uso com√∫n son continue, break, y fallthrough.\nEn este art√≠culo, examinaremos cada una de estas sentencias, dando ejemplos y explicando los escenarios en los que es m√°s apropiado utilizarlas.\nContinue #continue se usa principalmente dentro de bucles (como for-in o while) para omitir el c√≥digo restante dentro de la iteraci√≥n actual y pasar a la siguiente. Te permite omitir selectivamente partes espec√≠ficas de un bucle sin terminarlo por completo. Aqu√≠ un ejemplo para ilustrar su uso:\nfor number in 1...10 { if number % 2 == 0 { continue } print(number) } Resultado\n1 3 5 7 9 En este ejemplo, la instrucci√≥n continue se utiliza para omitir la impresi√≥n de n√∫meros pares. Cuando la condici√≥n number % 2 == 0 es verdadera, se ejecuta la instrucci√≥n continue, omitiendo la instrucci√≥n print y pasando a la siguiente iteraci√≥n.\nBreak #break se utiliza para finalizar prematuramente la ejecuci√≥n de un bucle o una sentencia de cambio. Te permite salir de un bucle o bloque switch antes de llegar a su final natural.\nF√±ijate el siguiente ejemplo:\nlet cars = [‚ÄúRed Bull\u0026#34;, ‚ÄúAston Martin\u0026#34;, ‚ÄúFerrari\u0026#34;, \u0026#34;Mercedes\u0026#34;, \u0026#34;McClaren\u0026#34;] for name in names { if name == \u0026#34;Mercedes\u0026#34; { break } print(name) } Resultado\nRed Bull Aston Martin Ferrari En este caso, la sentencia break se utiliza para salir del bucle una vez que la condici√≥n name == \u0026quot;Mercedes\u0026quot; es verdadera. Como resultado, el bucle termina antes de tiempo y los elementos restantes del array cars no se imprimen.\nFallthrough #fallthrough se usa exclusivamente dentro de las sentencias de cambio. Permite que el flujo de control pase al siguiente caso sin realizar una \u0026ldquo;interrupci√≥n\u0026rdquo; impl√≠cita.\nEste comportamiento es distinto del comportamiento predeterminado de un switch, donde el control de la ejecuci√≥n sale autom√°ticamente del bloque despu√©s de que coincida un caso.\nVeamos el siguiente ejemplo:\nlet grade = \u0026#34;A\u0026#34; switch grade { case \u0026#34;A\u0026#34;: print(\u0026#34;Excellent\u0026#34;) fallthrough case \u0026#34;B\u0026#34;: print(‚ÄúYou have approved\u0026#34;) case \u0026#34;C\u0026#34;: print(\u0026#34;Average\u0026#34;) default: print(\u0026#34;Incomplete\u0026#34;) } Resultado\nExcellent Good En este ejemplo, cuando la calificaci√≥n es A, la instrucci√≥n fallthrough se utiliza para continuar la ejecuci√≥n al siguiente caso sin salir del bloque de cambio. Como resultado, se imprimir√°n Excellent y You have approved.\nConclusi√≥n #Entender las sentencias de traspaso de control como continue, break, and fallthrough es crucial para una programaci√≥n en Swift eficaz.\ncontinue te permite omitir iteraciones espec√≠ficas dentro de los bucles, break resultar√° en la terminaci√≥n prematura de bucles o switches, y fallthrough har√° que el control fluya al siguiente caso en un switch.\nAl aprovechar estas sentencias de manera adecuada, puedes mejorar la flexibilidad y el control de la ejecuci√≥n de tu c√≥digo desarrollando iOS.\n","date":"17 abril 2023","permalink":"/es/blog/sentencias-transpaso-control-swift/","section":"Blog","summary":"Alterar el flujo de control dentro del c√≥digo","title":"Explorando las sentencias de traspaso de control en Swift"},{"content":"Comprender las bases de la programaci√≥n Swift es crucial para crear aplicaciones s√≥lidas y eficientes.\nUno de los conceptos clave que debes comprender son las sentencias condicionales. En este art√≠culo, navegaremos hacia el mundo de los condicionales en Swift, explorando su sintaxis, ejemplos y mejores pr√°cticas para usarlas de manera efectiva. ¬°A ello!\nSentencias condicionales: Tomando decisiones en Swift #En programaci√≥n, a menudo hay situaciones en las que necesitas que tu aplicaci√≥n tome decisiones basadas en ciertas condiciones. Aqu√≠ es donde entran en juego las se condicionales, que le permiten ejecutar bloques de c√≥digo espec√≠ficos dependiendo de si una condici√≥n se eval√∫a como verdadera o falsa.\nSwift ofrece tres sentencias condicionales principales: sentencias if, sentencias if-else y sentencias switch.\nCada sentencia tiene un prop√≥sito distinto, y comprender cu√°ndo usar cada una es esencial para escribir c√≥digo limpio y f√°cil de mantener.\nLa sentencia if #La sentencia if es la forma m√°s simple de sentencia condicional en Swift. Te permite ejecutar un bloque de c√≥digo solo si una condici√≥n espec√≠fica es verdadera.\nPor ejemplo, digamos que quieres mostrar un mensaje si la edad de un usuario es mayor o igual a 18 a√±os:\nlet userAge = 20 if userAge \u0026gt;= 18 { print(\u0026#34;Welcome! You can access.\u0026#34;) } } ```swift ### La sentencia `if`-`else` La sentencia `if`-`else` ampl√≠a la sentencia `if` al facilitar un bloque de c√≥digo alternativo para ejecutar cuando la condici√≥n que se eval√∫a resulta falsa. Considera el siguiente ejemplo que verifica si un n√∫mero es positivo o negativo: ```swift let number = -5 if number \u0026gt; 0 { print(\u0026#34;The number is positive.\u0026#34;) } else { print(\u0026#34;The number is negative.\u0026#34;) } ```swift ### La sentencia `switch` La sentencia `switch` ofrece una forma m√°s concisa de manejar m√∫ltiples condiciones posibles. Eval√∫a un valor determinado frente a varios casos y ejecuta el bloque de c√≥digo asociado con el primer caso coincidente. Supongamos que quieres mostrar un mensaje seg√∫n el rol de un usuario: ```swift let userRole = \u0026#34;admin\u0026#34; switch userRole { case \u0026#34;admin\u0026#34;: print(\u0026#34;Welcome, administrator!\u0026#34;) case \u0026#34;user\u0026#34;: print(\u0026#34;Welcome, user!\u0026#34;) default: print(\u0026#34;Unknown role.\u0026#34;) } ```swift ## Mejores pr√°cticas para utilizar condicionales: ### Mantenlo simple Trata de escribir c√≥digo conciso y legible. Evita condiciones anidadas complejas que puedan dificultar la comprensi√≥n y el mantenimiento del c√≥digo. ### Utiliza los operadores oportunos Swift proporciona una variedad de operadores l√≥gicos y de comparaci√≥n, como `\u0026lt;`, `\u0026gt;`, `==`, `\u0026amp;\u0026amp;`, `||`, para construir condiciones m√°s complejas. ### Planifica todas las posibilidades Aseg√∫rate de tener en cuenta todos los escenarios posibles en tus sentencias condicionales. El caso `default` en `switch` act√∫a como un comod√≠n para el resto de condiciones que no hayas tenido en cuenta. ### Prueba tu c√≥digo Valida tus condicionales con diferentes entradas para asegurarte de que se comporten como esperas. Las pruebas unitarias son una pr√°ctica muy valiosa para identificar y solucionar cualquier problema desde el principio. ## Conclusi√≥n Las sentencias condicionales son herramientas imprescindibles para el desarrollo con Swift, ya que te permiten tomar decisiones y controlar el flujo de tu c√≥digo en funci√≥n de situaciones espec√≠ficas. Al dominar las sentencias `if`, `if`-`else` y `switch`, obtendr√°s la capacidad de crear aplicaciones din√°micas y personalizadas. Recuerda utilizar estas sentencias con prudencia, manteniendo tu c√≥digo limpio y comprensible. üòâ ","date":"3 abril 2023","permalink":"/es/blog/sentencias-condicionales-swift/","section":"Blog","summary":"Controlando el comportamiento de la aplicaci√≥n bas√°ndose en condiciones","title":"Condicionales como base de Swift"},{"content":"En el desarrollo de iOS, las sentencias de control de flujo juegan un papel crucial en dirigir la ejecuci√≥n del c√≥digo.\nPermiten a los desarrolladores iterar sobre colecciones, realizar tareas repetitivas y controlar el comportamiento del programa basado en ciertas condiciones. En esta publicaci√≥n, nos sumergiremos en tres sentencias de control de flujo esenciales en Swift: for-in, while, y repeat-while.\nYa seas un desarrollador iOS junior o alguien que busca refrescar su conocimiento, entender estas sentencias es esencial para construir aplicaciones iOS robustas y eficientes.\nBucles for-in: Simplificando la iteraci√≥n #El bucle for-in es particularmente √∫til cuando quieres iterar sobre una colecci√≥n de elementos, como un array o un diccionario. Simplifica el proceso de acceder a cada elemento sin la necesidad de indexaci√≥n manual. Veamos un ejemplo:\nlet books = [‚ÄúA Game of Thrones‚Äù, ‚ÄúA Clash of Kings‚Äù, ‚ÄúA Storm of Swords‚Äù, ‚ÄùA Feast for Crows‚Äù, ‚ÄúA Dance with Dragons‚Äù] for book in books { print(book) } En este ejemplo, el bucle for-in itera sobre cada elemento en el array de libros e imprime su t√≠tulo. El bucle asigna autom√°ticamente cada elemento a la constante libro, permiti√©ndote realizar operaciones sobre √©l dentro del √°mbito del bucle.\nEste bucle es ideal para escenarios tales como:\nEnumerar a trav√©s de un array para realizar operaciones en cada elemento. Iterar sobre un diccionario para acceder tanto a las llaves como a los valores. Iterar sobre un rango de n√∫meros o caracteres. Bucles while: Ejecutando c√≥digo condicionalmente #El bucle while ejecuta un bloque de c√≥digo repetidamente mientras una condici√≥n dada permanezca verdadera. Esto es particularmente √∫til cuando no conoces el n√∫mero exacto de iteraciones de antemano. Aqu√≠ hay un ejemplo para ilustrar su uso:\nvar count = 0 while count \u0026lt; 5 { print(\u0026#34;Count: \\(count)\u0026#34;) count += 1 } En este ejemplo, el bucle while seguir√° ejecut√°ndose mientras la variable count sea menor que 5. Imprime el valor actual de count y lo incrementa en 1 en cada iteraci√≥n. Ten cuidado al usar bucles while para asegurarte de que la condici√≥n eventualmente se vuelva falsa; de lo contrario, puede resultar en un bucle infinito.\nConsidera usar el bucle while en las siguientes situaciones:\nRealizar repetidamente una acci√≥n hasta que se cumpla una condici√≥n espec√≠fica. Implementar validaci√≥n de entrada y pedir continuamente la entrada del usuario hasta que se proporcione datos v√°lidos. Interactuar con sistemas o procesos externos que requieren monitoreo continuo. Bucle repeat-while: Asegurando la primera ejecuci√≥n del c√≥digo #El bucle repeat-while es similar al bucle while, pero con una diferencia crucial: la condici√≥n se eval√∫a al final del bucle. Esto garantiza que el bloque de c√≥digo se ejecute al menos una vez, incluso si la condici√≥n es inicialmente falsa. Aqu√≠ hay un ejemplo:\nvar number = 10 repeat { print(number) number -= 2 } while number \u0026gt; 0 En este ejemplo, el bucle repeat-while imprime el valor de number y le resta 2 hasta que number se convierte en 0 o menos. A diferencia del bucle while, el bucle repeat-while ejecuta el bloque de c√≥digo primero y luego verifica la condici√≥n.\nEs adecuado para escenarios como:\nImplementar sistemas basados en men√∫s donde quieres asegurar la ejecuci√≥n antes de verificar las elecciones del usuario. Manejar la l√≥gica de juegos donde una acci√≥n debe realizarse al menos una vez antes de verificar las condiciones de finalizaci√≥n del juego. Repetir una operaci√≥n hasta que se cumpla una condici√≥n espec√≠fica. Conclusi√≥n #Entender las sentencias de control de flujo como for-in, while y repeat-`while es fundamental para cualquier desarrollador de iOS.\nEstas sentencias te permiten controlar el flujo del programa, iterar sobre colecciones y ejecutar c√≥digo condicionalmente. Al dominar estas sentencias de control de flujo, tendr√°s la capacidad de construir aplicaciones iOS m√°s eficientes y din√°micas.\nUtiliza estas sentencias sabiamente, prestando atenci√≥n a las condiciones de terminaci√≥n de los bucles para evitar bucles infinitos. Sigue explorando sus capacidades y experimentando con diferentes escenarios para mejorar tus habilidades de programaci√≥n.\n","date":"20 marzo 2023","permalink":"/es/blog/bucles-swift/","section":"Blog","summary":"Iterando y realizando tareas repetitivas","title":"Explorando los bucles en Swift"},{"content":"Las colecciones son una de las estructuras de datos m√°s utilizadas cuando programas, por lo tanto, es extremadamente importante conocer los diferentes enfoques que dispones para trabajar con ellas.\nLos tipos de colecci√≥n son tipos de datos complejos, y Swift permite usar tres tipos de colecci√≥n: Arrays, Sets y Diccionarios para gestionar valores relacionados.\nLa fiabilidad de estas colecciones se basa en los tipos de valores y claves que puedes almacenar. Cuando creas una instancia de una colecci√≥n, necesitas confirmar el tipo de valores que gestiona. Esto significa que: no puedes almacenar diferentes tipos a los que definiste previamente, y puedes estar seguro del tipo de datos que recuperar√°s cuando manejas una colecci√≥n.\nAdem√°s, gracias a la inferencia de tipo, puedes especificar el tipo, o Swift inferir√° el tipo.\nMutabilidad de las colecciones #As√≠ como las variables y constantes, las colecciones pueden ser mutables o inmutables dependiendo de c√≥mo fueron creadas.\nSi almacenas un array, set o un diccionario en una variable, puedes mutar la colecci√≥n, porque puedes agregar, remover o cambiar un √∫nico o m√∫ltiples valores en estas colecciones.\nPero, si lo almacenas en una constante, no puedes a√±adir nuevos elementos o modificar los que fueron instanciados.\nDiferencias entre arrays, sets y diccionarios #Los arrays son colecciones ordenadas, donde las duplicaciones est√°n permitidas y los valores pueden ser accedidos por un √≠ndice num√©rico (posici√≥n en el array)\nLos sets son colecciones desordenadas donde las duplicaciones no est√°n permitidas, y los valores pueden ser iterados, pero no se pueden acceder por un √≠ndice o clave.\nLos diccionarios son colecciones desordenadas compuestas por asociaciones de clave-valor.\nFundamentos de los diferentes tipos de colecci√≥n #Arrays #Si quieres crear un array vac√≠o, necesitar√°s especificar el tipo de dato. Hay diferentes maneras de crear un array vac√≠o, este es un ejemplo.\nvar numbers = [Int]() Pero, si quieres crearlo con valores, no necesitas especificar los tipos. A continuaci√≥n, puedes ver c√≥mo crear un array de strings\nvar tutorials = [\u0026#34;SwiftUI\u0026#34;, \u0026#34;Combine\u0026#34;, \u0026#34;AsyncAwait\u0026#34;] Y, si necesitas acceder a un valor, debes indicar la posici√≥n del valor en el array. Pero, recuerda que el √≠ndice de las colecciones comienza por 0.\nlet firstCourse = tutorials[0] El c√≥digo anterior almacenar√° SwiftUI en la constante firstCourse.\nSets #Nuevamente, necesitar√°s especificar el tipo de dato para crear un set vac√≠o.\nvar numbers = Set\u0026lt;Int\u0026gt;() Crear un set con valores es similar a crear un array pero, en este caso, necesitar√°s especificar que es un set para no crear un array\nvar tutorials = [\u0026#34;SwiftUI\u0026#34;, \u0026#34;Combine\u0026#34;, \u0026#34;AsyncAwait\u0026#34;] Pero, en este caso, como los sets no tienen √≠ndice, no puedes usarlo para acceder a los datos. Al menos, puedes comprobar si el valor existe.\nvar swiftuiExists = tutorials.contains(\u0026#34;SwiftUI\u0026#34;) El c√≥digo anterior almacenar√° true en la variable swiftuiExists\nDiccionarios #Y, por √∫ltimo, puedes crear un diccionario vac√≠o especificando tanto el tipo de clave como el tipo de valor\nvar nameOfNumbers = [Int: String]() Para crear un diccionario con valores, tambi√©n es similar a un array, pero tienes que escribir la clave de cada valor. Recuerda que las claves deben ser √∫nicas.\nvar requirements = [\u0026#34;View\u0026#34;:\u0026#34;SwiftUI\u0026#34;, \u0026#34;Database\u0026#34;:\u0026#34;CoreData\u0026#34;, \u0026#34;AugmentedReality\u0026#34;:\u0026#34;ARKit\u0026#34;] Y, si quieres acceder a un valor, solo necesitas conocer el √≠ndice\nlet database = requirements[\u0026#34;Database\u0026#34;] En las pr√≥ximas publicaciones, escribir√© sobre m√©todos √∫tiles en tipos de colecci√≥n para gestionar arrays, sets y diccionarios.\n","date":"6 marzo 2023","permalink":"/es/blog/colecciones-swift/","section":"Blog","summary":"Swift tiene tres tipos de colecciones y su uso depende de c√≥mo quieres gestionar sus valores","title":"Colecciones en Swift"},{"content":"Esta publicaci√≥n es un complemento para la anterior sobre Cadenas en Swift.\nEn proyectos del mundo real, puedes almacenar muchas cadenas, pero es importante que sepas c√≥mo transformar esas cadenas para mostrarlas seg√∫n tu vista.\nPor esta raz√≥n, veamos los m√©todos habituales que puedes usar para esto.\nContar caracteres #Dado que una cadena es una colecci√≥n de caracteres, puedes usar un m√©todo muy com√∫n en Arrays: count()\nPuedes usarlo en una constante/variable o en una cadena.\nlet starWarsIntro = \u0026#34;A long time ago...\u0026#34; let numberOfCharacters = starWarsIntro.count() // numberOfCharacters value 18 let numberOfCharactersOfGreet = \u0026#34;Hello World!\u0026#34;.count() // numberOfCharactersOfGreet value is 12 Incluso puedes combinar valores en la misma cadena a trav√©s de la interpolaci√≥n de cadenas:\nlet plotTwist = \u0026#34;I am your father\u0026#34; print(\u0026#34;The number of character in \\(plotTwist) is \\(plotTwist).count()\u0026#34;) // It will print \u0026#34;The number of character in I am your father is 16\u0026#34; Insertar o eliminar #Tambi√©n es importante agregar o eliminar caracteres o subcadenas.\nInsertar #Para insertar, puedes:\nInsertar un car√°cter con el m√©todo .insert(_ newElement:at:) Insertar una subcadena con el m√©todo .insert(contentsOf:at:) En at, deber√°s escribir un √≠ndice. Puedes obtener m√°s informaci√≥n sobre los √≠ndices en Documentaci√≥n oficial de Swift - √çndices de cadenas\nvar warning = \u0026#34;we have a problem\u0026#34; warning.insert(contentsOf: \u0026#34;Houston, \u0026#34;, at: warning.startIndex) print(warning) // It will print \u0026#34;Houston, we have a problem\u0026#34; Eliminar #Similar a insertar, para eliminar Swift permite eliminar caracteres o subcadenas:\nEliminar un car√°cter con el m√©todo .remove(at:) Eliminar una subcadena con el m√©todo removeSubrange(_ bounds:) Ten cuidado de no salirte de los l√≠mites.\nvar greeting = \u0026#34;Hello World!\u0026#34; greeting.remove(at: greeting.index(before: greeting.endIndex)) print(greeting) // It will print \u0026#34;Hello World\u0026#34; Modificar cadenas #May√∫sculas y min√∫sculas #Los m√©todos que puedes usar para esto son .uppercased(), .lowercased() o .capitalized()\nEjemplos:\nlet lordOfTheRings = \u0026#34;A ring to rule them all\u0026#34; print(lordOfTheRings.uppercased()) // It will print \u0026#34;A RING TO RULE THEM ALL\u0026#34; print(lordOfTheRings.lowercased()) // It will print \u0026#34;a ring to rule them all\u0026#34; print(lordOfTheRings.capitalized) // It will print \u0026#34;A Ring To Rule Them All\u0026#34; Extraer una cadena a un array #Para este objetivo, puedes usar .components(separatedBy: \u0026quot; \u0026quot;)\nlet et = ‚ÄúE.T. phone home.‚Äù let etWords = et.components(separatedBy: \u0026#34; \u0026#34;) // etWords value is equal to [\u0026#34;E.T.\u0026#34;, \u0026#34;phone\u0026#34;, \u0026#34;home.\u0026#34;] Reemplazar ocurrencias #En este caso, un m√©todo √∫til es .replacingOccurrences(of:, with:), puedes reemplazar un car√°cter o una cadena con otro car√°cter o cadena\nlet darkKnight = \u0026#34;I am Batman\u0026#34; let coded = darkKnight.replacingOccurrences(of: \u0026#34;a\u0026#34;, with: \u0026#34;4\u0026#34;) // coded value is equal to \u0026#34;I 4m B4tm4n\u0026#34; ","date":"20 febrero 2023","permalink":"/es/blog/metodos-utiles-cadenas-swift/","section":"Blog","summary":"Aprende m√©todos √∫tiles para cadenas en Swift y muestra la informaci√≥n que necesites","title":"M√©todos √∫tiles para cadenas en Swift"},{"content":"Cuando guardas un texto en una constante o una variable, est√°s guardando una cadena en Swift. Adem√°s, puedes ver una cadena como una serie de caracteres. Por esa raz√≥n, puedes acceder al contenido de una cadena de varias maneras, como una Colecci√≥n (Array, por ejemplo) de caracteres.\nInicializar una Cadena #Un literal de cadena es un texto escrito con comillas dobles al principio y al final. Entonces, si necesitas guardar un texto en una constante o una variable, solo debes asignar un literal de cadena a ella.\nlet coach = \u0026#34;Ted Lasso\u0026#34; var team = \u0026#34;AFC Richmond\u0026#34; NOTA: Es fundamental recordar que las cadenas distinguen entre may√∫sculas y min√∫sculas. Por lo tanto, \u0026ldquo;una cadena simple\u0026rdquo; es diferente de \u0026ldquo;Una cadena simple\u0026rdquo;.\nConcatenando cadenas #Si necesitas guardar el valor de dos cadenas en otra constante o variable, puedes concatenarlas.\nEs tan f√°cil como usar el operador + entre los dos valores cuando tienes que asignarlo.\nlet name = \u0026#34;Michael\u0026#34; let lastName = \u0026#34;Scott\u0026#34; let funnyBoss = name + lastName Otra forma es usar el operador += para agregar texto a una cadena previamente inicializada.\nvar spy = \u0026#34;Bond\u0026#34; spy += \u0026#34;, James Bond\u0026#34; En el ejemplo anterior, el valor final de spy es Bond, James Bond\nY, como una String es una Colecci√≥n de caracteres, tambi√©n puedes usar el m√©todo .append()\nvar greet = \u0026#34;Hello, world\u0026#34; greet.append(\u0026#34;!\u0026#34;) En el √∫ltimo c√≥digo, el valor de saludo es Hello, world!\nInterpolaci√≥n de cadenas #Pero quiz√°s la caracter√≠stica m√°s utilizada en las cadenas podr√≠a ser la interpolaci√≥n de cadenas. Permite usar valores de constantes o variables dentro de una cadena.\nEn este caso, puedes hacerlo escribiendo el nombre de la constante o variable, dentro de par√©ntesis \u0026ldquo;()\u0026rdquo;, y comenzando con una barra invertida \u0026ldquo;\u0026quot;. Es decir, \\(nombreDeVariable)\nlet name = \u0026#34;Forest\u0026#34; let fullName = \u0026#34;Forest Gump\u0026#34; let introduction = \u0026#34;Hello, I am \\(name), \\(fullName)\u0026#34; El valor final de introduction es \u0026quot;Hello, I am Forest, Forest Gump\u0026quot;\nCadena de varias l√≠neas #Para terminar (aunque no se utiliza a menudo en aplicaciones del mundo real), tal vez a veces necesites guardar textos m√°s largos en una cadena, y podr√≠a ser dif√≠cil leer el valor para otros programadores o para ti mismo. En este caso, puedes usar una cadena de varias l√≠neas.\nPara guardar una cadena de varias l√≠neas, solo necesitas escribir tres comillas al principio, y terminar con otras tres en una sola l√≠nea. Por ejemplo:\nlet text = \u0026#34;\u0026#34;\u0026#34; To be, or not to be, that is the question: Whether \u0026#39;tis nobler in the mind to suffer The slings and arrows of outrageous fortune, Or to take arms against a sea of troubles, And by opposing end them? To die, to sleep; \u0026#34;\u0026#34;\u0026#34; First triple double quotes doesn\u0026rsquo;t need to be in a single line, but it helps to focus in text value.\nEl primer conjunto de tres comillas dobles no necesita estar en una sola l√≠nea, pero ayuda a centrarse en el valor del texto. Puedes ver m√©todos √∫tiles en la publicaci√≥n. M√©todos √∫tiles para cadenas\n","date":"6 febrero 2023","permalink":"/es/blog/cadenas-swift/","section":"Blog","summary":"Como en otros lenguajes, las cadenas son un tipo b√°sico que permite guardar texto","title":"Cadenas en Swift"},{"content":"La programaci√≥n ha sido utilizada a menudo para procesar n√∫meros y obtener resultados dif√≠ciles de calcular para los humanos: distancias del universo, radios de planetas, pi\u0026hellip;\nAs√≠, es parte del aprendizaje fundamental, en Swift en particular y en programaci√≥n en general.\nB√°sicamente hay 2 tipos de n√∫meros en Swift: Enteros y n√∫meros de coma flotante. Cada uno representa un rango diferente y se utiliza para diferentes objetivos.\nEnteros #Un n√∫mero entero (tambi√©n llamado int, abreviado) es posiblemente el n√∫mero m√°s utilizado. Podr√≠amos decir que es el m√°s simple, porque no tiene componente fraccional.\nPuede ser positivo, cero o negativo. Por ejemplo, n√∫meros enteros son: 5, -3, 99, -256\u0026hellip;\nAdem√°s, Swift proporciona enteros con signo y sin signo para 8,16, 32 y 64 bits. Siguiendo la convenci√≥n de nombres de C, el tipo de n√∫mero sin signo de 8 bits es UInt8, mientras que el de 16 bits con signo es Int16. Pero, no se utiliza frecuentemente en la mayor√≠a de las aplicaciones desarrolladas.\nRango de enteros #Depende del n√∫mero de bits, pero cada uno tiene un n√∫mero m√°ximo y m√≠nimo para almacenar. Puedes comprobarlo en la siguiente lista.\nUInt8: de 0 a 255 UInt16: de 0 a 65535 UInt32: de 0 a 4294967295 UInt64: de 0 a 18446744073709551615 Int8: de -128 a 127 Int16: de -32768 a 32767 Int32: de -2147483648 a 2147483647 Int64: de -9223372036854775808 a 9223372036854775807 Pero, si no recuerdas los valores, puedes usar los m√©todos .max o .min\nlet minValue = Int.min //minValue is equal to let maxValue = Int.max //maxValue is equal to N√∫meros de coma flotante #A diferencia de los enteros, los n√∫meros de coma flotante tienen un componente fraccional. Pero, al igual que los enteros, pueden ser positivos o negativos. Existen dos tipos de n√∫meros de punto flotante con signo\nDoble #Los n√∫meros Double representan un n√∫mero de punto flotante de 64 bits y tienen una precisi√≥n de al menos 15 d√≠gitos decimales.\nFlotante #Los n√∫meros Float representan un n√∫mero de punto flotante de 32 bits y tienen una precisi√≥n de al menos 6 d√≠gitos decimales.\nNOTA: Necesitar√°s Double o Float dependiendo de m√∫ltiples factores, pero si cualquiera de los dos fuera apropiado, la documentaci√≥n de Swift recomienda usar Double.\n","date":"30 enero 2023","permalink":"/es/blog/numeros-swift/","section":"Blog","summary":"Programar ha sido a menudo para procesar n√∫meros y obtener resultados demasiado dif√≠ciles de calcular por humanos","title":"N√∫meros en Swift"},{"content":"La programaci√≥n es una forma de gestionar datos y, normalmente, es necesario guardar varios valores temporalmente: para hacer uso de ellos despu√©s de otras operaciones, para mostrarlos, transformarlos\u0026hellip;\nPor este motivo, igual que otros lenguajes de programaci√≥n, Swift es capaz de almacenar valores en constantes y variables.\nGracias a ellas, puedes asociar un nombre que elijas a un valor.\nConstantes #Un valor constante se guarda en un espacio de memoria y no se puede modificar. Una vez que un valor se establece en una constante, permanece inmutable.\nC√≥mo declarar una constante #Para declarar una constante debes comenzar con la palabra reservada let, seguida del nombre que elijas. Luego, debes usar el operador = y asignar un valor.\nEn el siguiente ejemplo, let es la palabra reservada para constantes, survivor el nombre de la constante y el valor asignado a survivor es Jack Shepard.\nlet survivor = ‚ÄúJack Shepard‚Äù El valor est√° entre comillas dobles porque es un tipo de valor cadena o String. Puedes leer sobre Strings en la documentaci√≥n oficial: Cadenas y caracteres\n¬øSabes por qu√© Swift usa let en lugar de const o similar a otros idiomas? Viene del mundo de las matem√°ticas en ingl√©s, donde dicen cosas como:\nlet x be equal to 5.\nVariables #Una variable es un valor que puedes modificar una vez declarado. Por lo que es un valor mutable.\nC√≥mo declarar una variable #Para declarar una variable, la estructura es la misma que una constante, pero debes usar la palabra reservada var\nPor lo que, para declarar una variable debes escribir\nvar videogame = ‚ÄúMetal Gear Solid‚Äù Ok, pero si queremos cambiar el valor de var, ¬øc√≥mo deber√≠amos hacerlo? F√°cil, s√≥lo necesitas asignar un nuevo valor y no escribir la palabra reservada var.\nvideogame = ‚ÄúUncharted‚Äù Nombrar una constante, varialbe o valor #Puedes utilizar casi cualquier car√°cter para el nombre de una constante o variable, incluidos los caracteres Unicode. Lo que significa que puedes usar, por ejemplo, emojis.\nPero es algo que no recomiendo. ¬øPor qu√©? Porque el nombre de una constante o de una variable, debe explicar sin dejar lugar a dudas lo que se guarda en su interior.\nPor ejemplo, ¬øque significa el valor 10?\nlet times = 10 let numberOfTimesIHaveSeenBackToTheFutureTrilogy = 10 En el segundo caso caso es m√°s f√°cil saberlo.\nConclusi√≥n #Por lo tanto, no te preocupes por la cantidad de caracteres del nombre. Es m√°s recomendable utilizar un nombre grande (pero descriptivo) que utilizar otro m√°s corto que no especifique qu√© almacena. Y, hoy en d√≠a, los IDEs se encargan de autocompletar los nombres, as√≠ que no ser√° tan dif√≠cil escribirlos üòâ\n","date":"16 enero 2023","permalink":"/es/blog/constantes-variables-swift/","section":"Blog","summary":"Como guardar y gestionar valores de datos en Swift","title":"Constantes y variables para guardar datos"},{"content":"¬°Hola! Hoy estoy muy contento porque, he refactorizado mi blog üòâ\nEsta no es mi primera experiencia escribiendo en mi blog pero, 2022 fue un a√±o con cambios y nuevos desaf√≠os en mi vida laboral, as√≠ que, decid√≠ reiniciar mi blog para alinearlo con lo que estoy haciendo en mi d√≠a a d√≠a.\nPor esta raz√≥n, este es mi primer post, pero solo en esta nueva versi√≥n de mi blog.\nSobre m√≠ #Si tengo que hablar de m√≠ en una frase, me gusta decir que soy un apasionado de la programaci√≥n y la tecnolog√≠a.\nActualmente, trabajo como Desarrollador iOS en Hiberus, una consultora tecnolog√≠a fundada en Espa√±a, pero que crece r√°pidamente y est√° abriendo nuevas oficinas en lugares como Berl√≠n, Londres, M√©xico DF o Miami.\nMi experiencia laboral ha estado principalmente enfocada en IT y, adem√°s de en programaci√≥n, tengo experiencia previa trabajando como QA o DevOps.\nDebido a que soy un entusiasta de los productos de Apple, decid√≠ aprender Swift y especializarme en el desarrollo de aplicaciones para su ecosistema. No solo para dispositivos iOS, sino tambi√©n para MacOS o el resto de los sistemas operativos de Apple.\nMi vida personal #Nac√≠ en Valencia (Espa√±a), donde vivo actualmente. Y nac√≠ en los 80‚Äôs, la √©poca del Spectrum, Atari y las primeras videoconsolas de Sega o Nintendo. As√≠ que crec√≠ y disfrut√© jugando videojuegos con mi Sega Megadrive, y viendo dibujos animados como He-man, Oliver y Benji o Bola de Drag√≥n.\nSoy el orgulloso padre de Lucas üë∂üèª, mi hijo de 3 a√±os que se ha convertido en el CEO de casa, y el orgulloso marido de Lorena, la mejor compa√±era de vida que podr√≠a tener. Una mujer maravillosa, con un poder especial para tratar con la infancia (Y conmigo üòÖ)\nActualmente, paso mis horas fuera del trabajo con mi familia o mis aficiones, como: disfrutar de series de TV, ver F√≥rmula 1, leer o jugar al ajedrez.\nPor qu√© escribo en este blog #Conocimiento #La primera raz√≥n (y la m√°s importante) es para aprender. Para m√≠, hay 3 niveles de conocimiento:\n1¬∫: Cuando alguien te ense√±a algo, o lo aprendes viendo un video, leyendo un libro\u0026hellip; 2¬∫: Cuando eres capaz de hacer lo que has aprendido. 3¬∫: Cuando eres capaz de ense√±ar a alguien lo que sabes. Y, por esta raz√≥n, escribir en un blog me ayuda a aprender ense√±ando a otros.\nPara ayudar #La segunda, es ayudar a otros en lo que hoy disfruto cada vez m√°s: programar. Creo que a todos les gusta ayudar a los dem√°s, y adem√°s, esta es mi manera de extender la ayuda que recibo de otros.\nExpresar mi opini√≥n #Otra raz√≥n es que, como Desarrollador iOS, necesito tener un profundo entendimiento sobre todo el ecosistema de Apple, as√≠ que, este ser√° un lugar para organizar mis pensamientos sobre las noticias, productos, eventos como la WWDC\u0026hellip; pero siempre enfocado en la programaci√≥n.\nPracticar ingl√©s #Y la √∫ltima raz√≥n, (pero no menos importante), practicar escribir documentaci√≥n t√©cnica en ingl√©s. Mi lengua materna es el espa√±ol, pero la globalizaci√≥n y el trabajo remoto han abierto muchas oportunidades. Y el ingl√©s es hoy el idioma clave para aprender y trabajar.\nSi quieres saber m√°s sobre m√≠, no dudes en consultar mis enlaces de redes sociales\n¬°As√≠ que, espero que disfrutes de mis posts! üôÇ\n","date":"2 enero 2023","permalink":"/es/blog/mi-nuevo-primer-post/","section":"Blog","summary":"Qui√©n soy y por qu√© he relanzado mi blog","title":"Mi (nuevo) primer post"},{"content":"Puedes encontrarme en las siguientes redes sociales:\n@oscarmorenodev\nOscar Moreno\nO si prefieres, puedes escribirme un email a oscar@oscarmoreno.com\n","date":null,"permalink":"/es/contacto/","section":"Oscar Moreno | Desarrollador iOS Ô£ø","summary":"\u003cp\u003ePuedes encontrarme en las siguientes redes sociales:\u003c/p\u003e\n\u003cp\u003e\n\n  \u003cspan class=\"icon relative inline-block align-text-bottom\"\u003e\n    \u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 512 512\"\u003e\u003cpath fill=\"currentColor\" d=\"M389.2 48h70.6L305.6 224.2 487 464H345L233.7 318.6 106.5 464H35.8L200.7 275.5 26.8 48H172.4L272.9 180.9 389.2 48zM364.4 421.8h39.1L151.1 88h-42L364.4 421.8z\"/\u003e\u003c/svg\u003e\n\n  \u003c/span\u003e\n\n \u003ca href=\"https://twitter.com/oscarmorenodev\" target=\"_blank\" rel=\"noreferrer\"\u003e@oscarmorenodev\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\n\n  \u003cspan class=\"icon relative inline-block align-text-bottom\"\u003e\n    \u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 448 512\"\u003e\u003cpath fill=\"currentColor\" d=\"M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z\"/\u003e\u003c/svg\u003e\n\n  \u003c/span\u003e\n\n \u003ca href=\"https://linkedin.com/in/oscarmorenodev\" target=\"_blank\" rel=\"noreferrer\"\u003eOscar Moreno\u003c/a\u003e\u003c/p\u003e","title":"Contacto"},{"content":"Un email. Uno esencial. Cada semana. #¬øBuscas una newsletter Swift que te ahorre tiempo y te mantenga al d√≠a con lo m√°s relevante del desarrollo en plataformas Apple?\nOne Swift Thing es para ti.\nCada semana, reviso las newsletters Swift m√°s destacadas ‚Äîsobre Swift, SwiftUI, Xcode, frameworks, productividad y nuevas herramientas‚Äî y selecciono un solo art√≠culo. El m√°s valioso. El que merece tu atenci√≥n.\nüß≠ ¬øPor qu√© una sola cosa? #Porque creo en la constancia.\nEs mejor aprender una idea √∫til cada semana que devorar veinte y luego pasar meses sin tocar nada nuevo.\nOne Swift Thing nace de esa filosof√≠a: menos ruido, m√°s intenci√≥n.\nUna newsletter Swift que te ayuda a avanzar poco a poco, sin agobios.\nüí° ¬øY si tengo tiempo para m√°s? #Te animo a que te suscribas a varias newsletters Swift si puedes. Yo mismo lo hago. Hay mucho contenido de calidad ah√≠ fuera.\nPero si no puedes dedicar tiempo a revisar qu√© leer, si no sabes qu√© es realmente importante esta semana‚Ä¶\nAh√≠ es donde entra esta newsletter Swift.\n‚úÖ ¬øQu√© obtendr√°s? # üìå Una selecci√≥n personal, semanal y sin automatismos. üß† Un solo art√≠culo, con contexto: por qu√© lo he elegido y qu√© puedes aprender. ‚úâÔ∏è En tu bandeja cada lunes. üö´ Sin listas interminables. üéØ ¬øPara qui√©n es? # Para desarrolladores Apple que valoran su tiempo. Para quienes quieren seguir aprendiendo, pero de forma sostenible. Para quienes ya no pueden revisar todas las newsletters Swift‚Ä¶ pero no quieren perderse lo esencial. üì© Suscr√≠bete gratis #Solo una cosa √∫til a la semana. Una newsletter Swift pensada para desarrolladores como t√∫.\nOne Swift Thing * indica que es obligatorio Direcci√≥n de email * /* real people should not fill this in and expect good things - do not remove this or risk form bot signups */ üîí 100% privacidad. No comparto tus datos con nadie.\nüîÅ Puedes darte de baja en cualquier momento, sin preguntas.\n","date":null,"permalink":"/es/newsletter/","section":"Oscar Moreno | Desarrollador iOS Ô£ø","summary":"\u003ch2 id=\"un-email-uno-esencial-cada-semana\" class=\"relative group\"\u003eUn email. Uno esencial. Cada semana. \u003cspan class=\"absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100\"\u003e\u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\" style=\"text-decoration-line: none !important;\" href=\"#un-email-uno-esencial-cada-semana\" aria-label=\"Ancla\"\u003e#\u003c/a\u003e\u003c/span\u003e\u003c/h2\u003e\u003cp\u003e¬øBuscas una \u003cstrong\u003enewsletter Swift\u003c/strong\u003e que te ahorre tiempo y te mantenga al d√≠a con lo m√°s relevante del desarrollo en plataformas Apple?\u003cbr\u003e\n\u003cstrong\u003eOne Swift Thing\u003c/strong\u003e es para ti.\u003c/p\u003e\n\u003cp\u003eCada semana, reviso las newsletters Swift m√°s destacadas ‚Äîsobre Swift, SwiftUI, Xcode, frameworks, productividad y nuevas herramientas‚Äî y selecciono \u003cstrong\u003eun solo art√≠culo\u003c/strong\u003e. El m√°s valioso. El que merece tu atenci√≥n.\u003c/p\u003e","title":"One Swift Thing"},{"content":"Recopilo datos de uso utilizando Google Analytics con el fin de visualizar el tr√°fico en este sitio web.\nTodos los datos son an√≥nimos y no vendo ni comparto ning√∫n dato con terceros.\nSi decides rechazarlo, no se recopilar√° ninguna informaci√≥n.\n","date":null,"permalink":"/es/privacidad/","section":"Oscar Moreno | Desarrollador iOS Ô£ø","summary":"\u003cp\u003eRecopilo datos de uso utilizando Google Analytics con el fin de visualizar el tr√°fico en este sitio web.\u003c/p\u003e\n\u003cp\u003eTodos los datos son an√≥nimos y no vendo ni comparto ning√∫n dato con terceros.\u003c/p\u003e\n\u003cp\u003eSi decides rechazarlo, no se recopilar√° ninguna informaci√≥n.\u003c/p\u003e","title":"Privacidad"},{"content":"Si tengo que hablar sobre m√≠ en una frase, me gusta decir que soy un apasionado de la programaci√≥n y del mundo tecnol√≥gico.\nMi vida profesional #Actualmente, trabajo como Desarrollador iOS en Openbank, el banco online de Grupo Santander, que disponde de aplicaciones usadas por millones de personas a lo largo de Europa y Am√©rica.\nPero, mi experiencia laboral ha estado principalmente enfocada en IT. Adem√°s de programar, tengo experiencia previa trabajando como ingeniero QA o DevOps.\nRecientemente, debido a que soy un usuario entusiasta de los productos de Apple, decid√≠ aprender Swift y especializarme en el desarrollo de su ecosistema. No solo para dispositivos iOS, sino para MacOS o el resto de los sistemas operativos de Apple.\nMi vida personal #Nac√≠ en Valencia (Espa√±a), donde vivo actualmente,. Y nac√≠ en los 80, la √©poca del Spectrum, Atari y las primeras videoconsolas de Sega o Nintendo. As√≠ que crec√≠ y disfrut√© jugando videojuegos con mi Sega Megadrive, viendo dibujos animados como He-man, Dragon Ball o Capit√°n Tsubasa.\nSoy el orgulloso padre de Lucas y Vega, los peque√±os que se han convertido en los reyes de la casa, y marido de Lorena, la mejor compa√±era de vida que podr√≠a tener. Una mujer maravillosa, con un poder especial para tratar con la infancia (Y conmigo üòÖ)\nActualmente, paso mis horas fuera del trabajo con mi familia o mis aficiones, como: disfrutar de series de TV o ver carreras de F√≥rmula 1.\n","date":null,"permalink":"/es/sobre-mi/","section":"Oscar Moreno | Desarrollador iOS Ô£ø","summary":"\u003cp\u003eSi tengo que hablar sobre m√≠ en una frase, me gusta decir que soy un apasionado de la programaci√≥n y del mundo tecnol√≥gico.\u003c/p\u003e\n\u003ch3 id=\"mi-vida-profesional\" class=\"relative group\"\u003eMi vida profesional \u003cspan class=\"absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100\"\u003e\u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\" style=\"text-decoration-line: none !important;\" href=\"#mi-vida-profesional\" aria-label=\"Ancla\"\u003e#\u003c/a\u003e\u003c/span\u003e\u003c/h3\u003e\u003cp\u003eActualmente, trabajo como Desarrollador iOS en \u003ca href=\"https://www.openbank.com\" target=\"_blank\" rel=\"noreferrer\"\u003eOpenbank\u003c/a\u003e, el banco online de \u003ca href=\"https://santander.com\" target=\"_blank\" rel=\"noreferrer\"\u003eGrupo Santander\u003c/a\u003e, que disponde de aplicaciones usadas por millones de personas a lo largo de Europa y Am√©rica.\u003c/p\u003e\n\u003cp\u003ePero, mi experiencia laboral ha estado principalmente enfocada en IT. Adem√°s de programar, tengo experiencia previa trabajando como ingeniero QA o DevOps.\u003c/p\u003e","title":"Sobre m√≠"},{"content":"","date":null,"permalink":"/es/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":null,"permalink":"/es/tags/","section":"Tags","summary":"","title":"Tags"}]