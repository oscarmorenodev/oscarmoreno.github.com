[{"content":"","date":null,"permalink":"/","section":"Oscar Moreno | Desarrollador iOS Ô£ø","summary":"","title":"Oscar Moreno | Desarrollador iOS Ô£ø"},{"content":"Si tengo que hablar sobre m√≠ en una frase, me gusta decir que soy un apasionado de la programaci√≥n y del mundo tecnol√≥gico.\nActualmente, trabajo como Desarrollador iOS en Hiberus, una empresa de consultor√≠a global fundada en Espa√±a, pero que crece r√°pidamente y est√° abriendo nuevas oficinas en lugares como Berl√≠n, Londres, M√©xico DF o Miami.\nPero, mi experiencia laboral ha estado principalmente enfocada en IT. Adem√°s de programar, tengo experiencia previa trabajando como ingeniero QA o DevOps.\nRecientemente, debido a que soy un usuario entusiasta de los productos de Apple, decid√≠ aprender Swift y especializarme en el desarrollo de su ecosistema. No solo para dispositivos iOS, sino para MacOS o el resto de los sistemas operativos de Apple.\nMi vida personal #Nac√≠ en Valencia (Espa√±a), donde vivo actualmente,. Y nac√≠ en los 80, la √©poca del Spectrum, Atari y las primeras videoconsolas de Sega o Nintendo. As√≠ que crec√≠ y disfrut√© jugando videojuegos con mi Sega Megadrive, viendo dibujos animados como He-man, Dragon Ball o Capit√°n Tsubasa.\nSoy el orgulloso padre de Lucas üë∂üèª, mi hijo de 3 a√±os que se ha convertido en el CEO de casa, y el orgulloso esposo de Lorena, la mejor compa√±era de vida que podr√≠a tener. Una mujer maravillosa, con un poder especial para tratar con la infancia (Y conmigo üòÖ)\nActualmente, paso mis horas fuera del trabajo con mi familia o mis aficiones, como: disfrutar de series de TV, jugar al ajedrez o ver carreras de F√≥rmula 1.\n","date":"6 marzo 2024","permalink":"/sobre-mi/","section":"Oscar Moreno | Desarrollador iOS Ô£ø","summary":"Si tengo que hablar sobre m√≠ en una frase, me gusta decir que soy un apasionado de la programaci√≥n y del mundo tecnol√≥gico.\nActualmente, trabajo como Desarrollador iOS en Hiberus, una empresa de consultor√≠a global fundada en Espa√±a, pero que crece r√°pidamente y est√° abriendo nuevas oficinas en lugares como Berl√≠n, Londres, M√©xico DF o Miami.\nPero, mi experiencia laboral ha estado principalmente enfocada en IT. Adem√°s de programar, tengo experiencia previa trabajando como ingeniero QA o DevOps.","title":"Sobre m√≠"},{"content":"Los closures son un concepto fundamental en Swift. Son herramientas poderosas que te permiten definir y manipular bloques de c√≥digo, por eso se les considera ciudadanos de primera clase. En este art√≠culo, exploraremos los closures, los closures finales, la captura de valores y el hecho de que los closures son tipos por referencia\nClosures #Un closure es un bloque de c√≥digo aut√≥nomo que se puede pasar y utilizar en el c√≥digo, como cualquier otra constante o variable. En Swift, puedes definir closures usando las llaves {}. Este ser√≠a un ejemplo sencillo:\nlet greet = { print(\u0026#34;Hello, world!\u0026#34;) } Closures finales #Los closures finales son una forma conveniente de incluir un closure como √∫ltimo argumento de una funci√≥n. Esto hace que tu c√≥digo sea m√°s legible. Supongamos que tienes una funci√≥n que toma un closure como argumento:\nfunc performAction(action: () -\u0026gt; Void) { // Perform some setup action() } // Using a trailing closure performAction { print(\u0026#34;Action performed!\u0026#34;) } Capturando valores #Los closures pueden capturar y almacenar referencias a variables y constantes del contexto en el que se definen. Esto significa que pueden \u0026ldquo;recordar\u0026rdquo; y manipular esos valores incluso si ya no est√°n dentro de su √°mbito. Mira este ejemplo:\nfunc makeIncrementer(incrementAmount: Int) -\u0026gt; () -\u0026gt; Int { var total = 0 let incrementer: () -\u0026gt; Int = { total += incrementAmount return total } return incrementer } // Usage example: let incrementByTwo = makeIncrementer(incrementAmount: 2) let incrementByFive = makeIncrementer(incrementAmount: 5) print(incrementByTwo()) // Output: 2 print(incrementByTwo()) // Output: 4 print(incrementByTwo()) // Output: 6 print(incrementByFive()) // Output: 5 print(incrementByFive()) // Output: 10 print(incrementByFive()) // Output: 15 En este ejemplo, definimos la funci√≥n makeIncrementer, que toma un incrementAmount como argumento y devuelve un closure de tipo () -\u0026gt; Int. Cada vez que llama al closure devuelto, incrementa la variable total en el valor de incrementAmount especificado y devuelve el total actualizado. Creamos dos closures separados, incrementByTwo e incrementByFive, cada uno con su propio total capturado y su incrementAmount. Cuando llamamos a estos closures varias veces, puedes ver c√≥mo mantienen su estado individual y aumentan en sus respectivos cantidades.\nLos closures son tipos por referencia #Los closures son m√°s que simples bloques de c√≥digo, son tipos por referencia. Puedes declarar un closure y las variables de ese tipo pueden contener closures con las mismas firmas. Esto te permite definir funciones que toman closures como par√°metros, o que los devuelven como resultados, proporcionando flexibilidad y reutilizaci√≥n en tu c√≥digo.\nConclusi√≥n #En resumen, los closures son un concepto clave en Swift y comprenderlos es esencial para cualquier desarrollador de iOS. Proporcionan una forma flexible de trabajar con c√≥digo y datos, ya sea que est√©s creando funciones simples u operaciones as√≠ncronas avanzadas. Al dominar los closures, rastrearlos, capturar valores y reconocer que los closures son tipos por referencia, estar√°s mejor capacitado para escribir c√≥digo Swift eficiente y legible.\n","date":"5 septiembre 2023","permalink":"/posts/closures-en-swift/","section":"Posts","summary":"Los closures son un concepto fundamental en Swift. Son herramientas poderosas que te permiten definir y manipular bloques de c√≥digo, por eso se les considera ciudadanos de primera clase. En este art√≠culo, exploraremos los closures, los closures finales, la captura de valores y el hecho de que los closures son tipos por referencia\nClosures #Un closure es un bloque de c√≥digo aut√≥nomo que se puede pasar y utilizar en el c√≥digo, como cualquier otra constante o variable.","title":"Entendiendo los closures en Swift"},{"content":"","date":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts"},{"content":"Como desarrolladores, a menudo manejamos situaciones en las que necesitamos trabajar con funciones en nuestras aplicaciones iOS. Las funciones son una parte integral del lenguaje de programaci√≥n Swift y nos proporcionan un conjunto de herramientas poderosas para construir c√≥digo flexible y modular. En este art√≠culo, exploraremos el concepto de usar tipos de funciones y c√≥mo puede beneficiar nuestro proceso de desarrollo.\nDeterminar el tipo de funci√≥n #En Swift, las funciones se consideran ciudadanos de primera clase, lo que significa que pueden asignarse a variables o constantes y tambi√©n pueden usarse como tipos. Para determinar el tipo de una funci√≥n, podemos usar la firma de la funci√≥n. La firma consta de los tipos de par√°metros y el tipo de retorno. Consideremos un ejemplo:\nfunc add(_ a: Int, _ b: Int) -\u0026gt; Int { return a + b } El tipo de esta funci√≥n puede representarse como (Int, Int) -\u0026gt; Int, donde (Int, Int) representa los tipos de par√°metros e Int representa el tipo de retorno.\nUsar tipos de funciones como par√°metros #Una de las ventajas de usar tipos de funciones es la capacidad de pasarlas como par√°metros a otras funciones. Esto nos permite crear funciones de orden superior que pueden aceptar diferentes comportamientos seg√∫n las funciones proporcionadas. Tomemos un ejemplo donde tenemos una funci√≥n que aplica una operaci√≥n dada en una matriz de enteros:\nfunc applyOperation(_ numbers: [Int], operation: (Int) -\u0026gt; Int) -\u0026gt; [Int] { var result = [Int]() for number in numbers { let transformedNumber = operation(number) result.append(transformedNumber) } return result } En el c√≥digo anterior, la funci√≥n applyOperation toma una matriz de enteros y una funci√≥n operation como par√°metros. El par√°metro operation representa una funci√≥n que toma un entero y devuelve un entero. Podemos usar esta funci√≥n de orden superior para realizar varias operaciones en nuestra matriz de n√∫meros.\nUsar tipos de funciones como retorno #Otro aspecto poderoso de usar tipos de funciones es la capacidad de usarlos como valores de retorno. Esto nos permite crear funciones que generan y devuelven din√°micamente otras funciones seg√∫n ciertas condiciones o requisitos. Consideremos un ejemplo:\nfunc operationFactory() -\u0026gt; (Int) -\u0026gt; Int { if condition { return { number in number * 2 } } else { return { number in number / 2 } } } En este ejemplo, la funci√≥n operationFactory devuelve una funci√≥n del tipo (Int) -\u0026gt; Int basada en una cierta condici√≥n. Podemos aprovechar este comportamiento para crear un c√≥digo m√°s flexible y adaptable.\nConclusi√≥n #El uso de tipos de funciones en el desarrollo de iOS nos proporciona un mecanismo poderoso para crear c√≥digo modular y flexible. Al tratar las funciones como ciudadanos de primera clase, podemos pasarlas como par√°metros a otras funciones, usarlas como tipos de retorno y generarlas din√°micamente cuando sea necesario. Este enfoque mejora la reutilizaci√≥n del c√≥digo, promueve la modularidad y permite la creaci√≥n de funciones de orden superior. Al aprovechar estas capacidades, los desarrolladores pueden construir aplicaciones iOS robustas y adaptables. As√≠ que, la pr√≥xima vez que te encuentres en una situaci√≥n donde necesites incorporar diferentes comportamientos en tu c√≥digo, considera usar tipos de funciones para una soluci√≥n m√°s elegante.\n","date":"10 julio 2023","permalink":"/posts/uso-funciones-swift/","section":"Posts","summary":"Como desarrolladores, a menudo manejamos situaciones en las que necesitamos trabajar con funciones en nuestras aplicaciones iOS. Las funciones son una parte integral del lenguaje de programaci√≥n Swift y nos proporcionan un conjunto de herramientas poderosas para construir c√≥digo flexible y modular. En este art√≠culo, exploraremos el concepto de usar tipos de funciones y c√≥mo puede beneficiar nuestro proceso de desarrollo.\nDeterminar el tipo de funci√≥n #En Swift, las funciones se consideran ciudadanos de primera clase, lo que significa que pueden asignarse a variables o constantes y tambi√©n pueden usarse como tipos.","title":"Usando funciones en Swift"},{"content":"Comprender las complejidades de las etiquetas de argumentos de funciones y los nombres de par√°metros es esencial para aprovechar al m√°ximo el lenguaje de programaci√≥n Swift. En este art√≠culo, exploraremos estos conceptos con un enfoque en la simplicidad, atendiendo a desarrolladores con experiencia limitada en la creaci√≥n de funciones. ¬°As√≠ que, comencemos!\nEtiquetas de argumentos de funci√≥n #Las etiquetas de argumentos proporcionan un contexto descriptivo al llamar a una funci√≥n, haciendo que el c√≥digo sea m√°s expresivo y legible. En Swift, las etiquetas de argumentos se especifican antes de los nombres de par√°metros y est√°n separadas por un espacio. Consideremos un ejemplo donde calculamos la puntuaci√≥n de un nivel de videojuego:\nfunc calculateScore(forLevel level: Int) -\u0026gt; Int { // Function body goes here } Aqu√≠, forLevel es la etiqueta del argumento, y level es el nombre del par√°metro. Al llamar a esta funci√≥n, usamos la etiqueta del argumento para proporcionar claridad:\nlet finalScore = calculateScore(forLevel: 5) Al usar etiquetas de argumentos, podemos transmitir el prop√≥sito de cada par√°metro, mejorando la comprensi√≥n de nuestro c√≥digo.\nAdem√°s, puedes omitir una etiqueta de argumento. Simplemente debes escribir un guion bajo en lugar de una etiqueta de argumento:\nfunc addStamina(_ stamina: Int) -\u0026gt; Int { // Function body goes here } Y solo necesitar√°s pasar el valor cuando llames a la funci√≥n.\nlet totalStamina = addStamina(100) Valores de par√°metros predeterminados #En Swift, tenemos la flexibilidad de asignar valores predeterminados a los par√°metros de funciones. Esto significa que al llamar a una funci√≥n, podemos optar por omitir argumentos espec√≠ficos, y en su lugar se utilizar√°n los valores predeterminados. Continuando con nuestro tema de videojuegos, modifiquemos nuestra funci√≥n anterior para incluir un valor predeterminado para el par√°metro bonusPoints:\nfunc calculateScore(level: Int, bonusPoints: Int = 500) -\u0026gt; Int { return level * bonusPoints } Ahora, podemos llamar a la funci√≥n y usar los dos par√°metros pero, si llamamos a la funci√≥n sin proporcionar un valor para bonusPoints, autom√°ticamente se utilizar√° el valor predeterminado de 500:\nlet totalScore = calculateScore(level: 2, bonusPoints: 100) // totalScore is equal to 200 let finalScore = calculateScore(level: 5) // finalScore is equal to 2500 Par√°metros vari√°dicos #A veces, podemos encontrarnos con situaciones donde el n√∫mero de argumentos de la funci√≥n no es fijo. Para manejar tales escenarios, Swift nos permite usar par√°metros vari√°dicos. Estos par√°metros pueden aceptar cero o m√°s valores de un tipo especificado. Para demostrarlo, imagina una funci√≥n que calcula la puntuaci√≥n total de varios videojuegos:\nfunc calculateTotalScore(scores: Int...) -\u0026gt; Int { // Function body goes here } Aqu√≠, scores es un par√°metro vari√°dico. Podemos pasar cualquier n√∫mero de argumentos separados por comas al llamar a la funci√≥n:\nlet totalScore = calculateTotalScore(scores: 100, 250, 500, 750) Par√°metros de entrada-salida #Por √∫ltimo, Swift proporciona el modificador de par√°metro in-out, que permite a una funci√≥n modificar el valor de una variable desde fuera de su propio √°mbito. Los par√°metros de entrada-salida se prefijan con la palabra clave \u0026ldquo;inout\u0026rdquo;. Considera un escenario donde necesitamos actualizar los puntos de salud de un personaje de juego:\nfunc updateHealthPoints(_ hp: inout Int) { // Function body goes here } Para pasar una variable como un par√°metro in-out, antecedemos un ampersand antes del nombre de la variable:\nvar characterHP = 100 updateHealthPoints(\u0026amp;characterHP) Conclusi√≥n #En este art√≠culo, hemos cubierto los fundamentos de las etiquetas de argumentos de funciones y los nombres de par√°metros en Swift. Exploramos el uso de etiquetas de argumentos, valores de par√°metros predeterminados, par√°metros variadicos y par√°metros de in-out. Al dominar estos conceptos, podr√°s escribir c√≥digo limpio, expresivo y flexible en tus proyectos de iOS. Sigue practicando e incorporando estas t√©cnicas en tu viaje de desarrollo, y pronto podr√≠as estar creando videojuegos retro notables que dejen a los jugadores nost√°lgicos por la edad de oro de los videojuegos.\n","date":"26 junio 2023","permalink":"/posts/etiquetas-argumentos-funcion-parametros/","section":"Posts","summary":"Comprender las complejidades de las etiquetas de argumentos de funciones y los nombres de par√°metros es esencial para aprovechar al m√°ximo el lenguaje de programaci√≥n Swift. En este art√≠culo, exploraremos estos conceptos con un enfoque en la simplicidad, atendiendo a desarrolladores con experiencia limitada en la creaci√≥n de funciones. ¬°As√≠ que, comencemos!\nEtiquetas de argumentos de funci√≥n #Las etiquetas de argumentos proporcionan un contexto descriptivo al llamar a una funci√≥n, haciendo que el c√≥digo sea m√°s expresivo y legible.","title":"Etiquetas de argumentos de funci√≥n y nombres de par√°metros"},{"content":"Como desarrolladores de iOS, a menudo nos encontramos con escenarios donde necesitamos devolver m√∫ltiples valores de una funci√≥n. Swift nos ofrece dos enfoques √∫tiles para lograr esto: utilizando tuplas y colecciones. En este art√≠culo, exploraremos ambos m√©todos y entenderemos cu√°ndo usar cada uno.\nUsando Tuplas #Las tuplas son estructuras de datos ligeras que nos permiten agrupar m√∫ltiples valores juntos. Proporcionan una forma sencilla de devolver m√∫ltiples valores de una funci√≥n. Considera el siguiente ejemplo:\nfunc getMovieDetails(movieId: Int) -\u0026gt; (String, String) { // Retrieve movie details from the database let movieTitle = \u0026#34;Back to the Future\u0026#34; let director = \u0026#34;Robert Zemeckis\u0026#34; return (movieTitle, director) } let movieDetails = getMovieDetails(movieId: 1) print(\u0026#34;Title: \\(movieDetails.0)\u0026#34;) print(\u0026#34;Director: \\(movieDetails.2)\u0026#34;) En este ejemplo, la funci√≥n getMovieDetails devuelve una tupla que contiene el t√≠tulo de la pel√≠cula y el director. Podemos acceder a valores individuales usando la sintaxis de punto y el √≠ndice correspondiente. Las tuplas son √∫tiles cuando tenemos un n√∫mero fijo de valores para devolver.\nUsando colecciones #Las colecciones, como arrays o diccionarios, ofrecen un enfoque m√°s flexible para devolver m√∫ltiples valores. Veamos c√≥mo podemos modificar nuestro ejemplo anterior para utilizar un array:\nfunc getMovieDetails(movieId: Int) -\u0026gt; [String] { // Retrieve movie details from the database let movieTitle = \u0026#34;Back to the Future\u0026#34; let releaseYear = 1985 let director = \u0026#34;Robert Zemeckis\u0026#34; return [movieTitle, String(releaseYear), director] } let movieDetails = getMovieDetails(movieId: 1) print(\u0026#34;Title: \\(movieDetails[0])\u0026#34;) print(\u0026#34;Release Year: \\(movieDetails[1])\u0026#34;) print(\u0026#34;Director: \\(movieDetails[2])\u0026#34;) Aqu√≠, la funci√≥n getMovieDetails devuelve un array de strings, conteniendo el t√≠tulo de la pel√≠cula, el a√±o de lanzamiento (convertido a string) y el director. Accedemos a los valores por sus respectivos √≠ndices. Las colecciones son ventajosas cuando tenemos un n√∫mero variable de valores para devolver o si el n√∫mero de valores puede cambiar en el futuro.\nElegir entre Tuplas y Colecciones #Al decidir entre tuplas y colecciones, considera las siguientes pautas:\nUsa tuplas cuando tengas un n√∫mero fijo de valores que no cambiar√°. Usa colecciones cuando el n√∫mero de valores pueda variar o cuando necesites agregar o eliminar valores f√°cilmente. Conclusi√≥n #Devolver m√∫ltiples valores de una funci√≥n en Swift es esencial en muchos escenarios de programaci√≥n. Al utilizar tuplas o colecciones, podemos manejar eficientemente estas situaciones. Las tuplas son adecuadas para devolver un n√∫mero fijo de valores, mientras que las colecciones ofrecen flexibilidad cuando el n√∫mero de valores puede variar. Entender estas t√©cnicas nos empodera para escribir un c√≥digo m√°s limpio y expresivo.\nRecuerda experimentar con estos conceptos usando ejemplos del mundo real y explorar c√≥mo pueden ser aplicados a tus propios proyectos.\n","date":"12 junio 2023","permalink":"/posts/devolviendo-multiples-valores-desde-funciones/","section":"Posts","summary":"Como desarrolladores de iOS, a menudo nos encontramos con escenarios donde necesitamos devolver m√∫ltiples valores de una funci√≥n. Swift nos ofrece dos enfoques √∫tiles para lograr esto: utilizando tuplas y colecciones. En este art√≠culo, exploraremos ambos m√©todos y entenderemos cu√°ndo usar cada uno.\nUsando Tuplas #Las tuplas son estructuras de datos ligeras que nos permiten agrupar m√∫ltiples valores juntos. Proporcionan una forma sencilla de devolver m√∫ltiples valores de una funci√≥n. Considera el siguiente ejemplo:","title":"Devolviendo m√∫ltiples valores desde una funci√≥n: Tuplas vs. Colecciones"},{"content":"Como desarrollador, es esencial entender los conceptos fundamentales de la programaci√≥n. Uno de esos conceptos es las funciones, las cuales desempe√±an un papel crucial en la organizaci√≥n y reutilizaci√≥n del c√≥digo. En este art√≠culo, exploraremos los conceptos b√°sicos de las funciones en Swift. Ya seas un principiante o est√©s buscando una revisi√≥n, esta gu√≠a te ayudar√° a comprender los aspectos esenciales de las funciones de manera simple y directa.\n¬øQu√© son las Funciones? #Una funci√≥n es un bloque de c√≥digo que realiza una tarea espec√≠fica. Te permite encapsular un conjunto de instrucciones bajo un nombre significativo, haciendo que tu c√≥digo sea m√°s organizado y modular. Las funciones pueden aceptar valores de entrada, llamados par√°metros, y devolver valores de salida. Proporcionan una forma de descomponer la l√≥gica compleja en partes m√°s peque√±as y manejables.\nSintaxis y Estructura: #En Swift, la declaraci√≥n de una funci√≥n comienza con la palabra clave func, seguida del nombre de la funci√≥n y par√©ntesis. Si la funci√≥n acepta par√°metros, se especifican dentro de los par√©ntesis. El tipo de retorno se indica con una flecha -\u0026gt; seguida del tipo. Aqu√≠ tienes un ejemplo:\nfunc greet(name: String) -\u0026gt; String { return \u0026#34;Hello, \\(name)!\u0026#34; } En este ejemplo, tenemos una funci√≥n llamada greet que acepta un par√°metro llamado name de tipo String. Devuelve un valor String que contiene un mensaje de saludo con el nombre proporcionado.\nEscenario de ejemplo #Imaginemos que estamos construyendo una aplicaci√≥n relacionada con programas de televisi√≥n. Podemos crear una funci√≥n para recomendar un programa en funci√≥n de las preferencias del usuario. Aqu√≠ tienes un ejemplo:\nfunc recommendShow(userPreference: String) -\u0026gt; String { if userPreference == \u0026#34;action\u0026#34; { return \u0026#34;You should watch \u0026#39;Game of Thrones\u0026#39;!\u0026#34; } else if userPreference == \u0026#34;comedy\u0026#34; { return \u0026#34;I recommend \u0026#39;Friends\u0026#39;!\u0026#34; } else { return \u0026#34;I\u0026#39;m sorry, I don\u0026#39;t have a recommendation for your preference.\u0026#34; } } Cuando llamas a esta funci√≥n con diferentes preferencias, como \u0026ldquo;acci√≥n\u0026rdquo; o \u0026ldquo;comedia\u0026rdquo;, devolver√° una recomendaci√≥n apropiada. Si la preferencia del usuario no coincide con ning√∫n caso espec√≠fico, se devuelve un mensaje predeterminado.\nCu√°ndo Usar Funciones #Las funciones son particularmente √∫tiles en los siguientes escenarios:\nReusabilidad #Si te encuentras realizando la misma tarea o c√°lculo en m√∫ltiples lugares de tu c√≥digo, es una buena indicaci√≥n para crear una funci√≥n para esa tarea. De esta manera, puedes reutilizar el c√≥digo sin duplicarlo.\nModularidad #Las funciones ayudan a organizar el c√≥digo en unidades m√°s peque√±as y autocontenidas. Esto mejora la legibilidad y mantenibilidad del c√≥digo.\nAbstracci√≥n #Al encapsular la l√≥gica compleja dentro de las funciones, puedes abstraer los detalles de implementaci√≥n y centrarte en la funcionalidad de nivel superior.\nConclusi√≥n #Comprender los conceptos b√°sicos de las funciones es esencial para cualquier desarrollador. Te permiten escribir c√≥digo limpio y reutilizable, y mejorar la estructura de tus programas. En este art√≠culo, exploramos la sintaxis y la estructura de las funciones en Swift, junto con un escenario de ejemplo utilizando las preferencias de programas de televisi√≥n. Al aprovechar las funciones de manera efectiva, puedes crear un c√≥digo m√°s modular y mantenible.\n","date":"29 mayo 2023","permalink":"/posts/entendiendo-basico-funciones/","section":"Posts","summary":"Como desarrollador, es esencial entender los conceptos fundamentales de la programaci√≥n. Uno de esos conceptos es las funciones, las cuales desempe√±an un papel crucial en la organizaci√≥n y reutilizaci√≥n del c√≥digo. En este art√≠culo, exploraremos los conceptos b√°sicos de las funciones en Swift. Ya seas un principiante o est√©s buscando una revisi√≥n, esta gu√≠a te ayudar√° a comprender los aspectos esenciales de las funciones de manera simple y directa.\n¬øQu√© son las Funciones?","title":"Entendiendo lo b√°sico de las funciones en Swift"},{"content":"En Swift, hay varios constructores del lenguaje que hacen la programaci√≥n m√°s eficiente y robusta.\nUno de estos constructores es la declaraci√≥n defer, que permite a los desarrolladores ejecutar un bloque de c√≥digo m√°s tarde en el flujo del programa. Este art√≠culo tiene como objetivo explicar c√≥mo funciona defer en Swift, proporcionar ejemplos de su uso y destacar los escenarios en los cuales puede ser beneficioso.\nSe utiliza para definir un bloque de c√≥digo que se ejecuta cuando se sale del √°mbito actual, independientemente de c√≥mo se salga del √°mbito, ya sea mediante una declaraci√≥n de retorno, un error o un break. Ten en cuenta que, en caso de que tu aplicaci√≥n deje de funcionar debido a un error en tiempo de ejecuci√≥n, el c√≥digo diferido no se ejecuta.\nAsegura que se ejecute un c√≥digo de limpieza o finalizaci√≥n espec√≠fico antes de salir del √°mbito, independientemente del camino de ejecuci√≥n.\nSintaxis de defer #La sintaxis es simple. Comienzas con la palabra clave defer seguido por el bloque de c√≥digo que quieres ejecutar m√°s tarde. Aqu√≠ un ejemplo:\nfunc processFile() { print(\u0026#34;Opening file...\u0026#34;) defer { print(\u0026#34;Closing file...\u0026#34;) } // Code for processing the file goes here // This code will be executed before the file is closed } En este ejemplo, el mensaje Opening file... se imprime primero, y luego se define el bloque defer.\nEl bloque defer contiene el c√≥digo que se ejecutar√° al final, justo antes de salir del √°mbito. En este caso, el mensaje Closing file... siempre se imprimir√°, asegurando que el archivo se cierre correctamente.\nCasos de uso de defer #defer es particularmente √∫til en escenarios donde necesitas asegurarte de que los recursos sean liberados correctamente o que se realicen acciones independientemente del camino de ejecuci√≥n. Algunos casos de uso comunes incluyen:\nLimpieza de recursos #Cuando trabajas con archivos, bases de datos o conexiones de red, puedes usar defer para asegurar que los recursos se liberen, las conexiones se cierren o las transacciones se confirmen.\nLiberaci√≥n de bloqueos #Si haces uso de un bloqueo o un sem√°foro, la declaraci√≥n defer puede ayudar a liberarlo incluso si ocurre una excepci√≥n o si el bloque de c√≥digo se sale de la ejecuci√≥n antes de tiempo.\nRestauraci√≥n de estado #En flujos de trabajo complejos o operaciones as√≠ncronas, puedes usar la declaraci√≥n defer para restaurar el estado a una condici√≥n consistente o inicial antes de salir del √°mbito.\nRegistro y depuraci√≥n #defer se puede emplear para registrar o informar informaci√≥n con fines de depuraci√≥n antes de salir del √°mbito actual.\nConclusi√≥n #defer en Swift es un constructo del lenguaje poderoso que permite a los desarrolladores diferir la ejecuci√≥n de c√≥digo hasta el final de un √°mbito. Asegura que se ejecute un c√≥digo espec√≠fico de limpieza o finalizaci√≥n, independientemente de c√≥mo se salga del √°mbito.\nAl aprovechar la declaraci√≥n defer, los desarrolladores podemos escribir c√≥digo m√°s resiliente y organizado, facilitando la gesti√≥n de la limpieza de recursos y asegurando el comportamiento deseado en varios escenarios.\nRecuerda, la declaraci√≥n defer puede ser particularmente √∫til cuando trabajas con recursos, bloqueos, gesti√≥n de estado y depuraci√≥n.\n","date":"15 mayo 2023","permalink":"/posts/descubriendo-defer-swift/","section":"Posts","summary":"En Swift, hay varios constructores del lenguaje que hacen la programaci√≥n m√°s eficiente y robusta.\nUno de estos constructores es la declaraci√≥n defer, que permite a los desarrolladores ejecutar un bloque de c√≥digo m√°s tarde en el flujo del programa. Este art√≠culo tiene como objetivo explicar c√≥mo funciona defer en Swift, proporcionar ejemplos de su uso y destacar los escenarios en los cuales puede ser beneficioso.\nSe utiliza para definir un bloque de c√≥digo que se ejecuta cuando se sale del √°mbito actual, independientemente de c√≥mo se salga del √°mbito, ya sea mediante una declaraci√≥n de retorno, un error o un break.","title":"Descubriendo defer en Swift"},{"content":"En la programaci√≥n iOS, una construcci√≥n poderosa que ayuda a mejorar la legibilidad del c√≥digo y a mejorar el flujo de control es la sentencia guard. Esta declaraci√≥n act√∫a como un guardi√°n, permiti√©ndonos manejar de manera elegante los escenarios excepcionales y salir temprano de un bloque de c√≥digo.\nEn este art√≠culo, descubrir√°s los beneficios de la sentencia guard, explorar√°s su uso y proporcionar√°s ejemplos para ilustrar su efectividad.\nEntendiendo la sentencia guard #La sentencia guard sirve como un mecanismo de salida anticipada condicional en Swift, el lenguaje de programaci√≥n para el desarrollo de iOS.\nPermite verificar condiciones espec√≠ficas y asegurar que se cumplan antes de continuar con la ejecuci√≥n de un bloque de c√≥digo.\nSi las condiciones no se cumplen, la sentencia guard termina el √°mbito actual, permiti√©ndonos manejar los escenarios de fallo de manera elegante.\nLa sintaxis para una sentencia guard es la siguiente:\nguard condition else { // Code to handle the failure case // Return, throw, or perform any necessary cleanup } // Code to execute when the condition is successfully met Cuando se encuentra una sentencia guard, se eval√∫a la condici√≥n especificada.\nSi la condici√≥n se eval√∫a como falsa, se ejecuta el c√≥digo dentro del bloque else.\nEste bloque t√≠picamente contiene c√≥digo para manejar el caso de fallo, como retornar de la funci√≥n, lanzar un error, o realizar cualquier limpieza necesaria. Si la condici√≥n se eval√∫a como verdadera, el c√≥digo contin√∫a ejecut√°ndose normalmente despu√©s de guard.\nSalida anticipada para condiciones inaceptables #Las sentencias guard pueden ayudar a evitar declaraciones condicionales anidadas proporcionando salidas tempranas para condiciones que se consideran inaceptables. Esto simplifica el c√≥digo y mejora la legibilidad. Por ejemplo:\nlet amount = 500 let accountBalance = 1000 guard amount \u0026lt;= accountBalance else { print(\u0026#34;Insufficient funds!\u0026#34;) return } // Perform payment operation Otros casos de uso #Hay otros casos de uso para guard, espec√≠ficamente relacionados con los Opcionales y el manejo de errores. Sin embargo, dado que estos son temas m√°s avanzados, en mi opini√≥n, es mejor solo mencionarlos ahora y explorarlos en detalle en publicaciones avanzadas futuras.\nValidaci√≥n de entradas #La sentencia guard se utiliza a menudo para validar los par√°metros de entrada, asegurando que cumplan con ciertos requisitos antes de proceder. Este caso se utiliza manejando opcionales.\nDesasignaci√≥n de recursos #En este caso, guard es √∫til al tratar con recursos que requieren limpieza. Asegura que el c√≥digo de limpieza se ejecute siempre que se encuentre una condici√≥n de fallo.\nConclusi√≥n #La sentencia guard es una herramienta poderosa en la programaci√≥n de iOS que permite un c√≥digo limpio, conciso y eficiente. Proporciona una manera elegante de manejar escenarios de fallo y salir graciosamente de un bloque de c√≥digo cuando ciertas condiciones no se cumplen.\nAl usar la sentencia guard de manera efectiva, puedes mejorar la legibilidad y mantenibilidad de tu c√≥digo.\nAdopta esta construcci√≥n en tus proyectos y disfruta de los beneficios de un proceso de desarrollo m√°s eficiente.\n","date":"2 mayo 2023","permalink":"/posts/guard-salida-anticipada-swift/","section":"Posts","summary":"En la programaci√≥n iOS, una construcci√≥n poderosa que ayuda a mejorar la legibilidad del c√≥digo y a mejorar el flujo de control es la sentencia guard. Esta declaraci√≥n act√∫a como un guardi√°n, permiti√©ndonos manejar de manera elegante los escenarios excepcionales y salir temprano de un bloque de c√≥digo.\nEn este art√≠culo, descubrir√°s los beneficios de la sentencia guard, explorar√°s su uso y proporcionar√°s ejemplos para ilustrar su efectividad.\nEntendiendo la sentencia guard #La sentencia guard sirve como un mecanismo de salida anticipada condicional en Swift, el lenguaje de programaci√≥n para el desarrollo de iOS.","title":"Entendiendo la sentencia guard para una salida anticipiada"},{"content":"Las sentencias de traspaso de control son herramientas esenciales en programaci√≥n que te permiten alterar el flujo de ejecuci√≥n dentro de tu c√≥digo.\nEn Swift, tres sentencias de traspaso de control de uso com√∫n son continue, break, y fallthrough.\nEn este art√≠culo, examinaremos cada una de estas sentencias, dando ejemplos y explicando los escenarios en los que es m√°s apropiado utilizarlas.\nContinue #continue se usa principalmente dentro de bucles (como for-in o while) para omitir el c√≥digo restante dentro de la iteraci√≥n actual y pasar a la siguiente. Te permite omitir selectivamente partes espec√≠ficas de un bucle sin terminarlo por completo. Aqu√≠ un ejemplo para ilustrar su uso:\nfor number in 1...10 { if number % 2 == 0 { continue } print(number) } Resultado\n1 3 5 7 9 En este ejemplo, la instrucci√≥n continue se utiliza para omitir la impresi√≥n de n√∫meros pares. Cuando la condici√≥n number % 2 == 0 es verdadera, se ejecuta la instrucci√≥n continue, omitiendo la instrucci√≥n print y pasando a la siguiente iteraci√≥n.\nBreak #break se utiliza para finalizar prematuramente la ejecuci√≥n de un bucle o una sentencia de cambio. Te permite salir de un bucle o bloque switch antes de llegar a su final natural.\nF√±ijate el siguiente ejemplo:\nlet cars = [‚ÄúRed Bull\u0026#34;, ‚ÄúAston Martin\u0026#34;, ‚ÄúFerrari\u0026#34;, \u0026#34;Mercedes\u0026#34;, \u0026#34;McClaren\u0026#34;] for name in names { if name == \u0026#34;Mercedes\u0026#34; { break } print(name) } Resultado\nRed Bull Aston Martin Ferrari En este caso, la sentencia break se utiliza para salir del bucle una vez que la condici√≥n name == \u0026quot;Mercedes\u0026quot; es verdadera. Como resultado, el bucle termina antes de tiempo y los elementos restantes del array cars no se imprimen.\nFallthrough #fallthrough se usa exclusivamente dentro de las sentencias de cambio. Permite que el flujo de control pase al siguiente caso sin realizar una \u0026ldquo;interrupci√≥n\u0026rdquo; impl√≠cita.\nEste comportamiento es distinto del comportamiento predeterminado de un switch, donde el control de la ejecuci√≥n sale autom√°ticamente del bloque despu√©s de que coincida un caso.\nVeamos el siguiente ejemplo:\nlet grade = \u0026#34;A\u0026#34; switch grade { case \u0026#34;A\u0026#34;: print(\u0026#34;Excellent\u0026#34;) fallthrough case \u0026#34;B\u0026#34;: print(‚ÄúYou have approved\u0026#34;) case \u0026#34;C\u0026#34;: print(\u0026#34;Average\u0026#34;) default: print(\u0026#34;Incomplete\u0026#34;) } Resultado\nExcellent Good En este ejemplo, cuando la calificaci√≥n es A, la instrucci√≥n fallthrough se utiliza para continuar la ejecuci√≥n al siguiente caso sin salir del bloque de cambio. Como resultado, se imprimir√°n Excellent y You have approved.\nConclusi√≥n #Entender las sentencias de traspaso de control como continue, break, and fallthrough es crucial para una programaci√≥n en Swift eficaz.\ncontinue te permite omitir iteraciones espec√≠ficas dentro de los bucles, break resultar√° en la terminaci√≥n prematura de bucles o switches, y fallthrough har√° que el control fluya al siguiente caso en un switch.\nAl aprovechar estas sentencias de manera adecuada, puedes mejorar la flexibilidad y el control de la ejecuci√≥n de tu c√≥digo desarrollando iOS.\n","date":"17 abril 2023","permalink":"/posts/sentencias-transpaso-control-swift/","section":"Posts","summary":"Las sentencias de traspaso de control son herramientas esenciales en programaci√≥n que te permiten alterar el flujo de ejecuci√≥n dentro de tu c√≥digo.\nEn Swift, tres sentencias de traspaso de control de uso com√∫n son continue, break, y fallthrough.\nEn este art√≠culo, examinaremos cada una de estas sentencias, dando ejemplos y explicando los escenarios en los que es m√°s apropiado utilizarlas.\nContinue #continue se usa principalmente dentro de bucles (como for-in o while) para omitir el c√≥digo restante dentro de la iteraci√≥n actual y pasar a la siguiente.","title":"Explorando las sentencias de traspaso de control en Swift"},{"content":"Comprender las bases de la programaci√≥n Swift es crucial para crear aplicaciones s√≥lidas y eficientes.\nUno de los conceptos clave que debes comprender son las sentencias condicionales. En este art√≠culo, navegaremos hacia el mundo de los condicionales en Swift, explorando su sintaxis, ejemplos y mejores pr√°cticas para usarlas de manera efectiva. ¬°A ello!\nSentencias condicionales: Tomando decisiones en Swift #En programaci√≥n, a menudo hay situaciones en las que necesitas que tu aplicaci√≥n tome decisiones basadas en ciertas condiciones. Aqu√≠ es donde entran en juego las se condicionales, que le permiten ejecutar bloques de c√≥digo espec√≠ficos dependiendo de si una condici√≥n se eval√∫a como verdadera o falsa.\nSwift ofrece tres sentencias condicionales principales: sentencias if, sentencias if-else y sentencias switch.\nCada sentencia tiene un prop√≥sito distinto, y comprender cu√°ndo usar cada una es esencial para escribir c√≥digo limpio y f√°cil de mantener.\nLa sentencia if #La sentencia if es la forma m√°s simple de sentencia condicional en Swift. Te permite ejecutar un bloque de c√≥digo solo si una condici√≥n espec√≠fica es verdadera.\nPor ejemplo, digamos que quieres mostrar un mensaje si la edad de un usuario es mayor o igual a 18 a√±os:\nlet userAge = 20 if userAge \u0026gt;= 18 { print(\u0026#34;Welcome! You can access.\u0026#34;) } } La sentencia if-else #La sentencia if-else ampl√≠a la sentencia if al facilitar un bloque de c√≥digo alternativo para ejecutar cuando la condici√≥n que se eval√∫a resulta falsa.\nConsidera el siguiente ejemplo que verifica si un n√∫mero es positivo o negativo:\nlet number = -5 if number \u0026gt; 0 { print(\u0026#34;The number is positive.\u0026#34;) } else { print(\u0026#34;The number is negative.\u0026#34;) } La sentencia switch #La sentencia switch ofrece una forma m√°s concisa de manejar m√∫ltiples condiciones posibles. Eval√∫a un valor determinado frente a varios casos y ejecuta el bloque de c√≥digo asociado con el primer caso coincidente.\nSupongamos que quieres mostrar un mensaje seg√∫n el rol de un usuario:\nlet userRole = \u0026#34;admin\u0026#34; switch userRole { case \u0026#34;admin\u0026#34;: print(\u0026#34;Welcome, administrator!\u0026#34;) case \u0026#34;user\u0026#34;: print(\u0026#34;Welcome, user!\u0026#34;) default: print(\u0026#34;Unknown role.\u0026#34;) } Mejores pr√°cticas para utilizar condicionales: #Mantenlo simple #Trata de escribir c√≥digo conciso y legible. Evita condiciones anidadas complejas que puedan dificultar la comprensi√≥n y el mantenimiento del c√≥digo.\nUtiliza los operadores oportunos #Swift proporciona una variedad de operadores l√≥gicos y de comparaci√≥n, como \u0026lt;, \u0026gt;, ==, \u0026amp;\u0026amp;, ||, para construir condiciones m√°s complejas.\nPlanifica todas las posibilidades #Aseg√∫rate de tener en cuenta todos los escenarios posibles en tus sentencias condicionales. El caso default en switch act√∫a como un comod√≠n para el resto de condiciones que no hayas tenido en cuenta.\nPrueba tu c√≥digo #Valida tus condicionales con diferentes entradas para asegurarte de que se comporten como esperas. Las pruebas unitarias son una pr√°ctica muy valiosa para identificar y solucionar cualquier problema desde el principio.\nConclusi√≥n #Las sentencias condicionales son herramientas imprescindibles para el desarrollo con Swift, ya que te permiten tomar decisiones y controlar el flujo de tu c√≥digo en funci√≥n de situaciones espec√≠ficas. Al dominar las sentencias if, if-else y switch, obtendr√°s la capacidad de crear aplicaciones din√°micas y personalizadas.\nRecuerda utilizar estas sentencias con prudencia, manteniendo tu c√≥digo limpio y comprensible. üòâ\n","date":"3 abril 2023","permalink":"/posts/sentencias-condicionales-swift/","section":"Posts","summary":"Comprender las bases de la programaci√≥n Swift es crucial para crear aplicaciones s√≥lidas y eficientes.\nUno de los conceptos clave que debes comprender son las sentencias condicionales. En este art√≠culo, navegaremos hacia el mundo de los condicionales en Swift, explorando su sintaxis, ejemplos y mejores pr√°cticas para usarlas de manera efectiva. ¬°A ello!\nSentencias condicionales: Tomando decisiones en Swift #En programaci√≥n, a menudo hay situaciones en las que necesitas que tu aplicaci√≥n tome decisiones basadas en ciertas condiciones.","title":"Condicionales como base de Swift"},{"content":"En el desarrollo de iOS, las sentencias de control de flujo juegan un papel crucial en dirigir la ejecuci√≥n del c√≥digo.\nPermiten a los desarrolladores iterar sobre colecciones, realizar tareas repetitivas y controlar el comportamiento del programa basado en ciertas condiciones. En esta publicaci√≥n, nos sumergiremos en tres sentencias de control de flujo esenciales en Swift: for-in, while, y repeat-while.\nYa seas un desarrollador iOS junior o alguien que busca refrescar su conocimiento, entender estas sentencias es esencial para construir aplicaciones iOS robustas y eficientes.\nBucles for-in: Simplificando la iteraci√≥n #El bucle for-in es particularmente √∫til cuando quieres iterar sobre una colecci√≥n de elementos, como un array o un diccionario. Simplifica el proceso de acceder a cada elemento sin la necesidad de indexaci√≥n manual. Veamos un ejemplo:\nlet books = [‚ÄúA Game of Thrones‚Äù, ‚ÄúA Clash of Kings‚Äù, ‚ÄúA Storm of Swords‚Äù, ‚ÄùA Feast for Crows‚Äù, ‚ÄúA Dance with Dragons‚Äù] for book in books { print(book) } En este ejemplo, el bucle for-in itera sobre cada elemento en el array de libros e imprime su t√≠tulo. El bucle asigna autom√°ticamente cada elemento a la constante libro, permiti√©ndote realizar operaciones sobre √©l dentro del √°mbito del bucle.\nEste bucle es ideal para escenarios tales como:\nEnumerar a trav√©s de un array para realizar operaciones en cada elemento. Iterar sobre un diccionario para acceder tanto a las llaves como a los valores. Iterar sobre un rango de n√∫meros o caracteres. Bucles while: Ejecutando c√≥digo condicionalmente #El bucle while ejecuta un bloque de c√≥digo repetidamente mientras una condici√≥n dada permanezca verdadera. Esto es particularmente √∫til cuando no conoces el n√∫mero exacto de iteraciones de antemano. Aqu√≠ hay un ejemplo para ilustrar su uso:\nvar count = 0 while count \u0026lt; 5 { print(\u0026#34;Count: \\(count)\u0026#34;) count += 1 } En este ejemplo, el bucle while seguir√° ejecut√°ndose mientras la variable count sea menor que 5. Imprime el valor actual de count y lo incrementa en 1 en cada iteraci√≥n. Ten cuidado al usar bucles while para asegurarte de que la condici√≥n eventualmente se vuelva falsa; de lo contrario, puede resultar en un bucle infinito.\nConsidera usar el bucle while en las siguientes situaciones:\nRealizar repetidamente una acci√≥n hasta que se cumpla una condici√≥n espec√≠fica. Implementar validaci√≥n de entrada y pedir continuamente la entrada del usuario hasta que se proporcione datos v√°lidos. Interactuar con sistemas o procesos externos que requieren monitoreo continuo. Bucle repeat-while: Asegurando la primera ejecuci√≥n del c√≥digo #El bucle repeat-while es similar al bucle while, pero con una diferencia crucial: la condici√≥n se eval√∫a al final del bucle. Esto garantiza que el bloque de c√≥digo se ejecute al menos una vez, incluso si la condici√≥n es inicialmente falsa. Aqu√≠ hay un ejemplo:\nvar number = 10 repeat { print(number) number -= 2 } while number \u0026gt; 0 En este ejemplo, el bucle repeat-while imprime el valor de number y le resta 2 hasta que number se convierte en 0 o menos. A diferencia del bucle while, el bucle repeat-while ejecuta el bloque de c√≥digo primero y luego verifica la condici√≥n.\nEs adecuado para escenarios como:\nImplementar sistemas basados en men√∫s donde quieres asegurar la ejecuci√≥n antes de verificar las elecciones del usuario. Manejar la l√≥gica de juegos donde una acci√≥n debe realizarse al menos una vez antes de verificar las condiciones de finalizaci√≥n del juego. Repetir una operaci√≥n hasta que se cumpla una condici√≥n espec√≠fica. Conclusi√≥n #Entender las sentencias de control de flujo como for-in, while y repeat-`while es fundamental para cualquier desarrollador de iOS.\nEstas sentencias te permiten controlar el flujo del programa, iterar sobre colecciones y ejecutar c√≥digo condicionalmente. Al dominar estas sentencias de control de flujo, tendr√°s la capacidad de construir aplicaciones iOS m√°s eficientes y din√°micas.\nUtiliza estas sentencias sabiamente, prestando atenci√≥n a las condiciones de terminaci√≥n de los bucles para evitar bucles infinitos. Sigue explorando sus capacidades y experimentando con diferentes escenarios para mejorar tus habilidades de programaci√≥n.\n","date":"20 marzo 2023","permalink":"/posts/bucles-swift/","section":"Posts","summary":"En el desarrollo de iOS, las sentencias de control de flujo juegan un papel crucial en dirigir la ejecuci√≥n del c√≥digo.\nPermiten a los desarrolladores iterar sobre colecciones, realizar tareas repetitivas y controlar el comportamiento del programa basado en ciertas condiciones. En esta publicaci√≥n, nos sumergiremos en tres sentencias de control de flujo esenciales en Swift: for-in, while, y repeat-while.\nYa seas un desarrollador iOS junior o alguien que busca refrescar su conocimiento, entender estas sentencias es esencial para construir aplicaciones iOS robustas y eficientes.","title":"Explorando los bucles en Swift"},{"content":"Las colecciones son una de las estructuras de datos m√°s utilizadas cuando programas, por lo tanto, es extremadamente importante conocer los diferentes enfoques que dispones para trabajar con ellas.\nLos tipos de colecci√≥n son tipos de datos complejos, y Swift permite usar tres tipos de colecci√≥n: Arrays, Sets y Diccionarios para gestionar valores relacionados.\nLa fiabilidad de estas colecciones se basa en los tipos de valores y claves que puedes almacenar. Cuando creas una instancia de una colecci√≥n, necesitas confirmar el tipo de valores que gestiona. Esto significa que: no puedes almacenar diferentes tipos a los que definiste previamente, y puedes estar seguro del tipo de datos que recuperar√°s cuando manejas una colecci√≥n.\nAdem√°s, gracias a la inferencia de tipo, puedes especificar el tipo, o Swift inferir√° el tipo.\nMutabilidad de las colecciones #As√≠ como las variables y constantes, las colecciones pueden ser mutables o inmutables dependiendo de c√≥mo fueron creadas.\nSi almacenas un array, set o un diccionario en una variable, puedes mutar la colecci√≥n, porque puedes agregar, remover o cambiar un √∫nico o m√∫ltiples valores en estas colecciones.\nPero, si lo almacenas en una constante, no puedes a√±adir nuevos elementos o modificar los que fueron instanciados.\nDiferencias entre arrays, sets y diccionarios #Los arrays son colecciones ordenadas, donde las duplicaciones est√°n permitidas y los valores pueden ser accedidos por un √≠ndice num√©rico (posici√≥n en el array)\nLos sets son colecciones desordenadas donde las duplicaciones no est√°n permitidas, y los valores pueden ser iterados, pero no se pueden acceder por un √≠ndice o clave.\nLos diccionarios son colecciones desordenadas compuestas por asociaciones de clave-valor.\nFundamentos de los diferentes tipos de colecci√≥n #Arrays #Si quieres crear un array vac√≠o, necesitar√°s especificar el tipo de dato. Hay diferentes maneras de crear un array vac√≠o, este es un ejemplo.\nvar numbers = [Int]() Pero, si quieres crearlo con valores, no necesitas especificar los tipos. A continuaci√≥n, puedes ver c√≥mo crear un array de strings\nvar tutorials = [\u0026#34;SwiftUI\u0026#34;, \u0026#34;Combine\u0026#34;, \u0026#34;AsyncAwait\u0026#34;] Y, si necesitas acceder a un valor, debes indicar la posici√≥n del valor en el array. Pero, recuerda que el √≠ndice de las colecciones comienza por 0.\nlet firstCourse = tutorials[0] El c√≥digo anterior almacenar√° SwiftUI en la constante firstCourse.\nSets #Nuevamente, necesitar√°s especificar el tipo de dato para crear un set vac√≠o.\nvar numbers = Set\u0026lt;Int\u0026gt;() Crear un set con valores es similar a crear un array pero, en este caso, necesitar√°s especificar que es un set para no crear un array\nvar tutorials = [\u0026#34;SwiftUI\u0026#34;, \u0026#34;Combine\u0026#34;, \u0026#34;AsyncAwait\u0026#34;] Pero, en este caso, como los sets no tienen √≠ndice, no puedes usarlo para acceder a los datos. Al menos, puedes comprobar si el valor existe.\nvar swiftuiExists = tutorials.contains(\u0026#34;SwiftUI\u0026#34;) El c√≥digo anterior almacenar√° true en la variable swiftuiExists\nDiccionarios #Y, por √∫ltimo, puedes crear un diccionario vac√≠o especificando tanto el tipo de clave como el tipo de valor\nvar nameOfNumbers = [Int: String]() Para crear un diccionario con valores, tambi√©n es similar a un array, pero tienes que escribir la clave de cada valor. Recuerda que las claves deben ser √∫nicas.\nvar requirements = [\u0026#34;View\u0026#34;:\u0026#34;SwiftUI\u0026#34;, \u0026#34;Database\u0026#34;:\u0026#34;CoreData\u0026#34;, \u0026#34;AugmentedReality\u0026#34;:\u0026#34;ARKit\u0026#34;] Y, si quieres acceder a un valor, solo necesitas conocer el √≠ndice\nlet database = requirements[\u0026#34;Database\u0026#34;] En las pr√≥ximas publicaciones, escribir√© sobre m√©todos √∫tiles en tipos de colecci√≥n para gestionar arrays, sets y diccionarios.\n","date":"6 marzo 2023","permalink":"/posts/colecciones-swift/","section":"Posts","summary":"Las colecciones son una de las estructuras de datos m√°s utilizadas cuando programas, por lo tanto, es extremadamente importante conocer los diferentes enfoques que dispones para trabajar con ellas.\nLos tipos de colecci√≥n son tipos de datos complejos, y Swift permite usar tres tipos de colecci√≥n: Arrays, Sets y Diccionarios para gestionar valores relacionados.\nLa fiabilidad de estas colecciones se basa en los tipos de valores y claves que puedes almacenar.","title":"Colecciones en Swift"},{"content":"Esta publicaci√≥n es un complemento para la anterior sobre Cadenas en Swift.\nEn proyectos del mundo real, puedes almacenar muchas cadenas, pero es importante que sepas c√≥mo transformar esas cadenas para mostrarlas seg√∫n tu vista.\nPor esta raz√≥n, veamos los m√©todos habituales que puedes usar para esto.\nContar caracteres #Dado que una cadena es una colecci√≥n de caracteres, puedes usar un m√©todo muy com√∫n en Arrays: count()\nPuedes usarlo en una constante/variable o en una cadena.\nlet starWarsIntro = \u0026#34;A long time ago...\u0026#34; let numberOfCharacters = starWarsIntro.count() // numberOfCharacters value 18 let numberOfCharactersOfGreet = \u0026#34;Hello World!\u0026#34;.count() // numberOfCharactersOfGreet value is 12 Incluso puedes combinar valores en la misma cadena a trav√©s de la interpolaci√≥n de cadenas:\nlet plotTwist = \u0026#34;I am your father\u0026#34; print(\u0026#34;The number of character in \\(plotTwist) is \\(plotTwist).count()\u0026#34;) // It will print \u0026#34;The number of character in I am your father is 16\u0026#34; Insertar o eliminar #Tambi√©n es importante agregar o eliminar caracteres o subcadenas.\nInsertar #Para insertar, puedes:\nInsertar un car√°cter con el m√©todo .insert(_ newElement:at:) Insertar una subcadena con el m√©todo .insert(contentsOf:at:) En at, deber√°s escribir un √≠ndice. Puedes obtener m√°s informaci√≥n sobre los √≠ndices en Documentaci√≥n oficial de Swift - √çndices de cadenas\nvar warning = \u0026#34;we have a problem\u0026#34; warning.insert(contentsOf: \u0026#34;Houston, \u0026#34;, at: warning.startIndex) print(warning) // It will print \u0026#34;Houston, we have a problem\u0026#34; Eliminar #Similar a insertar, para eliminar Swift permite eliminar caracteres o subcadenas:\nEliminar un car√°cter con el m√©todo .remove(at:) Eliminar una subcadena con el m√©todo removeSubrange(_ bounds:) Ten cuidado de no salirte de los l√≠mites.\nvar greeting = \u0026#34;Hello World!\u0026#34; greeting.remove(at: greeting.index(before: greeting.endIndex)) print(greeting) // It will print \u0026#34;Hello World\u0026#34; Modificar cadenas #May√∫sculas y min√∫sculas #Los m√©todos que puedes usar para esto son .uppercased(), .lowercased() o .capitalized()\nEjemplos:\nlet lordOfTheRings = \u0026#34;A ring to rule them all\u0026#34; print(lordOfTheRings.uppercased()) // It will print \u0026#34;A RING TO RULE THEM ALL\u0026#34; print(lordOfTheRings.lowercased()) // It will print \u0026#34;a ring to rule them all\u0026#34; print(lordOfTheRings.capitalized) // It will print \u0026#34;A Ring To Rule Them All\u0026#34; Extraer una cadena a un array #Para este objetivo, puedes usar .components(separatedBy: \u0026quot; \u0026quot;)\nlet et = ‚ÄúE.T. phone home.‚Äù let etWords = et.components(separatedBy: \u0026#34; \u0026#34;) // etWords value is equal to [\u0026#34;E.T.\u0026#34;, \u0026#34;phone\u0026#34;, \u0026#34;home.\u0026#34;] Reemplazar ocurrencias #En este caso, un m√©todo √∫til es .replacingOccurrences(of:, with:), puedes reemplazar un car√°cter o una cadena con otro car√°cter o cadena\nlet darkKnight = \u0026#34;I am Batman\u0026#34; let coded = darkKnight.replacingOccurrences(of: \u0026#34;a\u0026#34;, with: \u0026#34;4\u0026#34;) // coded value is equal to \u0026#34;I 4m B4tm4n\u0026#34; ","date":"20 febrero 2023","permalink":"/posts/metodos-utiles-cadenas-swift/","section":"Posts","summary":"Esta publicaci√≥n es un complemento para la anterior sobre Cadenas en Swift.\nEn proyectos del mundo real, puedes almacenar muchas cadenas, pero es importante que sepas c√≥mo transformar esas cadenas para mostrarlas seg√∫n tu vista.\nPor esta raz√≥n, veamos los m√©todos habituales que puedes usar para esto.\nContar caracteres #Dado que una cadena es una colecci√≥n de caracteres, puedes usar un m√©todo muy com√∫n en Arrays: count()\nPuedes usarlo en una constante/variable o en una cadena.","title":"Useful String Methods in Swift"},{"content":"Cuando guardas un texto en una constante o una variable, est√°s guardando una cadena en Swift. Adem√°s, puedes ver una cadena como una serie de caracteres. Por esa raz√≥n, puedes acceder al contenido de una cadena de varias maneras, como una Colecci√≥n (Array, por ejemplo) de caracteres.\nInicializar una Cadena #Un literal de cadena es un texto escrito con comillas dobles al principio y al final. Entonces, si necesitas guardar un texto en una constante o una variable, solo debes asignar un literal de cadena a ella.\nlet coach = \u0026#34;Ted Lasso\u0026#34; var team = \u0026#34;AFC Richmond\u0026#34; NOTA: Es fundamental recordar que las cadenas distinguen entre may√∫sculas y min√∫sculas. Por lo tanto, \u0026ldquo;una cadena simple\u0026rdquo; es diferente de \u0026ldquo;Una cadena simple\u0026rdquo;.\nConcatenando cadenas #Si necesitas guardar el valor de dos cadenas en otra constante o variable, puedes concatenarlas.\nEs tan f√°cil como usar el operador + entre los dos valores cuando tienes que asignarlo.\nlet name = \u0026#34;Michael\u0026#34; let lastName = \u0026#34;Scott\u0026#34; let funnyBoss = name + lastName Otra forma es usar el operador += para agregar texto a una cadena previamente inicializada.\nvar spy = \u0026#34;Bond\u0026#34; spy += \u0026#34;, James Bond\u0026#34; En el ejemplo anterior, el valor final de spy es Bond, James Bond\nY, como una String es una Colecci√≥n de caracteres, tambi√©n puedes usar el m√©todo .append()\nvar greet = \u0026#34;Hello, world\u0026#34; greet.append(\u0026#34;!\u0026#34;) En el √∫ltimo c√≥digo, el valor de saludo es Hello, world!\nInterpolaci√≥n de cadenas #Pero quiz√°s la caracter√≠stica m√°s utilizada en las cadenas podr√≠a ser la interpolaci√≥n de cadenas. Permite usar valores de constantes o variables dentro de una cadena.\nEn este caso, puedes hacerlo escribiendo el nombre de la constante o variable, dentro de par√©ntesis \u0026ldquo;()\u0026rdquo;, y comenzando con una barra invertida \u0026ldquo;\u0026quot;. Es decir, \\(nombreDeVariable)\nlet name = \u0026#34;Forest\u0026#34; let fullName = \u0026#34;Forest Gump\u0026#34; let introduction = \u0026#34;Hello, I am \\(name), \\(fullName)\u0026#34; El valor final de introduction es \u0026quot;Hello, I am Forest, Forest Gump\u0026quot;\nCadena de varias l√≠neas #Para terminar (aunque no se utiliza a menudo en aplicaciones del mundo real), tal vez a veces necesites guardar textos m√°s largos en una cadena, y podr√≠a ser dif√≠cil leer el valor para otros programadores o para ti mismo. En este caso, puedes usar una cadena de varias l√≠neas.\nPara guardar una cadena de varias l√≠neas, solo necesitas escribir tres comillas al principio, y terminar con otras tres en una sola l√≠nea. Por ejemplo:\nlet text = \u0026#34;\u0026#34;\u0026#34; To be, or not to be, that is the question: Whether \u0026#39;tis nobler in the mind to suffer The slings and arrows of outrageous fortune, Or to take arms against a sea of troubles, And by opposing end them? To die, to sleep; \u0026#34;\u0026#34;\u0026#34; First triple double quotes doesn\u0026rsquo;t need to be in a single line, but it helps to focus in text value.\nEl primer conjunto de tres comillas dobles no necesita estar en una sola l√≠nea, pero ayuda a centrarse en el valor del texto. Puedes ver m√©todos √∫tiles en la publicaci√≥n. M√©todos √∫tiles para cadenas\n","date":"6 febrero 2023","permalink":"/posts/cadenas-swift/","section":"Posts","summary":"Cuando guardas un texto en una constante o una variable, est√°s guardando una cadena en Swift. Adem√°s, puedes ver una cadena como una serie de caracteres. Por esa raz√≥n, puedes acceder al contenido de una cadena de varias maneras, como una Colecci√≥n (Array, por ejemplo) de caracteres.\nInicializar una Cadena #Un literal de cadena es un texto escrito con comillas dobles al principio y al final. Entonces, si necesitas guardar un texto en una constante o una variable, solo debes asignar un literal de cadena a ella.","title":"Swift Strings"},{"content":"La programaci√≥n ha sido utilizada a menudo para procesar n√∫meros y obtener resultados dif√≠ciles de calcular para los humanos: distancias del universo, radios de planetas, pi\u0026hellip;\nAs√≠, es parte del aprendizaje fundamental, en Swift en particular y en programaci√≥n en general.\nB√°sicamente hay 2 tipos de n√∫meros en Swift: Enteros y n√∫meros de coma flotante. Cada uno representa un rango diferente y se utiliza para diferentes objetivos.\nEnteros #Un n√∫mero entero (tambi√©n llamado int, abreviado) es posiblemente el n√∫mero m√°s utilizado. Podr√≠amos decir que es el m√°s simple, porque no tiene componente fraccional.\nPuede ser positivo, cero o negativo. Por ejemplo, n√∫meros enteros son: 5, -3, 99, -256\u0026hellip;\nAdem√°s, Swift proporciona enteros con signo y sin signo para 8,16, 32 y 64 bits. Siguiendo la convenci√≥n de nombres de C, el tipo de n√∫mero sin signo de 8 bits es UInt8, mientras que el de 16 bits con signo es Int16. Pero, no se utiliza frecuentemente en la mayor√≠a de las aplicaciones desarrolladas.\nRango de enteros #Depende del n√∫mero de bits, pero cada uno tiene un n√∫mero m√°ximo y m√≠nimo para almacenar. Puedes comprobarlo en la siguiente lista.\nUInt8: de 0 a 255 UInt16: de 0 a 65535 UInt32: de 0 a 4294967295 UInt64: de 0 a 18446744073709551615 Int8: de -128 a 127 Int16: de -32768 a 32767 Int32: de -2147483648 a 2147483647 Int64: de -9223372036854775808 a 9223372036854775807 Pero, si no recuerdas los valores, puedes usar los m√©todos .max o .min\nlet minValue = Int.min //minValue is equal to let maxValue = Int.max //maxValue is equal to N√∫meros de coma flotante #A diferencia de los enteros, los n√∫meros de coma flotante tienen un componente fraccional. Pero, al igual que los enteros, pueden ser positivos o negativos. Existen dos tipos de n√∫meros de punto flotante con signo\nDoble #Los n√∫meros Double representan un n√∫mero de punto flotante de 64 bits y tienen una precisi√≥n de al menos 15 d√≠gitos decimales.\nFlotante #Los n√∫meros Float representan un n√∫mero de punto flotante de 32 bits y tienen una precisi√≥n de al menos 6 d√≠gitos decimales.\nNOTA: Necesitar√°s Double o Float dependiendo de m√∫ltiples factores, pero si cualquiera de los dos fuera apropiado, la documentaci√≥n de Swift recomienda usar Double.\n","date":"30 enero 2023","permalink":"/posts/numeros-swift/","section":"Posts","summary":"La programaci√≥n ha sido utilizada a menudo para procesar n√∫meros y obtener resultados dif√≠ciles de calcular para los humanos: distancias del universo, radios de planetas, pi\u0026hellip;\nAs√≠, es parte del aprendizaje fundamental, en Swift en particular y en programaci√≥n en general.\nB√°sicamente hay 2 tipos de n√∫meros en Swift: Enteros y n√∫meros de coma flotante. Cada uno representa un rango diferente y se utiliza para diferentes objetivos.\nEnteros #Un n√∫mero entero (tambi√©n llamado int, abreviado) es posiblemente el n√∫mero m√°s utilizado.","title":"N√∫meros en Swift"},{"content":"La programaci√≥n es una forma de gestionar datos y, normalmente, es necesario guardar varios valores temporalmente: para hacer uso de ellos despu√©s de otras operaciones, para mostrarlos, transformarlos\u0026hellip;\nPor este motivo, igual que otros lenguajes de programaci√≥n, Swift es capaz de almacenar valores en constantes y variables.\nGracias a ellas, puedes asociar un nombre que elijas a un valor.\nConstantes #Un valor constante se guarda en un espacio de memoria y no se puede modificar. Una vez que un valor se establece en una constante, permanece inmutable.\nC√≥mo declarar una constante #Para declarar una constante debes comenzar con la palabra reservada let, seguida del nombre que elijas. Luego, debes usar el operador = y asignar un valor.\nEn el siguiente ejemplo, let es la palabra reservada para constantes, survivor el nombre de la constante y el valor asignado a survivor es Jack Shepard.\nlet survivor = ‚ÄúJack Shepard‚Äù El valor est√° entre comillas dobles porque es un tipo de valor cadena o String. Puedes leer sobre Strings en la documentaci√≥n oficial: Cadenas y caracteres\n¬øSabes por qu√© Swift usa let en lugar de const o similar a otros idiomas? Viene del mundo de las matem√°ticas en ingl√©s, donde dicen cosas como:\nlet x be equal to 5.\nVariables #Una variable es un valor que puedes modificar una vez declarado. Por lo que es un valor mutable.\nC√≥mo declarar una variable #Para declarar una variable, la estructura es la misma que una constante, pero debes usar la palabra reservada var\nPor lo que, para declarar una variable debes escribir\nvar videogame = ‚ÄúMetal Gear Solid‚Äù Ok, pero si queremos cambiar el valor de var, ¬øc√≥mo deber√≠amos hacerlo? F√°cil, s√≥lo necesitas asignar un nuevo valor y no escribir la palabra reservada var.\nvideogame = ‚ÄúUncharted‚Äù Nombrar una constante, varialbe o valor #Puedes utilizar casi cualquier car√°cter para el nombre de una constante o variable, incluidos los caracteres Unicode. Lo que significa que puedes usar, por ejemplo, emojis.\nPero es algo que no recomiendo. ¬øPor qu√©? Porque el nombre de una constante o de una variable, debe explicar sin dejar lugar a dudas lo que se guarda en su interior.\nPor ejemplo, ¬øque significa el valor 10?\nlet times = 10 let numberOfTimesIHaveSeenBackToTheFutureTrilogy = 10 En el segundo caso caso es m√°s f√°cil saberlo.\nConclusi√≥n #Por lo tanto, no te preocupes por la cantidad de caracteres del nombre. Es m√°s recomendable utilizar un nombre grande (pero descriptivo) que utilizar otro m√°s corto que no especifique qu√© almacena. Y, hoy en d√≠a, los IDEs se encargan de autocompletar los nombres, as√≠ que no ser√° tan dif√≠cil escribirlos üòâ\n","date":"16 enero 2023","permalink":"/posts/constantes-variables-swift/","section":"Posts","summary":"La programaci√≥n es una forma de gestionar datos y, normalmente, es necesario guardar varios valores temporalmente: para hacer uso de ellos despu√©s de otras operaciones, para mostrarlos, transformarlos\u0026hellip;\nPor este motivo, igual que otros lenguajes de programaci√≥n, Swift es capaz de almacenar valores en constantes y variables.\nGracias a ellas, puedes asociar un nombre que elijas a un valor.\nConstantes #Un valor constante se guarda en un espacio de memoria y no se puede modificar.","title":"Constantes y variables para guardar datos"},{"content":"¬°Hola! Hoy estoy muy contento porque, he refactorizado mi blog üòâ\nEsta no es mi primera experiencia escribiendo en mi blog pero, 2022 fue un a√±o con cambios y nuevos desaf√≠os en mi vida laboral, as√≠ que, decid√≠ reiniciar mi blog para alinearlo con lo que estoy haciendo en mi d√≠a a d√≠a.\nPor esta raz√≥n, este es mi primer post, pero solo en esta nueva versi√≥n de mi blog.\nSobre m√≠ #Si tengo que hablar de m√≠ en una frase, me gusta decir que soy un apasionado de la programaci√≥n y la tecnolog√≠a.\nActualmente, trabajo como Desarrollador iOS en Hiberus, una consultora tecnolog√≠a fundada en Espa√±a, pero que crece r√°pidamente y est√° abriendo nuevas oficinas en lugares como Berl√≠n, Londres, M√©xico DF o Miami.\nMi experiencia laboral ha estado principalmente enfocada en IT y, adem√°s de en programaci√≥n, tengo experiencia previa trabajando como QA o DevOps.\nDebido a que soy un entusiasta de los productos de Apple, decid√≠ aprender Swift y especializarme en el desarrollo de aplicaciones para su ecosistema. No solo para dispositivos iOS, sino tambi√©n para MacOS o el resto de los sistemas operativos de Apple.\nMi vida personal #Nac√≠ en Valencia (Espa√±a), donde vivo actualmente. Y nac√≠ en los 80‚Äôs, la √©poca del Spectrum, Atari y las primeras videoconsolas de Sega o Nintendo. As√≠ que crec√≠ y disfrut√© jugando videojuegos con mi Sega Megadrive, y viendo dibujos animados como He-man, Oliver y Benji o Bola de Drag√≥n.\nSoy el orgulloso padre de Lucas üë∂üèª, mi hijo de 3 a√±os que se ha convertido en el CEO de casa, y el orgulloso marido de Lorena, la mejor compa√±era de vida que podr√≠a tener. Una mujer maravillosa, con un poder especial para tratar con la infancia (Y conmigo üòÖ)\nActualmente, paso mis horas fuera del trabajo con mi familia o mis aficiones, como: disfrutar de series de TV, ver F√≥rmula 1, leer o jugar al ajedrez.\nPor qu√© escribo en este blog #Conocimiento #La primera raz√≥n (y la m√°s importante) es para aprender. Para m√≠, hay 3 niveles de conocimiento:\n1¬∫: Cuando alguien te ense√±a algo, o lo aprendes viendo un video, leyendo un libro\u0026hellip; 2¬∫: Cuando eres capaz de hacer lo que has aprendido. 3¬∫: Cuando eres capaz de ense√±ar a alguien lo que sabes. Y, por esta raz√≥n, escribir en un blog me ayuda a aprender ense√±ando a otros.\nPara ayudar #La segunda, es ayudar a otros en lo que hoy disfruto cada vez m√°s: programar. Creo que a todos les gusta ayudar a los dem√°s, y adem√°s, esta es mi manera de extender la ayuda que recibo de otros.\nExpresar mi opini√≥n #Otra raz√≥n es que, como Desarrollador iOS, necesito tener un profundo entendimiento sobre todo el ecosistema de Apple, as√≠ que, este ser√° un lugar para organizar mis pensamientos sobre las noticias, productos, eventos como la WWDC\u0026hellip; pero siempre enfocado en la programaci√≥n.\nPracticar ingl√©s #Y la √∫ltima raz√≥n, (pero no menos importante), practicar escribir documentaci√≥n t√©cnica en ingl√©s. Mi lengua materna es el espa√±ol, pero la globalizaci√≥n y el trabajo remoto han abierto muchas oportunidades. Y el ingl√©s es hoy el idioma clave para aprender y trabajar.\nSi quieres saber m√°s sobre m√≠, no dudes en consultar mis enlaces de redes sociales\n¬°As√≠ que, espero que disfrutes de mis posts! üôÇ\n","date":"2 enero 2023","permalink":"/posts/mi-nuevo-primer-post/","section":"Posts","summary":"¬°Hola! Hoy estoy muy contento porque, he refactorizado mi blog üòâ\nEsta no es mi primera experiencia escribiendo en mi blog pero, 2022 fue un a√±o con cambios y nuevos desaf√≠os en mi vida laboral, as√≠ que, decid√≠ reiniciar mi blog para alinearlo con lo que estoy haciendo en mi d√≠a a d√≠a.\nPor esta raz√≥n, este es mi primer post, pero solo en esta nueva versi√≥n de mi blog.","title":"Mi (nuevo) primer post"},{"content":"","date":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags"}]