[{"content":"If I have to talk about me in a sentence, I like to say that I am a passionate about programming and tech world.\nNowadays, I work as iOS Developer at Hiberus, a global consultancy company founded in Spain, but growing quickly and opening new offices in places such as Berl√≠n, London, M√©xico DF or Miami.\nBut, my work experience have been mainly focused in IT. Besides programming, I have previous experience working as QA or DevOps engineer.\nRecently, because I\u0026rsquo;m a enthusiastic user of Apple products, I decided to learn Swift, and specialize in their ecosystem development. Not only for iOS devices, but for MacOS or the rest of Apple operating systems.\nMy personal life #I was born in Valencia (Spain), where I live actually. and I was born at 80‚Äôs, the age of Spectrum, Atari and the first Sega\u0026rsquo;s or Nintendo videoconsoles. So, I grow up and enjoyed play videogames with my Sega Megadrive, watch cartoons as He-man, Dragon Ball or Captain Tsubasa.\nI\u0026rsquo;m the proud father of Lucas üë∂üèª, my 3 years son that became the home CEO, and the proud husband of Lorena, the best life companion that I could have. A wonderfull woman, with a special power to treat with the childhood (And with me üòÖ)\nNowadays, I spend my non-working hours with my family or my hobbies, such as: enjoying TV Series, playing chess or watching Formula 1 races.\n","date":"6 March 2024","permalink":"/en/about/","section":"Oscar Moreno | iOS Developer Ô£ø","summary":"If I have to talk about me in a sentence, I like to say that I am a passionate about programming and tech world.","title":"About"},{"content":"","date":null,"permalink":"/en/","section":"Oscar Moreno | iOS Developer Ô£ø","summary":"","title":"Oscar Moreno | iOS Developer Ô£ø"},{"content":"","date":null,"permalink":"/en/posts/","section":"Posts","summary":"","title":"Posts"},{"content":"Closures are a fundamental concept in Swift. They are powerful tools that allow you to define and manipulate blocks of code as first-class citizens. In this article, we\u0026rsquo;ll explore closure expressions, trailing closures, capturing values, and the idea that closures are type references.\nClosure Expressions #A closure expression is a self-contained block of code that can be passed around and used in your code, just like any other variable. In Swift, you can define closures using the {} braces. Here\u0026rsquo;s a simple example:\nlet greet = { print(\u0026#34;Hello, world!\u0026#34;) } Trailing Closures #Trailing closures are a convenient way to include a closure expression as the last argument of a function. This makes your code more readable. Suppose you have a function that takes a closure as an argument:\nfunc performAction(action: () -\u0026gt; Void) { // Perform some setup action() } // Using a trailing closure performAction { print(\u0026#34;Action performed!\u0026#34;) } Capturing Values #Closures can capture and store references to variables and constants from the surrounding context in which they are defined. This means they can \u0026ldquo;remember\u0026rdquo; and manipulate those values even if they are no longer in scope. Here\u0026rsquo;s an example:\nfunc makeIncrementer(incrementAmount: Int) -\u0026gt; () -\u0026gt; Int { var total = 0 let incrementer: () -\u0026gt; Int = { total += incrementAmount return total } return incrementer } // Usage example: let incrementByTwo = makeIncrementer(incrementAmount: 2) let incrementByFive = makeIncrementer(incrementAmount: 5) print(incrementByTwo()) // Output: 2 print(incrementByTwo()) // Output: 4 print(incrementByTwo()) // Output: 6 print(incrementByFive()) // Output: 5 print(incrementByFive()) // Output: 10 print(incrementByFive()) // Output: 15 In this example, we define the makeIncrementer function, which takes an incrementAmount as an argument and returns a closure of type () -\u0026gt; Int. Each time you call the returned closure, it increments the total variable by the specified incrementAmount and returns the updated total. We create two separate closures, incrementByTwo and incrementByFive, each with its own captured total and `incrementAmount values. When we call these closures multiple times, you can see how they maintain their individual state and increment by their respective amounts.\nClosures Are Type References #Closures are more than just blocks of code; they are also type references. You can declare a closure type, and variables of that type can hold closures with matching signatures. This allows you to define functions that take closures as parameters or return them as results, providing flexibility and reusability in your code.\nConclusion #In summary, closures are a crucial concept in Swift, and understanding them is essential for any iOS developer. They provide a flexible way to work with code and data, whether you\u0026rsquo;re creating simple functions or advanced asynchronous operations. By mastering closure expressions, trailing closures, capturing values, and recognizing that closures are type references, you\u0026rsquo;ll be better equipped to write efficient and readable Swift code.\n","date":"5 September 2023","permalink":"/en/posts/closures-swift/","section":"Posts","summary":"Closures are a fundamental concept in Swift.","title":"Understanding Closures in Swift"},{"content":"As developers, we often manage situations where we need to work with functions in our iOS applications. Functions are an integral part of the Swift programming language and provide us with a powerful toolset to build flexible and modular code. In this article, we will explore the concept of using functions types and how it can benefit our development process.\nDetermining the Function Type #In Swift, functions are considered first-class citizens, which means they can be assigned to variables or constants and can also be used as types. To determine the type of a function, we can use the function\u0026rsquo;s signature. The signature consists of the parameter types and return type. Let\u0026rsquo;s consider an example:\nfunc add(_ a: Int, _ b: Int) -\u0026gt; Int { return a + b } The type of this function can be represented as (Int, Int) -\u0026gt; Int, where (Int, Int) represents the parameter types and Int represents the return type.\nUsing Functions Types as Parameters #One of the advantages of using functions types is the ability to pass them as parameters to other functions. This enables us to create higher-order functions that can accept different behaviors based on the functions provided. Let\u0026rsquo;s take an example where we have a function that applies a given operation on an array of integers:\nfunc applyOperation(_ numbers: [Int], operation: (Int) -\u0026gt; Int) -\u0026gt; [Int] { var result = [Int]() for number in numbers { let transformedNumber = operation(number) result.append(transformedNumber) } return result } In the above code, the applyOperation function takes an array of integers and a function operation as parameters. The operation parameter represents a function that takes an integer and returns an integer. We can use this higher-order function to perform various operations on our array of numbers.\nUsing Functions Types to Return #Another powerful aspect of using functions types is the ability to use them as output return. This enables us to create functions that dynamically generate and return other functions based on certain conditions or requirements. Let\u0026rsquo;s consider an example:\nfunc operationFactory() -\u0026gt; (Int) -\u0026gt; Int { if condition { return { number in number * 2 } } else { return { number in number / 2 } } } In this example, the operationFactory function returns a function of type (Int) -\u0026gt; Int based on a certain condition. We can utilize this behavior to create more flexible and adaptable code.\nConclusion #Using functions types in iOS development provides us with a powerful mechanism to create modular and flexible code. By treating functions first-class citizens, we can pass them as parameters to other functions, use them as return types, and dynamically generate them when needed. This approach enhances code reusability, promotes modularity, and allows for the creation of higher-order functions. By leveraging these capabilities, developers can build robust and adaptable iOS applications. So, next time you find yourself in a situation where you need to incorporate different behaviors in your code, consider using functions types for a more elegant solution.\nHappy coding! üë®üèª‚Äçüíª\n","date":"10 July 2023","permalink":"/en/posts/using-function-types-swift/","section":"Posts","summary":"As developers, we often manage situations where we need to work with functions in our iOS applications.","title":"Using Function Types in Swift"},{"content":"Understanding the intricacies of function argument labels and parameter names is essential to harness the full power of the Swift programming language. In this article, we will explore these concepts with a focus on simplicity, catering to developers with limited experience in function creation. So, let\u0026rsquo;s dive in!\nFunction Argument Labels #Argument labels provide a descriptive context when calling a function, making the code more expressive and readable. In Swift, argument labels are specified before the parameter names and are separated by a space. Let\u0026rsquo;s consider an example where we calculate the score of a video game level:\nfunc calculateScore(forLevel level: Int) -\u0026gt; Int { // Function body goes here } Here, forLevel is the argument label, and level is the parameter name. When calling this function, we use the argument label to provide clarity:\nlet finalScore = calculateScore(forLevel: 5) By using argument labels, we can convey the purpose of each parameter, enhancing the understanding of our code.\nAlso, you can omit an argument label. You simply must write an underscore instead an argument label:\nfunc addStamina(_ stamina: Int) -\u0026gt; Int { // Function body goes here } And you will only need to pass the value when you call the function.\nlet totalStamina = addStamina(100) Default Parameter Values #In Swift, we have the flexibility to assign default values to function parameters. This means that when calling a function, we can choose to omit specific arguments, and the default values will be used instead. Continuing with our video game theme, let\u0026rsquo;s modify our previous function to include a default value for the bonusPoints parameter:\nfunc calculateScore(level: Int, bonusPoints: Int = 500) -\u0026gt; Int { return level * bonusPoints } Now, we can call the function and use the two parameters but, if we call the function without providing a value for bonusPoints, it will automatically default to 500:\nlet totalScore = calculateScore(level: 2, bonusPoints: 100) // totalScore is equal to 200 let finalScore = calculateScore(level: 5) // finalScore is equal to 2500 Variadic Parameters #Sometimes, we may encounter situations where the number of function arguments is not fixed. To handle such scenarios, Swift allows us to use variadic parameters. These parameters can accept zero or more values of a specified type. To demonstrate, imagine a function that calculates the total score of multiple video games:\nfunc calculateTotalScore(scores: Int...) -\u0026gt; Int { // Function body goes here } Here, scores is a variadic parameter. We can pass any number of arguments separated by commas when calling the function:\nlet totalScore = calculateTotalScore(scores: 100, 250, 500, 750) In-Out Parameters #Lastly, Swift provides the in-out parameter modifier, which allows a function to modify the value of a variable from outside its own scope. In-out parameters are prefixed with the \u0026ldquo;inout\u0026rdquo; keyword. Consider a scenario where we need to update the health points of a game character:\nfunc updateHealthPoints(_ hp: inout Int) { // Function body goes here } To pass a variable as an in-out parameter, we prepend an ampersand before the variable name:\nvar characterHP = 100 updateHealthPoints(\u0026amp;characterHP) Conclusion #In this article, we\u0026rsquo;ve covered the fundamentals of function argument labels and parameter names in Swift. We explored the usage of argument labels, default parameter values, variadic parameters, and in-out parameters. By mastering these concepts, you\u0026rsquo;ll be equipped to write clean, expressive, and flexible code in your iOS projects. Keep practicing and incorporating these techniques into your development journey, and soon could be creating remarkable retro video games that leave players nostalgic for the golden age of gaming.\nHappy coding! üë®üèª‚Äçüíª\n","date":"26 June 2023","permalink":"/en/posts/function-argument-labels-parameters/","section":"Posts","summary":"Understanding the intricacies of function argument labels and parameter names is essential to harness the full power of the Swift programming language.","title":"Function Argument Labels and Parameter Names"},{"content":"Working as iOS developers, we often come across scenarios where we need to return multiple values from a function. Swift provides us with two useful approaches to achieve this: using tuples and collections. In this article, we will explore both methods and understand when to use each one.\nUsing Tuples #Tuples are lightweight data structures that allow us to group multiple values together. They provide a simple way to return multiple values from a function. Consider the following example:\nfunc getMovieDetails(movieId: Int) -\u0026gt; (String, String) { // Retrieve movie details from the database let movieTitle = \u0026#34;Back to the Future\u0026#34; let director = \u0026#34;Robert Zemeckis\u0026#34; return (movieTitle, director) } let movieDetails = getMovieDetails(movieId: 1) print(\u0026#34;Title: \\(movieDetails.0)\u0026#34;) print(\u0026#34;Director: \\(movieDetails.2)\u0026#34;) In this example, the getMovieDetails function returns a tuple containing the movie title and director. We can access individual values using dot syntax and the corresponding index. Tuples are handy when we have a fixed number of values to return.\nUsing Collections #Collections, such as arrays or dictionaries, offer a more flexible approach for returning multiple values. Let\u0026rsquo;s see how we can modify our previous example to utilize an array:\nfunc getMovieDetails(movieId: Int) -\u0026gt; [String] { // Retrieve movie details from the database let movieTitle = \u0026#34;Back to the Future\u0026#34; let releaseYear = 1985 let director = \u0026#34;Robert Zemeckis\u0026#34; return [movieTitle, String(releaseYear), director] } let movieDetails = getMovieDetails(movieId: 1) print(\u0026#34;Title: \\(movieDetails[0])\u0026#34;) print(\u0026#34;Release Year: \\(movieDetails[1])\u0026#34;) print(\u0026#34;Director: \\(movieDetails[2])\u0026#34;) Here, the getMovieDetails function returns an array of strings, containing the movie title, release year (converted to a string), and director. We access the values by their respective indices. Collections are advantageous when we have a varying number of values to return or if the number of values may change in the future.\nChoosing Between Tuples and Collections #When deciding between tuples and collections, consider the following guidelines:\nUse tuples when you have a fixed number of values that won\u0026rsquo;t change. Use collections when the number of values may vary or when you need to easily add or remove values. Conclusion #Returning multiple values from a function in Swift is essential in many programming scenarios. By utilizing tuples or collections, we can efficiently handle these situations. Tuples are suitable for returning a fixed number of values, while collections offer flexibility when the number of values may vary. Understanding these techniques empowers us to write cleaner, more expressive code.\nRemember to experiment with these concepts using real-world examples and explore how they can be applied to your own projects.\nHappy coding! üë®üèª‚Äçüíª\n","date":"12 June 2023","permalink":"/en/posts/returning-multiple-values-from-functions/","section":"Posts","summary":"Working as iOS developers, we often come across scenarios where we need to return multiple values from a function.","title":"Returning Multiple Values from a Function: Tuples vs. Collections"},{"content":"As a developer, it\u0026rsquo;s essential to understand the fundamental concepts of programming. One such concept is functions, which play a crucial role in organizing and reusing code. In this article, we\u0026rsquo;ll explore the basics of functions in Swift. Whether you\u0026rsquo;re a beginner or looking for a refresher, this guide will help you grasp the essentials of functions in a simple and straightforward manner.\nWhat are Functions? #A function is a block of code that performs a specific task. It allows you to encapsulate a set of instructions under a meaningful name, making your code more organized and modular. Functions can accept input values, called parameters, and return output values. They provide a way to break down complex logic into smaller, manageable parts.\nSyntax and Structure: #In Swift, a function declaration begins with the func keyword, followed by the function name and parentheses. If the function accepts parameters, they are specified within the parentheses. The return type is indicated by an arrow -\u0026gt; followed by the type. Here\u0026rsquo;s an example:\nfunc greet(name: String) -\u0026gt; String { return \u0026#34;Hello, \\(name)!\u0026#34; } In this example, we have a function named \u0026ldquo;greet\u0026rdquo; that accepts a parameter called \u0026ldquo;name\u0026rdquo; of type String. It returns a String value containing a greeting message with the provided name.\nExample Scenario #Let\u0026rsquo;s say we\u0026rsquo;re building an app related to TV shows. We can create a function to recommend a show based on the user\u0026rsquo;s preferences. Here\u0026rsquo;s an example:\nfunc recommendShow(userPreference: String) -\u0026gt; String { if userPreference == \u0026#34;action\u0026#34; { return \u0026#34;You should watch \u0026#39;Game of Thrones\u0026#39;!\u0026#34; } else if userPreference == \u0026#34;comedy\u0026#34; { return \u0026#34;I recommend \u0026#39;Friends\u0026#39;!\u0026#34; } else { return \u0026#34;I\u0026#39;m sorry, I don\u0026#39;t have a recommendation for your preference.\u0026#34; } } When calling this function with different preferences, such as \u0026ldquo;action\u0026rdquo; or \u0026ldquo;comedy,\u0026rdquo; it will return an appropriate recommendation. If the user preference doesn\u0026rsquo;t match any specific case, a default message is returned.\nWhen to Use Functions #Functions are particularly useful in the following scenarios:\nReusability #If you find yourself performing the same task or calculation at multiple places in your code, it\u0026rsquo;s a good indication to create a function for that task. This way, you can reuse the code without duplicating it.\nModularity #Functions help in organizing code into smaller, self-contained units. This improves code readability and maintainability.\nAbstraction #By encapsulating complex logic within functions, you can abstract away the implementation details and focus on the higher-level functionality.\nConclusion #Understanding the basics of functions is essential for any developer. They allow you to write clean, reusable code and improve the structure of your programs. In this article, we explored the syntax and structure of functions in Swift, along with an example scenario using TV show preferences. By leveraging functions effectively, you can create more modular and maintainable code.\nHappy coding! üë®üèª‚Äçüíª\n","date":"29 May 2023","permalink":"/en/posts/understanding-basics-functions/","section":"Posts","summary":"As a developer, it\u0026rsquo;s essential to understand the fundamental concepts of programming.","title":"Understanding the Basics of Swift Functions"},{"content":"In Swift, there are various language constructs that make programming more efficient and robust.\nOne such construct is the defer statement, which allows developers to execute a block of code later in the program\u0026rsquo;s flow. This article aims to explain how defer works in Swift, provide examples of its usage, and highlight the scenarios in which it can be beneficial.\nIs used to define a block of code that is executed when the current scope is exited, regardless of how the scope is exited‚Äîwhether through a return statement, an error, or a break. Have in mind that, in case your app stops running because a runtime error or a crash, deferred code doesn\u0026rsquo;t execute.\nIt ensures that specific cleanup or finalization code is executed before leaving the scope, regardless of the execution path.\nSyntax of Defer #The syntax is simple. You begin with the keyword defer followed by the code block you want to execute later. Here\u0026rsquo;s an example:\nfunc processFile() { print(\u0026#34;Opening file...\u0026#34;) defer { print(\u0026#34;Closing file...\u0026#34;) } // Code for processing the file goes here // This code will be executed before the file is closed } In this example, the \u0026ldquo;Opening file\u0026hellip;\u0026rdquo; message is printed first, and then the defer block is defined.\nThe defer block contains the code that will be executed at the end, just before leaving the scope. In this case, the message \u0026ldquo;Closing file\u0026hellip;\u0026rdquo; will always be printed, ensuring the file is properly closed.\nUse Cases of Defer #The defer statement is particularly useful in scenarios where you need to ensure resources are properly released or actions are performed regardless of the execution path. Some common use cases include:\nResource Cleanup #When working with files, databases, or network connections, you can use the defer statement to ensure that resources are released, connections are closed, or transactions are committed.\nLock Release #If you acquire a lock or a semaphore, the defer statement can help release it even if an exception occurs or if the code block is exited prematurely.\nState Restoration #In complex workflows or asynchronous operations, you can use the defer statement to restore the state to a consistent or initial condition before exiting the scope.\nLogging and Debugging #The defer statement can be employed to log or report information for debugging purposes before leaving the current scope.\nConclusion #The defer statement in Swift is a powerful language construct that allows developers to defer the execution of code until the end of a scope. It ensures that specific cleanup or finalization code is executed regardless of how the scope is exited.\nBy leveraging the defer statement, developers can write more resilient and organized code, making it easier to handle resource cleanup and ensure the desired behavior in various scenarios.\nRemember, the defer statement can be particularly handy when working with resources, locks, state management, and debugging needs.\n","date":"15 May 2023","permalink":"/en/posts/discovering-defer-swift/","section":"Posts","summary":"In Swift, there are various language constructs that make programming more efficient and robust.","title":"Discovering Defer in Swift"},{"content":"In iOS programming, one powerful construct that helps streamline code readability and improve control flow is the guard statement. This statement acts as a gatekeeper, allowing us to gracefully handle exceptional scenarios and exit early from a code block.\nIn this article, you will discover the benefits of the guard statement, explore its usage, and provide examples to illustrate its effectiveness.\nUnderstanding the guard Statement #The guard statement serves as a conditional early exit mechanism in Swift, the programming language for iOS development.\nIt allows us to check for specific conditions and ensure that they are met before continuing the execution of a code block.\nIf the conditions aren\u0026rsquo;t met, the guard statement terminates the current scope, enabling us to handle failure scenarios elegantly.\nThe syntax for a guard statement is as follows:\nguard condition else { // Code to handle the failure case // Return, throw, or perform any necessary cleanup } // Code to execute when the condition is successfully met When a guard statement is encountered, the specified condition is evaluated.\nIf the condition evaluates to false, the code within the else block is executed.\nThis block typically contains code to handle the failure case, such as returning from the function, throwing an error, or performing any necessary cleanup. If the condition evaluates to true, the code continues executing normally after guard.\nEarly Exit for Unacceptable Conditions #guard statements can help avoid nested conditional statements by providing early exits for conditions that are considered unacceptable. This simplifies code and improves readability. For instance:\nlet amount = 500 let accountBalance = 1000 guard amount \u0026lt;= accountBalance else { print(\u0026#34;Insufficient funds!\u0026#34;) return } // Perform payment operation Another Use Cases #There are other use cases for guard, specifically related to Optionals and Error handling. However, since these are more advanced topics, in my opinion, it is better only mention them now, and explore them in detail in future advanced posts.\nInput Validation #guard statement is often used to validate input parameters, ensuring that they meet certain requirements before proceeding. This case is used handling optionals.\nResource Deallocation #In this case, guard is handy when dealing with resources that require cleanup. It ensures that the cleanup code is executed whenever a failure condition is encountered.\nConclusion #The guard statement is a powerful tool in iOS programming that allows for clean, concise, and efficient code. It provides an elegant way to handle failure scenarios and gracefully exit from a code block when certain conditions are not met.\nBy using the guard statement effectively, you can improve the readability and maintainability of your code.\nEmbrace this construct in your iOS projects, and enjoy the benefits of a more streamlined development process.\nHappy coding! üë®üèª‚Äçüíª\n","date":"2 May 2023","permalink":"/en/posts/guard-early-exit-swift/","section":"Posts","summary":"In iOS programming, one powerful construct that helps streamline code readability and improve control flow is the guard statement.","title":"Understanding the Guard Statement for Early Exit"},{"content":"Control transfer statements are essential tools in programming that allow developers to alter the flow of execution within their code.\nIn Swift, three commonly used control transfer statements are continue, break, and fallthrough.\nIn this article, we will examine into each of these statements, providing examples and explaining the scenarios where they are most appropriate to use.\nContinue #The continue statement is primarily used within loop constructs (such as ‚Äòfor-in\u0026rsquo; or \u0026lsquo;while\u0026rsquo;) to skip the remaining code within the current iteration and proceed to the next iteration.It allows you to selectively skip over specific parts of a loop without terminating it entirely. Here\u0026rsquo;s an example to illustrate its usage:\nfor number in 1...10 { if number % 2 == 0 { continue } print(number) } Output\n1 3 5 7 9 In this example, the continue statement is used to skip printing even numbers. When the condition number % 2 == 0 is true, the continue statement is executed, bypassing the print statement and proceeding to the next iteration.\n##¬†Break The break statement is used to terminate the execution of a loop or switch statement prematurely. It allows you to exit out of a loop or switch block before reaching its natural end.\nConsider the following example:\nlet cars = [‚ÄúRed Bull\u0026#34;, ‚ÄúAston Martin\u0026#34;, ‚ÄúFerrari\u0026#34;, \u0026#34;Mercedes\u0026#34;, \u0026#34;McClaren\u0026#34;] for name in names { if name == \u0026#34;Mercedes\u0026#34; { break } print(name) } Output\nRed Bull Aston Martin Ferrari In this case, the break statement is used to exit the loop once the condition name == \u0026quot;Mercedes\u0026quot; is true. As a result, the loop terminates prematurely, and the remaining elements in the cars array are not printed.\nFallthrough #The fallthrough statement is exclusively used within switch statements. It allows the control flow to move to the next case without performing an implicit break.\nThis behavior differs from the default behavior of a switch statement, where control automatically exits the switch block after a case is matched.\nConsider the following example:\nlet grade = \u0026#34;A\u0026#34; switch grade { case \u0026#34;A\u0026#34;: print(\u0026#34;Excellent\u0026#34;) fallthrough case \u0026#34;B\u0026#34;: print(‚ÄúYou have approved\u0026#34;) case \u0026#34;C\u0026#34;: print(\u0026#34;Average\u0026#34;) default: print(\u0026#34;Incomplete\u0026#34;) } Output\nExcellent Good In this example, when the grade is \u0026ldquo;A,\u0026rdquo; the fallthrough statement is used to continue the execution to the next case without exiting the switch block. As a result, both \u0026ldquo;Excellent\u0026rdquo; and \u0026ldquo;You have approved\u0026rdquo; are printed.\nConclusion #Understanding control transfer statements like continue, break, and fallthrough is crucial for effective Swift programming.\ncontinue allows you to skip specific iterations within loops, break enables premature termination of loops or switch statements, and fallthrough allows control to flow to the next case in a switch statement.\nBy leveraging these statements appropriately, you can enhance the flexibility and control of your code execution in iOS development.\nHappy coding! üë®üèª‚Äçüíª\n","date":"17 April 2023","permalink":"/en/posts/control-transfer-statements-swift/","section":"Posts","summary":"Control transfer statements are essential tools in programming that allow developers to alter the flow of execution within their code.","title":"Exploring Control Transfer Statements in Swift"},{"content":"Understanding the fundamentals of Swift programming is crucial to creating robust and efficient applications.\nOne of the key concepts you need to grasp is conditional statements. In this article, we will navigate into the world of conditional statements in Swift, exploring their syntax, examples, and best practices for using them effectively. So let\u0026rsquo;s go!\nConditional Statements: Making Decisions in Swift #In programming, there are often situations where you need your app to make decisions based on certain conditions. This is where conditional statements come into play, enabling you to execute specific blocks of code depending on whether a condition evaluates to true or false.\nSwift offers three primary conditional statements: if statements, if-else statements, and switch statements.\nEach statement serves a distinct purpose, and understanding when to use them is essential for writing clean and maintainable code.\nThe If Statement #The if statement is the simplest form of conditional statement in Swift. It allows you to execute a block of code only if a specified condition is true.\nFor example, let\u0026rsquo;s say you want to display a message if a user\u0026rsquo;s age is greater than or equal to 18:\nlet userAge = 20 if userAge \u0026gt;= 18 { print(\u0026#34;Welcome! You can access.\u0026#34;) } The If-Else Statement #The if-else statement expands upon the if statement by providing an alternative block of code to execute when the condition evaluates to false.\nConsider the following example that checks whether a number is positive or negative:\nlet number = -5 if number \u0026gt; 0 { print(\u0026#34;The number is positive.\u0026#34;) } else { print(\u0026#34;The number is negative.\u0026#34;) } The Switch Statement #The switch statement offers a more concise way to handle multiple possible conditions. It evaluates a given value against various cases and executes the code block associated with the first matching case.\nLet\u0026rsquo;s say you want to display a message based on a user\u0026rsquo;s role:\nlet userRole = \u0026#34;admin\u0026#34; switch userRole { case \u0026#34;admin\u0026#34;: print(\u0026#34;Welcome, administrator!\u0026#34;) case \u0026#34;user\u0026#34;: print(\u0026#34;Welcome, user!\u0026#34;) default: print(\u0026#34;Unknown role.\u0026#34;) } Best Practices for Using Conditional Statements: #Keep it simple #Aim to write concise and readable code. Avoid complex nested conditions that can make your code difficult to understand and maintain.\nUse appropriate operators #Swift provides a range of comparison and logical operators, such as \u0026lt;, \u0026gt;, ==, \u0026amp;\u0026amp;, ||, to construct meaningful conditions.\nPlan for all possibilities #Ensure you account for all possible scenarios in your conditional statements. The default case in switch acts as a catch-all for unmatched conditions.\nTest your code #Validate your conditional statements with different inputs to ensure they behave as expected. Unit testing is a valuable practice to identify and fix any issues early on.\nConclusion #Conditional statements are fundamental tools for iOS developers, allowing you to make decisions and control the flow of your code based on specific conditions. By mastering if statements, if-else statements, and switch statements, you gain the ability to create dynamic and responsive applications.\nRemember to use these statements wisely, keeping your code clean and understandable.\nHappy coding! üë®üèª‚Äçüíª\n","date":"3 April 2023","permalink":"/en/posts/conditional-statements-swift/","section":"Posts","summary":"Understanding the fundamentals of Swift programming is crucial to creating robust and efficient applications.","title":"Swift Fundamentals about Conditionals"},{"content":"In iOS development, flow control statements play a crucial role in directing the execution of code.\nIt allow developers to iterate over collections, perform repetitive tasks, and control the program\u0026rsquo;s behavior based on certain conditions. In this post, we will dive into three essential flow control statements in Swift: for-in, while, and repeat-while.\nWhether you\u0026rsquo;re a junior iOS developer or someone looking to refresh their knowledge, understanding these statements is essential for building robust and efficient iOS applications.\nFor-In Loops: Simplifying iteration #The for-in loop is particularly useful when you want to iterate over a collection of elements, such as an array or a dictionary. It simplifies the process of accessing each element without the need for manual indexing. Let\u0026rsquo;s take a look at an example:\nlet books = [‚ÄúA Game of Thrones‚Äù, ‚ÄúA Clash of Kings‚Äù, ‚ÄúA Storm of Swords‚Äù, ‚ÄùA Feast for Crows‚Äù, ‚ÄúA Dance with Dragons‚Äù] for book in books { print(book) } In this example, the for-in loop iterates over each element in the books array and prints it title. The loop automatically assigns each element to the book constant, allowing you to perform operations on it within the loop\u0026rsquo;s scope.\nThis loop is ideal for scenarios such as:\nEnumerating through an array to perform operations on each element. Iterating over a dictionary to access both the keys and values. Looping over a range of numbers or characters. While Loops: Executing Code Conditionally #The while loop executes a block of code repeatedly as long as a given condition remains true. This is particularly useful when you don\u0026rsquo;t know the exact number of iterations in advance. Here\u0026rsquo;s an example to illustrate its usage:\nvar count = 0 while count \u0026lt; 5 { print(\u0026#34;Count: \\(count)\u0026#34;) count += 1 } In this example, the while loop will continue executing as long as the count variable is less than 5. It prints the current value of count and increments it by 1 in each iteration. Be cautious when using while loops to ensure that the condition eventually becomes false; otherwise, it can result in an infinite loop.\nConsider using the while loop in the following situations:\nRepeatedly performing an action until a specific condition is met. Implementing input validation and continuously asking for user input until valid data is provided. Interacting with external systems or processes that require continuous monitoring. Repeat-While Loop: Ensuring First Code Execution #The repeat-while loop is similar to the while loop, but with a crucial difference: the condition is evaluated at the end of the loop. This guarantees that the code block executes at least once, even if the condition is initially false. Here\u0026rsquo;s an example:\nvar number = 10 repeat { print(number) number -= 2 } while number \u0026gt; 0 In this example, the repeat-while loop prints the value of number and subtracts 2 from it until number becomes 0 or less. Unlike the while loop, the repeat-while loop executes the code block first and then checks the condition.\nIs suitable for scenarios like:\nImplementing menu-driven systems where you want to ensure execution before checking for user choices. Handling game logic where an action must be performed at least once before checking for game-ending conditions. Repeating an operation until a specific condition is met. Conclusion #Understanding flow control statements like for-in, while, and repeat-`while is fundamental for any iOS developer.\nThese statements enable you to control the program\u0026rsquo;s flow, iterate over collections, and execute code conditionally. By mastering these flow control statements, you\u0026rsquo;ll have the ability to build more efficient and dynamic iOS applications.\nUtilize these statements wisely, paying attention to loop termination conditions to avoid infinite loops. Keep exploring their capabilities and experimenting with different scenarios to enhance your programming skills.\nHappy coding! üë®üèª‚Äçüíª\n","date":"20 March 2023","permalink":"/en/posts/loops-swift/","section":"Posts","summary":"In iOS development, flow control statements play a crucial role in directing the execution of code.","title":"Exploring Loops in Swift"},{"content":"The collections are one of the most used data structure when you are programming so, it is extremely important know the different approach you dispose to work with them.\nCollection types are complex data types, and Swift allow use three collection types: Arrays, Sets and Dictionaries for manage related values.\nThe reliability of these collections is based on the types of values and keys that you can store. When you create an instance of a collection, you need to confirm the type of values that it manages. This means that: you cannot store different types that you previously defined, and you can be sure the type of data you will retrieve when you manage a collection.\nAlso, thanks to type inference, you can specify the type, or Swift will infere the type.\nCollection Mutability #As well as variables and constants, collections can be mutable or unmutable depending on how was created.\nIf you store an array, set or a dictionary in a variable, you can mutate the collection, because you can add, remove or change a single or multiple values in these collection.\nBut, if you store it in a constant, you cannot add new elements or modify the ones with was instantiated.\nDiferences between arrays, sets and dictionaries #Arrays are ordered collections, where duplications are allowed and values can be accessed by a numeric index (position in the array)\nSets are unordered collections where duplications are no allowed, and values can be iterated, but cannot be accesed by an index or key.\nDictionaries are unordered collections composed by key-value associations.\nFundamentals of different collection types #Arrays #If you want to create an empty array, you will need specify the data type. There are different ways to create an empty array, this a example.\nvar numbers = [Int]() But, if you want to create it with values, you don\u0026rsquo;t need specify the types. Next, you can see how to create an strings array\nvar tutorials = [\u0026#34;SwiftUI\u0026#34;, \u0026#34;Combine\u0026#34;, \u0026#34;AsyncAwait\u0026#34;] And, if you need to access to a value, you must indicate the position of the value in the array. But, remember that collections index starts by 0.\nlet firstCourse = tutorials[0] The above code will store \u0026ldquo;SwiftUI\u0026rdquo; in firstCourse constant.\nSets #Again, you will need specify data type for create an empty set.\nvar numbers = Set\u0026lt;Int\u0026gt;() Create a set with values, is similar to create an array but, in this case, you will need to specify that is a set to don\u0026rsquo;t create an array\nvar tutorials = [\u0026#34;SwiftUI\u0026#34;, \u0026#34;Combine\u0026#34;, \u0026#34;AsyncAwait\u0026#34;] But, in this case, as sets have not an index, you cannot use it to access to the data. At least, you can check if the value exists.\nvar swiftuiExists = tutorials.contains(\u0026#34;SwiftUI\u0026#34;) The above code wil store true in swiftuiExists variable\nDictionaries #And, lastly, you can create an empty dictionary specifying both the key type and the value type\nvar nameOfNumbers = [Int: String]() To create a dictionary with values, it is also similar to an array, but you have to write the key of each value. Remember that the keys must be uniques.\nvar requirements = [\u0026#34;View\u0026#34;:\u0026#34;SwiftUI\u0026#34;, \u0026#34;Database\u0026#34;:\u0026#34;CoreData\u0026#34;, \u0026#34;AugmentedReality\u0026#34;:\u0026#34;ARKit\u0026#34;] And, if you want to access to a value, you only need know the index\nlet database = requirements[\u0026#34;Database\u0026#34;] In next posts, I will write about useful methods in collection types to manage arrays, sets and dictionaries. Happy coding! üë®üèª‚Äçüíª\n","date":"6 March 2023","permalink":"/en/posts/swift-collection-types/","section":"Posts","summary":"The collections are one of the most used data structure when you are programming so, it is extremely important know the different approach you dispose to work with them.","title":"Swift Collection Types"},{"content":"This post is a complement for the previous one about Swift Strings.\nI real-world projects, you can store a lot of strings but, it is important that you know how to transform those strings, to display them according to your view.\nFor this reason, let\u0026rsquo;s see usual methods that you can use for it.\nCount characters #Because a String is a Collection of Characters, you can use a very common method in Arrays: count()\nEither you can use it in a constant/variable or in a String\nlet starWarsIntro = \u0026#34;A long time ago...\u0026#34; let numberOfCharacters = starWarsIntro.count() // numberOfCharacters value 18 let numberOfCharactersOfGreet = \u0026#34;Hello World!\u0026#34;.count() // numberOfCharactersOfGreet value is 12 Even you can combine values in the same String through String interpolation:\nlet plotTwist = \u0026#34;I am your father\u0026#34; print(\u0026#34;The number of character in \\(plotTwist) is \\(plotTwist).count()\u0026#34;) // It will print \u0026#34;The number of character in I am your father is 16\u0026#34; Insert or remove #Also it is important add or remove characters or substrings\nInsert #For insert, you can:\nInsert a character with the method .insert(_ newElement:at:) Insert a substring with the method .insert(contentsOf:at:) In at you will need to write a index. You can know more about indexes in Swift official Documentation - String Indices\nvar warning = \u0026#34;we have a problem\u0026#34; warning.insert(contentsOf: \u0026#34;Houston, \u0026#34;, at: warning.startIndex) print(warning) // It will print \u0026#34;Houston, we have a problem\u0026#34; Remove #Similar to insert, for remove Swift allow remove characters of substrings:\nRemove a character with the method .remove(:at:) Remove a substring with the method removeSubrange(_ bounds:) Be careful with don\u0026rsquo;t exit out of bounds\nvar greeting = \u0026#34;Hello World!\u0026#34; greeting.remove(at: greeting.index(before: greeting.endIndex)) print(greeting) // It will print \u0026#34;Hello World\u0026#34; Modify strings #Uppercase and lowercase #The methods that you can use for it are .uppercased(), .lowercased() or .capitalized()\nExamples:\nlet lordOfTheRings = \u0026#34;A ring to rule them all\u0026#34; print(lordOfTheRings.uppercased()) // It will print \u0026#34;A RING TO RULE THEM ALL\u0026#34; print(lordOfTheRings.lowercased()) // It will print \u0026#34;a ring to rule them all\u0026#34; print(lordOfTheRings.capitalized) // It will print \u0026#34;A Ring To Rule Them All\u0026#34; Extract a string to an array #For this goal you can use .components(separatedBy: \u0026quot; \u0026quot;)\nlet et = ‚ÄúE.T. phone home.‚Äù let etWords = et.components(separatedBy: \u0026#34; \u0026#34;) // etWords value is equal to [\u0026#34;E.T.\u0026#34;, \u0026#34;phone\u0026#34;, \u0026#34;home.\u0026#34;] Replacing occurrences #In this case, a useful method is .replacingOccurrences(of:, with:), you can replace a character or a string with another character or string\nlet darkKnight = \u0026#34;I am Batman\u0026#34; let coded = darkKnight.replacingOccurrences(of: \u0026#34;a\u0026#34;, with: \u0026#34;4\u0026#34;) // coded value is equal to \u0026#34;I 4m B4tm4n\u0026#34; Happy coding! üë®üèª‚Äçüíª\n","date":"20 February 2023","permalink":"/en/posts/useful-strings-methods-swift/","section":"Posts","summary":"This post is a complement for the previous one about Swift Strings.","title":"Useful String Methods in Swift"},{"content":"When you save a text in a constant or a variable, your are saving a string in Swift. Furthermore, you can see a string as a serie of characters. For that reason, you can access to the content of a string in various ways, such as Collection (Array i.e.) of characters.\nInitialize a String #A string literal is a text writed with a double quote at beginning and at the end. So, if you need to save a text in a constant or a variable, you only must to assign a string literal to it.\nlet coach = \u0026#34;Ted Lasso\u0026#34; var team = \u0026#34;AFC Richmond\u0026#34; NOTE: It is fundamental remember that strings are case sensitive. So, \u0026ldquo;a simple string\u0026rdquo; it is different of \u0026ldquo;A simple string\u0026rdquo;.\nConcatenating strings #If you need to save the value of two strings in another constant or variable, you can concatenate it.\nIt is as easy as use the operator + between the two values when you have to assign it.\nlet name = \u0026#34;Michael\u0026#34; let lastName = \u0026#34;Scott\u0026#34; let funnyBoss = name + lastName Another way, it is to use the operator += to add text to a previous initialized string\nvar spy = \u0026#34;Bond\u0026#34; spy += \u0026#34;, James Bond\u0026#34; In the above example, the final value of spy is Bond, James Bond\nAnd, as a String is a Collection of characters, you can also use the method .append()\nvar greet = \u0026#34;Hello, world\u0026#34; greet.append(\u0026#34;!\u0026#34;) In the last code, greet value is Hello, world!\nString interpolation #But maybe the most used feature in Strings could be String interpolation. It allows use constants or variables values inside a string.\nIn this case, you can do it, writing the constant or variable name, inside parenthesis \u0026ldquo;()\u0026rdquo;, and starting with a backlash \u0026ldquo;\u0026quot;. That is \\(variableName)\nlet name = \u0026#34;Forest\u0026#34; let fullName = \u0026#34;Forest Gump\u0026#34; let introduction = \u0026#34;Hello, I am \\(name), \\(fullName)\u0026#34; The final value of introduction is \u0026quot;Hello, I am Forest, Forest Gump\u0026quot;\nMultiline String #Finishing (althought it is not used often in real world apps) maybe sometimes you need to save larger texts in a string, and it could be difficult read the value for others programmers o for yourself. In this case, you can use a multiline string.\nTo save a multiline string, you only need to write three quotation marks at the beginning, and finish with another three in a single line. For example:\nlet text = \u0026#34;\u0026#34;\u0026#34; To be, or not to be, that is the question: Whether \u0026#39;tis nobler in the mind to suffer The slings and arrows of outrageous fortune, Or to take arms against a sea of troubles, And by opposing end them? To die, to sleep; \u0026#34;\u0026#34;\u0026#34; First triple double quotes doesn\u0026rsquo;t need to be in a single line, but it helps to focus in text value.\nYou can see useful methods in the post [Useful String methods in Swift](../useful-strings-methods-swift) Happy coding! üë®üèª‚Äçüíª\n","date":"6 February 2023","permalink":"/en/posts/swift-strings/","section":"Posts","summary":"When you save a text in a constant or a variable, your are saving a string in Swift.","title":"Swift Strings"},{"content":"Programming has been often for process numbers and obtain results so difficult to calculate for humans: universe distances, planet radius, pi‚Ä¶\nSo, is part of fundamental learning, in Swift in particular and in programming globally.\nThere are basically 2 types of numbers in Swift: Integers and Floating-Point numbers. Each one represents a different range and is used for different targets.\nIntegers #A integer number (also called int, for short) is possibly the most used number. We could say that it is the most simple, because has no fractional component.\nIt can be positive, zero, or negative. For example, integer numbers are: 5, -3, 99, -256‚Ä¶\nAlso, Swift provides signed and unsigned integers for 8,16, 32 and 64 bit. Following naming convention of C, the type of 8 bit unsigned number is UInt8, whereas 16 bit signed is Int16. But, is not frequently used in most of developed apps.\nIntegers range #It depends of bits number, but each one has a max and min number to store. You can check it in next list.\nUInt8: from 0 to 255 UInt16: from 0 to 65535 UInt32: from 0 to 4294967295 UInt64: from 0 to 18446744073709551615 Int8: from -128 to 127 Int16: from -32768 to 32767 Int32: from -2147483648 to 2147483647 Int64: from -9223372036854775808 to 9223372036854775807 But, if you don‚Äôt remember the values, you can use the methods .max or .min let minValue = Int.min //minValue is equal to let maxValue = Int.max //maxValue is equal to Floating-Point numbers #Unlike integers, floating-point numbers has a fractional component. But, like integers, can be positive or negative.\nIt exists two signed floating-point number types\nDouble #Double numbers represent a 64-bit floating-point number, and has a precision of at least 15 decimal digits.\nFloat #Float numbers represent a 32-bit floating-point number, and has a precision of at least 6 decimal digits.\n*NOTE: You will need Double or Float depending of multiple factors, but if either would be appropriated, Swift documentation recommends use Double.* Happy coding! üë®üèª‚Äçüíª\n","date":"30 January 2023","permalink":"/en/posts/numbers-in-swift/","section":"Posts","summary":"Programming has been often for process numbers and obtain results so difficult to calculate for humans: universe distances, planet radius, pi‚Ä¶","title":"Numbers in Swift"},{"content":"Programming is a way to manage data, and usually, you need save multiple values temporally: to manage it after other operations, to display it‚Ä¶\nFor this matter, as another programming languages, Swift is able to store values in constants and variables.\nThanks to constant and variables you are able to associate a name that you choose to a value.\nConstants #A constant value is saved in a memory space, and it can‚Äôt be modified. After a value is established in a constant, it remains immutable.\nHow to declare a constant #To declare a constant you must start with reserved word let, followed by a name you choose. Then, you must can use the operator ‚Äò=‚Äò and assign a value.\nIn the next example, ‚Äòlet‚Äô is the reserved word for constants, survivor the name of the constant, and the value that is assigned to the constant ‚Äòsurvivor‚Äô is ‚ÄúJack Shepard‚Äù.\nlet survivor = ‚ÄúJack Shepard‚Äù The value is between double quotes because is a String value type. You can read about Strings in official documentation: Strings and Characters\nDo you know why Swift use let instead const or similar as another languages? It comes from the mathematics world, where they say things like:\nlet x be equal to 5\nVariables #A variable is a value that you can modify after have been declared. So, is a mutable value.\nHow to declare a variable #To declare a variable, the structure is the same as a constant, but you must use the reserved word var\nThen, for declare a variable you must write\nvar videogame = ‚ÄúMetal Gear Solid‚Äù Ok but, if we want to change a var value, how should we do it? Easy, you only need assign a new value, and don‚Äôt write the reserved word var\nvideogame = ‚ÄúUncharted‚Äù Naming a constant, variable or value #You can use almost any character for a name of constant or variable, including Unicode characters. It means that you can use for example emojis\nBut it is something that a I wouldn‚Äôt recommend. Why? Because the name of a constant or a variable, should explain without any doubt what is stored within.\nFor example, which one explain what means the value 10?\nlet times = 10 let numberOfTimesIHaveSeenBackToTheFutureTrilogy = 10 In second case is easier to know\nConclusion #So, don‚Äôt worry about numbers of characters for the name. It is more recommended use a large (but descriptive ) name than use another shorter that doesn‚Äôt specify what stores. And, nowadays, IDE‚Äôs are in charge to autocomplete names, it won‚Äôt be difficult write them üòâ\nHappy coding! üë®üèª‚Äçüíª\n","date":"16 January 2023","permalink":"/en/posts/constants-and-variables-swift/","section":"Posts","summary":"Programming is a way to manage data, and usually, you need save multiple values temporally: to manage it after other operations, to display it‚Ä¶","title":"Constants and Variables to Save Values in Swift"},{"content":"Hi! I am very happy today, because I have refactored my blog üòâ\nThis is not my first experience writing in my blog but, 2022 was a year with changes and new challenges in my working life so, I decided restart my blog to align it with what I am doing day by day.\nFor this reason, this is my first post, but only in this new version of my blog.\nAbout me #If I have to talk about me in a sentence, I like to say that I am a passionate about programming and tech world.\nNowadays, I work as iOS Developer at Hiberus, a global consultancy company founded in Spain, but growing quickly and opening new offices in places such as Berl√≠n, London, M√©xico DF or Miami.\nBut, my work experience have been mainly focused in IT. Besides programming, I have previous experience working as QA or DevOps engineer.\nRecently, because I\u0026rsquo;m a enthusiastic user of Apple products, I decided to learn Swift, and specialize in their ecosystem development. Not only for iOS devices, but for MacOS or the rest of Apple operating systems.\nMy personal life #I was born in Valencia (Spain), where I live, at 80‚Äôs, the age of Spectrum, Atari and the first Sega\u0026rsquo;s or Nintendo videoconsoles. So, I grow up and enjoyed play videogames with my Sega Megadrive, watch cartoons as He-man, Dragon Ball or Captain Tsubasa.\nI\u0026rsquo;m the proud father of Lucas üë∂üèª, my 3 years son that became the home CEO, and the proud husband of Lorena, the best life companion that I could have. A wonderfull woman, with a special power to treat with the childhood (And with me üòÖ)\nNowadays, I spend my non-working hours with my family or my hobbies, such as: enjoying TV Series, watching Formula 1, reading or playing chess.\nWhy I write in this blog #Knowledge #The first reason (and the most important) is for learning. I think that there are 3 levels of knowledge:\n1st: When someone teach you something, or you learn it watching a video or reading a book 2nd: When you are able to do what you have learned 3rd: When you are able to teach someone what you know. And, for this reason, write in a blog help me to learn teaching others.\nTo help #The second one, is helping others what today I love: programming. I think that everybody‚Äôs like help others, and also, this my way to extend the help that I receive from others.\nExpress my opinion #Another reason is, as iOS Developer, I need to have a deep understand about the Apple ecosystem so, this will be a place to organize my thoughts about the news, products, events as WWDC‚Ä¶ but ever focused in coding\nPractice english #And the last reason, (but no less important), practice to write tech documentation in English. My native language is Spanish, but globalization and remote working has opened a lot of opportunities. And English is today the key language for learn and work.\nIf you wanna know more about me, feel free to check my social media links (see the footer)\nSo, I hope you enjoy my posts! üôÇ\n","date":"2 January 2023","permalink":"/en/posts/my-new-first-post/","section":"Posts","summary":"Hi! I am very happy today, because I have refactored my blog üòâ","title":"My (New) First Post"},{"content":"","date":null,"permalink":"/en/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":null,"permalink":"/en/tags/","section":"Tags","summary":"","title":"Tags"}]