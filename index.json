[{"content":"","date":null,"permalink":"/legal/","section":"Legals","summary":"","title":"Legals"},{"content":"","date":null,"permalink":"/","section":"Oscar Moreno | iOS Developer ","summary":"","title":"Oscar Moreno | iOS Developer "},{"content":"","date":null,"permalink":"/apps/","section":"Apps","summary":"","title":"Apps"},{"content":"Last updated: July 8, 2025\nThank you for using NSBuddy, a macOS application designed to improve the productivity of Swift developers. These Terms of Service (\u0026ldquo;Terms\u0026rdquo;) govern your access to and use of NSBuddy (\u0026ldquo;the App\u0026rdquo;), developed and maintained by Oscar Moreno Zamora (\u0026ldquo;the Developer\u0026rdquo;).\nBy using NSBuddy, you agree to be bound by these Terms. If you do not agree with any part of the Terms, you should not use the App.\n1. Overview #NSBuddy is currently available for macOS, with future versions planned for iOS and iPadOS. Most features require an active subscription. No registration or user account is necessary to use the App.\n2. License #By downloading or using NSBuddy, you are granted a non-exclusive, non-transferable, personal license to use the App on any Apple device associated with your Apple ID.\nYou may not:\nDistribute, sublicense, or resell the App; Modify, reverse engineer, or decompile any part of the App; Use the App for any unlawful purpose. 3. Payments and Subscriptions #Some features of NSBuddy are only available to users with an active subscription. Payments and subscriptions are handled through Apple\u0026rsquo;s App Store and are subject to Apple’s terms and conditions.\n4. Data and Privacy #NSBuddy does not collect personal data. Optionally, users may choose to provide their email address to send feedback. The App accesses local Derived Data and SwiftUI Previews folders only after the user grants permission.\nFor more details, please refer to our Privacy Policy.\n5. External Services #NSBuddy uses internet access solely to open external links in the Browse section. No user data is sent to external servers. A third-party package, WishKit, may be used to manage user suggestions.\n6. Disclaimer of Warranties and Liability #The App is provided \u0026ldquo;as is\u0026rdquo; without warranty of any kind. While the App is designed to support your development workflow, the Developer does not guarantee uninterrupted or error-free operation.\nIn no event shall the Developer be held liable for any loss, data corruption, or damage resulting from the use or misuse of the App.\nSupport and guarantees, if any, are limited to those provided through Apple\u0026rsquo;s standard support policies.\n7. Legal Jurisdiction #These Terms shall be governed and construed in accordance with the laws of Spain. Any disputes arising from the use of the App shall fall under the jurisdiction of the courts of Spain.\n8. Contact #If you have any questions regarding these Terms, you may contact the Developer through oscarmoreno.com.\n","date":null,"permalink":"/legal/nsbuddy-terms-of-service/","section":"Legals","summary":"\u003cp\u003e\u003cstrong\u003eLast updated\u003c/strong\u003e: July 8, 2025\u003c/p\u003e\n\u003cp\u003eThank you for using \u003cstrong\u003eNSBuddy\u003c/strong\u003e, a macOS application designed to improve the productivity of Swift developers. These Terms of Service (\u0026ldquo;Terms\u0026rdquo;) govern your access to and use of NSBuddy (\u0026ldquo;the App\u0026rdquo;), developed and maintained by Oscar Moreno Zamora (\u0026ldquo;the Developer\u0026rdquo;).\u003c/p\u003e\n\u003cp\u003eBy using NSBuddy, you agree to be bound by these Terms. If you do not agree with any part of the Terms, you should not use the App.\u003c/p\u003e","title":"NSBuddy Terms of Service"},{"content":"NSBuddy is a dedicated macOS app crafted for Swift developers who seek to enhance their coding efficiency and save valuable time. Whether you\u0026rsquo;re an experienced developer or just starting out, NSBuddy consolidates all the essential developer tools in one convenient location, allowing you to maintain focus and productivity.\nSpecifically designed with Swift and SwiftUI, NSBuddy offers a suite of practical utilities tailored to streamline the daily work processes of developers targeting Apple platforms.\nWhy Choose NSBuddy: # Efficient Disk Management: Easily manage clutter by scheduling or manually removing Derived Data and Xcode previews, freeing up crucial disk space.\nSwift Code Generation: Accelerate your coding process with instant Swift struct creation and Core Data queries from JSON or other input models.\nSeamless Format Conversion: Transform JSON files into Swift models, convert different color formats, or generate code-friendly representations quickly.\nEnhanced Code Readability: Automatically format and beautify JSON to ensure your code is tidy and ready for development.\nQuick Validation: Instantly verify and test your regular expressions and JSON structures to prevent errors before they occur.\nPersonalized Resources: Organize your go-to tools and documentation with custom developer links, giving you quick access to the resources you rely on most.\nTailored Workspace: Customize your experience by selecting only the tools you need, keeping your workspace clean and focused on what matters.\nEmbrace a more streamlined development process with NSBuddy, where every tool is designed to support your journey as a Swift developer.\nSoon on the App Store.\n","date":null,"permalink":"/apps/nsbuddy/","section":"Apps","summary":"NSBuddy is a dedicated macOS app crafted for Swift developers who seek to enhance their coding efficiency and save valuable time. Soon on the App Store","title":"NSBuddy"},{"content":"Effective date: 2025-07-01\nNSBuddy (“the App”) is a macOS application developed and maintained by Oscar Moreno Zamora (“the Developer”). This privacy policy describes how NSBuddy handles user data and what information may be collected when using the App.\n1. Information Collected #NSBuddy is designed with privacy in mind. The App does not collect or transmit any personal data by default.\nThe following information may be collected or accessed locally:\nApp Version: The App checks its version to determine when to prompt the user for an App Store review. Email (Optional): Users may voluntarily provide their email address when submitting feedback via WishKit. Access to Xcode Data: Upon explicit user permission, NSBuddy accesses and manages the following directories to clean development artifacts: ~/Library/Developer/Xcode/DerivedData ~/Library/Developer/Xcode/Previews 2. Use of External Services #NSBuddy uses the following third-party services:\nWishKit: Used to collect optional user feedback. RevenueCat: Used to manage subscriptions and purchases. NSBuddy does not store or access any payment information directly. External Links: The App includes a “Browse” section with links to external resources. Internet access is only used to open those links in the default browser. No other external communication or data transfer is performed by the App.\n3. Data Storage #All data generated or used by NSBuddy is stored locally on the user’s device. No data is uploaded to any server controlled by the Developer.\n4. Permissions #NSBuddy requests permission to access specific system directories necessary for its core functionality:\n~/Library/Developer/Xcode/DerivedData ~/Library/Developer/Xcode/Previews These permissions are only requested once and require explicit user approval.\n5. Legal Compliance #NSBuddy is available globally. While the App does not process or store personal data in a way that typically triggers privacy regulations such as the GDPR, the Developer is committed to respecting user privacy and complying with applicable laws.\n6. Subscriptions and Payments #NSBuddy offers subscription-based access to most of its features. Subscriptions are handled through RevenueCat, which integrates with Apple’s in-app purchase system. No payment data is collected or stored by the App or the Developer.\n7. Contact #For questions about this privacy policy, you may contact the Developer:\nOscar Moreno Zamora\nContact\n","date":null,"permalink":"/legal/nsbuddy-privacy-policy/","section":"Legals","summary":"\u003cp\u003e\u003cstrong\u003eEffective date\u003c/strong\u003e: 2025-07-01\u003c/p\u003e\n\u003cp\u003eNSBuddy (“the App”) is a macOS application developed and maintained by Oscar Moreno Zamora (“the Developer”). This privacy policy describes how NSBuddy handles user data and what information may be collected when using the App.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"1-information-collected\" class=\"relative group\"\u003e1. Information Collected \u003cspan class=\"absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100\"\u003e\u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\" style=\"text-decoration-line: none !important;\" href=\"#1-information-collected\" aria-label=\"Anchor\"\u003e#\u003c/a\u003e\u003c/span\u003e\u003c/h2\u003e\u003cp\u003eNSBuddy is designed with privacy in mind. The App does \u003cstrong\u003enot\u003c/strong\u003e collect or transmit any personal data by default.\u003c/p\u003e","title":"NSBuddy Privacy Policy"},{"content":"","date":null,"permalink":"/blog/","section":"Blog","summary":"","title":"Blog"},{"content":"One of my favorite features in Swift is enums.\nThey are easy to understand and use.\nBut sometimes, we don\u0026rsquo;t make the most of them.\nAnd that can be achieved (among other ways) through associated values.\nAssociated values allow you to attach values of different types to the different cases of an enumeration.\nIf you need it, I also wrote an article on enumerations.\nSo today, I will show you how to make the most of them and in what situations they are advantageous.\nHow to Define Associated Values in Your Enumerations #You just need to include, after each case, the type of value you want to associate.\nYou can define as many values as you want.\nAlthough, as in other cases, it\u0026rsquo;s not recommended to have too many values.\nIn this way, you will improve readability and reduce complexity.\nMoreover, optionally, you can also specify the parameter name.\nstruct User { let name: String } enum Resolution { case completed case dropped } enum State { case toDo(estimatedDate: Date) case inProgress(assignee: User) case done(time: Int) case close(Resolution) } As you can see, each case of the State enum has an associated value.\nAll of them have a parameter name except for the closing case.\nAssigning Associated Values to an Enumeration Case #Once the enum is defined, when you choose a case, you must assign a value of the specified type.\nlet state = State.toDo(estimatedDate: Date.now.addingTimeInterval(86400)) let state2 = State.inProgress(assignee: .init(name: \u0026#34;John\u0026#34;)) let state3 = State.done(time: 10) let state4 = State.close(.completed) Additionally, this also occurs when using a switch to handle different situations.\nBut, in this way, the parameter assigned in each case of the switch doesn\u0026rsquo;t need to have the same name as in the definition.\nNor are you required to reference the parameter if you don\u0026rsquo;t need it for handling.\nYou can see this better in the following example.\nfunc manageTask(_ task: State) { switch task { case .toDo: print(\u0026#34;Task is not started yet.\u0026#34;) case .inProgress(let assignee): print(\u0026#34;\\(assignee) is working on it\u0026#34;) case .done(var duration): duration /= 60 print(\u0026#34;Task was completed in \\(duration) hours\u0026#34;) case .close(let finalState): print(\u0026#34;Task is finished. It was \\(finalState)\u0026#34;) } } manageTask(.toDo(estimatedDate: Date.now.addingTimeInterval(172_800))) let user = User(name: \u0026#34;Erlich Bachman\u0026#34;) manageTask(.inProgress(assignee: user)) manageTask(.done(minutes: 90.0)) As you can see, in the toDo case, the estimated start date is not used, so you don\u0026rsquo;t need to retrieve that value.\nWhile in the done and close cases, the parameter name in the definition does not match the name in the switch.\nAdvantages of Using Associated Types for Enums #Improved Readability #I know I say this often, but we spend more time reading code than writing it.\nSo it\u0026rsquo;s better for that activity to be as simple as possible.\nThanks to associated values, you don\u0026rsquo;t need to create external structures to associate with the cases.\nMoreover, the code hierarchy remains simpler without those classes.\nGreater Stability #Strong typing is one of the greatest advantages of Swift.\nAnd it is reinforced by this feature.\nYou must define the type of each associated value.\nYou can only assign a value of that type, allowing you to avoid errors due to incorrect typing.\nAdditionally, if you\u0026rsquo;re using a switch to handle actions based on the case, you\u0026rsquo;re required to address all cases.\nAnd Xcode itself helps you add the associated values if needed.\nExamples of Using Associated Values #Error Handling #It is common that, to complement the information of an error, you need additional data.\nThis information could be the message to display or something you need to solve the error.\nenum ArcadeMachineError: Error { case invalidSelection case insufficientFunds(coinsNeeded: Int) case userUnknown(user: String) } func displayError(_ error: ArcadeMachineError) { switch error { case .invalidSelection: print(\u0026#34;Invalid selection\u0026#34;) case .insufficientFunds(let coinsNeeded): print(\u0026#34;Insufficient funds. You need \\(coinsNeeded) coins\u0026#34;) case .userUnknown(let user): print(\u0026#34;User \\(user) is unknown\u0026#34;) } } displayError(.userUnknown(user: \u0026#34;pacman\u0026#34;)) Defining View Actions #Actions executed as a result of user interaction often require related values:\nenum UserAction { case login(username: String, password: String) case logout case updateProfile(name: String, age: Int) } func performAction(_ action: UserAction) { switch action { case .login(let username, let password): print(\u0026#34;Logging in with \\(username) and \\(password)\u0026#34;) case .logout: print(\u0026#34;Logging out\u0026#34;) case .updateProfile(let name, let age): print(\u0026#34;Updating profile with name: \\(name), age: \\(age)\u0026#34;) } } performAction(.updateProfile(name: \u0026#34;grogu\u0026#34;, age: 50)) Modeling Complex Data #For example, when dealing with multimedia elements.\nThese often come with different types of associated data.\nWith an enumeration and associated values, it\u0026rsquo;s as easy to define as it is to handle.\nenum MediaType { case image(url: String, resolution: (width: Int, height: Int)) case video(url: String, duration: TimeInterval) case audio(url: String, bitrate: Int) } func handleMedia(_ media: MediaType) { switch media { case .image(let url, let resolution): print(\u0026#34;Image URL: \\(url), Resolution: \\(resolution.width)x\\(resolution.height)\u0026#34;) case .video(let url, let duration): print(\u0026#34;Video URL: \\(url), Duration: \\(duration) seconds\u0026#34;) case .audio(let url, let bitrate): print(\u0026#34;Audio URL: \\(url), Bitrate: \\(bitrate) kbps\u0026#34;) } } handleMedia(.video(url: \u0026#34;R.Astley-never_gonna_give_you_up.mp4\u0026#34;, duration: 213)) Managing States #This is possibly the most widespread use of associated values in enums.\nAnd it\u0026rsquo;s because the states of an app often involve related data such as the user, the view being displayed, etc.\nenum AppState { case onboarding(step: Int) case loggedIn(userID: String) case loggedOut } func handleAppState(_ state: AppState) { switch state { case .onboarding(let step): print(\u0026#34;Onboarding step \\(step)\u0026#34;) case .loggedIn(let userID): print(\u0026#34;User logged in with ID \\(userID)\u0026#34;) case .loggedOut: print(\u0026#34;User logged out\u0026#34;) } } handleAppState(.onboarding(step: 1)) Advanced Filters #Associated values can also be very useful for filters.\nWhen you use them, you need to define the value of those filters.\nThus, you can easily set them.\nenum Filter { case priceRange(min: Double, max: Double) case category(name: String) case availability(isInStock: Bool) } func applyFilter(_ filter: Filter) { switch filter { case .priceRange(let min, let max): print(\u0026#34;Filter by price range: \\(min) - \\(max)\u0026#34;) case .category(let name): print(\u0026#34;Filter by category: \\(name)\u0026#34;) case .availability(let isInStock): print(\u0026#34;Filter by availability: \\(isInStock ? \u0026#34;In stock\u0026#34; : \u0026#34;Out of stock\u0026#34;)\u0026#34;) } } applyFilter(.priceRange(min: 10.0, max: 20.0)) Conclusions #You\u0026rsquo;ve seen how easy it is to associate values with different cases of an enum:\nYou just need to define them after each case. Take advantage of Xcode autocomplete to add the values you need. They help you have more stable, readable, and secure code. Examples where you can use them include:\nError handling Defining view actions Modeling complex data State management Advanced filters And if you want to practice, here is a playground with the examples: enum-associated-values.playground.zip Source #Associated Enumeration Values - Official Swift Documentation\n","date":"15 October 2024","permalink":"/blog/associated-enum-values/","section":"Blog","summary":"Learn how to manage multiple data types within a single enumeration","title":"Enhance Your Enums with Associated Values"},{"content":"A few weeks ago, while writing about key-paths, subscripts attracted my attention.\nSo, I continued investigating it, and now that I have seen the advantages it offers, I\u0026rsquo;ll explain how to take advantage of it to have more customized and readable code.\nWhat are subscripts in Swift #Subscripts in Swift provide you with a flexible way to access elements found in collections, sequences, or custom types.\nThese custom types could be classes, structures, or enumerations.\nSubscripts offer a simple syntax for setting and retrieving values without the need for separate methods for getters and/or setters.\nSubscripts are special methods that allow access to elements in a collection-like type.\nAnd for this, the same notation as arrays is used. That is, using square brackets [].\nHow to create subscripts #To create a subscript, you simply need to create a method with the name subscript.\nsubscript(index: Index) -\u0026gt; OutputType { get { // Return a value } set(newValue) { // Set a value } } It\u0026rsquo;s not mandatory to use set if you simply want to return the value, so it wouldn\u0026rsquo;t be necessary to explicitly indicate the get either.\nsubscript(index: Index) -\u0026gt; OutputType { // Return a value } How to access elements using subscripts in Swift #Following the previous syntax, here you can see how to create a subscript method for a structure that returns the element you ask for from the Fibonacci sequence.\nstruct Fibonacci { subscript(position: Int) -\u0026gt; Int { guard n \u0026gt; 1 else { return n } var a = 0, b = 1 for _ in 2...n { let temp = a + b a = b b = temp } return b } } As you can see, you can pass a position parameter to the subscript method to know the position of the element you want to obtain.\nAs you can also check, you don\u0026rsquo;t need a setter to set a value.\nSo if you indicate the position you want, you can have the value of that position.\nlet fib = Fibonacci() // Prints \u0026#34;13\u0026#34; print(fib[7]) Subscripts with multiple parameters #Subscripts can take multiple parameters, allowing more complex forms of access.\nHere you can see an example of a structure to create a 3D cube.\nstruct Cube3D { private var cells: [[[Int]]] let size: Int init(size: Int, defaultValue: Int = 0) { self.size = size self.cells = Array(repeating: Array(repeating: Array(repeating: defaultValue, count: size), count: size), count: size) } subscript(x: Int, y: Int, z: Int) -\u0026gt; Int { get { guard isValidIndex(x: x, y: y, z: z) else { fatalError(\u0026#34;Index out of range\u0026#34;) } return cells[x][y][z] } set { guard isValidIndex(x: x, y: y, z: z) else { fatalError(\u0026#34;Index out of range\u0026#34;) } cells[x][y][z] = newValue } } subscript(xRange: Range\u0026lt;Int\u0026gt;, yRange: Range\u0026lt;Int\u0026gt;, z: Int) -\u0026gt; [[Int]] { guard isValidRange(xRange: xRange, yRange: yRange, z: z) else { fatalError(\u0026#34;Range out of cube bounds\u0026#34;) } return xRange.map { x in yRange.map { y in cells[x][y][z] } } } private func isValidIndex(x: Int, y: Int, z: Int) -\u0026gt; Bool { return x \u0026gt;= 0 \u0026amp;\u0026amp; x \u0026lt; size \u0026amp;\u0026amp; y \u0026gt;= 0 \u0026amp;\u0026amp; y \u0026lt; size \u0026amp;\u0026amp; z \u0026gt;= 0 \u0026amp;\u0026amp; z \u0026lt; size } private func isValidRange(xRange: Range\u0026lt;Int\u0026gt;, yRange: Range\u0026lt;Int\u0026gt;, z: Int) -\u0026gt; Bool { return xRange.lowerBound \u0026gt;= 0 \u0026amp;\u0026amp; xRange.upperBound \u0026lt;= size \u0026amp;\u0026amp; yRange.lowerBound \u0026gt;= 0 \u0026amp;\u0026amp; yRange.upperBound \u0026lt;= size \u0026amp;\u0026amp; z \u0026gt;= 0 \u0026amp;\u0026amp; z \u0026lt; size } } After the parameters and the initializer, it has two subscript methods.\nThe first takes three position parameters, to determine the place in the 3D cube, and has both a getter and a setter.\nThe second also takes several parameters, of type Range.\nThis second subscript would allow obtaining a 2D slice of the cube.\nAs you are working with collections and sequences, it is very important to check that you never access positions outside the index to avoid crashes. That\u0026rsquo;s why the isValidIndex and isValidRange methods. And now, you\u0026rsquo;ll be able to assign and retrieve the cube values.\nvar cube = Cube3D(size: 5, defaultValue: 0) cube[0, 0, 0] = 1 cube[1, 2, 3] = 5 cube[4, 4, 4] = 9 // Prints \u0026#34;1\u0026#34; print(cube[0, 0, 0]) // Prints \u0026#34;5\u0026#34; print(cube[1, 2, 3]) // Prints \u0026#34;9\u0026#34; print(cube[4, 4, 4]) let slice = cube[0..\u0026lt;2, 0..\u0026lt;3, 0] // Prints [[1, 0, 0], [0, 0, 0]] print(slice) Type Subscripts #You can also define subscripts on the type itself, instead of on instances.\nTo do this, indicate the static keyword before subscript, just as you would create any static method.\nenum DayOfWeek: Int { case monday = 1 case tuesday case wednesday case thursday case friday case saturday case sunday static subscript(index: Int) -\u0026gt; DayOfWeek? { return DayOfWeek(rawValue: index) } } And now, if you want to access any day of the week from the enumeration, you just need to indicate its index.\n// day is equal to .wednesday let day = DayOfWeek[3] Note that Monday has been assigned 1 since, at least in Spain, Monday is the first day of the week. And it feels more natural to access it that way. If it hadn\u0026rsquo;t been indicated, in the previous example, day would be equal to thursday and the monday case would be accessed through index 0. Conclusions #Summarizing, about subscripts, the most important points:\nThey provide shorthand access to collection elements. They can be used both to get and set values. Multiple subscripts can be defined for a single type. Subscripts can have multiple input parameters. You can create static subscripts that don\u0026rsquo;t belong to the instance but to the type. But, keep the following in mind to make the most of them:\nUse them when they provide you with a more natural syntax for accessing elements in your custom types. Remember to handle errors and check bounds in subscripts. Make sure when you should use read-only or read/write subscripts. Use type subscripts only when it makes sense to access values directly on the type instead of on instances. And as usual, here is a playground for you to practice. Subscripts.playground.zip Sources #Subscripts - Official Swift Documentation\n","date":"8 October 2024","permalink":"/blog/swift-subscripts/","section":"Blog","summary":"Subscripts allow you to access different data in a more flexible and customizable way","title":"Access collections in a easy way"},{"content":"As project complexity grows, it\u0026rsquo;s common to create very similar code.\nYou already know the best way to optimize it is not to repeat it.\nOr at least, take advantage of common points.\nIn this case, using generics can be very helpful.\nThey may seem complex at first.\nBut if you get used to using them, you\u0026rsquo;ll have cleaner and more reusable code.\nWhy use generics in Swift? #Imagine you have a method as simple as the following, which shows a message with a value you pass as a parameter.\nfunc logString(value: String) { print(\u0026#34;INFO - Value recorded: \\(value)\u0026#34;) } // Prints \u0026#34;INFO - Value recorded: RandomResult\u0026#34; logString(value: \u0026#34;RandomResult\u0026#34;) But what if you also need to pass an integer value?\nThat method would also be simple.\nfunc logInt(value: Int) { print(\u0026#34;INFO - Value recorded: \\(value)\u0026#34;) } // Prints \u0026#34;INFO - Value recorded: 10\u0026#34; logInt(value: 10) But, as you\u0026rsquo;ve probably noticed, it\u0026rsquo;s practically the same as the first one.\nAnd what if you wanted to capture values of other data types? Double, Bool, Float\u0026hellip;\nYou\u0026rsquo;ve likely already guessed the problem this can cause.\nThere would be a significant amount of duplicated code, and therefore, inefficiency.\nThis is the problem that generics solve.\nThey allow you to create functions and types that work with different types without repeating code.\nHow do you create generics in Swift? #Swift allows you to create both generic functions and your custom generic types.\nType parameter names #Before creating generics, it\u0026rsquo;s important to understand how to name them.\nAlthough you may not have noticed, you\u0026rsquo;ve already used generics before.\nFor example, when you\u0026rsquo;ve used an array, which is defined as Array\u0026lt;Element\u0026gt;.\nElement is any type that makes up the array: String, Int, Double\u0026hellip;\nThe same goes for dictionaries, which in this case are defined as Dictionary\u0026lt;Key, Value\u0026gt;.\nThat\u0026rsquo;s why dictionaries work with two elements: a key and a value.\nIn some cases, descriptive names like Element, Key, and Value are used in generics\u0026hellip;\nBut in others, when there\u0026rsquo;s no meaningful relationship, a single uppercase letter is typically used.\nThe convention, in this latter case, is to use T, U, or V.\nAnd if you need more? Well, in that case\u0026hellip; you might want to review that code to avoid so many parameters 😉\nGeneric functions #Taking the earlier example about log messages, you could create a generic function as follows:\nfunc log\u0026lt;T\u0026gt;(value: T) { print(\u0026#34;INFO - Value recorded: \\(value)\u0026#34;) } The first difference is replacing the parameter types of the function.\nThat is, the type of the value parameter is T, instead of String or Int.\nT refers to any Swift type.\nThe second difference is including the generic type to be used, following the function name, between \u0026lt; and \u0026gt;.\nGeneric types #Generics aren\u0026rsquo;t limited to functions.\nImagine you want to create a store to store String values.\nIt could be a structure like the following:\nstruct StringsStore { var content: [String] mutating func add(string: String) { content.append(string) } mutating func clear() { content.removeAll() } } But again, you\u0026rsquo;d have the same limitation if you wanted to accept integers as well.\nSo, like in the case of functions, you\u0026rsquo;d need to replace the parameter type, using, for example, Element.\nAnd following the type name, you\u0026rsquo;d include the type with \u0026lt;Element\u0026gt;.\nstruct ValuesStore\u0026lt;Element\u0026gt; { var content: [Element] mutating func add(value: Element) { content.append(value) } mutating func clear() { content.removeAll() } } And now, you can use it with different types:\nvar intsStore = ValuesStore(content: [2,4,5]) intsStore.add(value: 10) // Prints \u0026#34;[2, 4, 5, 10]\u0026#34; print(intsStore.content) var doublesStore = ValuesStore(content: [2.5, 4.7, 5.8]) doublesStore.add(value: 4.7) // Prints \u0026#34;[2.5, 4.7, 5.8, 4.7]\u0026#34; print(doublesStore.content) Generic extensions #You can also create extensions of generic types.\nAnd you don\u0026rsquo;t need to specify the parameter type again.\nThat is, you can use the same one from its definition.\nIn the case of ValuesStore, it would be as follows:\nextension ValuesStore { var lastElement: Element? { content.last } } // Prints \u0026#34;10\u0026#34; print(intsStore.lastElement ?? \u0026#34;Empty store\u0026#34;) Restricting generics with Where #There may be situations where you need a generic for several types\u0026hellip; but not for all types.\nImagine the following case:\nfunc sumTwoValues\u0026lt;T\u0026gt;(valueA: T, valueB: T) -\u0026gt; T { // ERROR: Binary operator \u0026#39;+\u0026#39; cannot be applied to two \u0026#39;T\u0026#39; operands valueA + valueB } In the example above, you could use integers, doubles, or any type of number, since a sum will be performed.\nBut you couldn\u0026rsquo;t pass two Bool values because they can\u0026rsquo;t be summed.\nSolution? Restrict T to only allow types that conform to the Numeric protocol.\nTo do this, simply use the where clause to indicate the types for T.\nfunc sumTwoValues\u0026lt;T\u0026gt;(valueA: T, valueB: T) -\u0026gt; T where T: Numeric { valueA + valueB } And now, you can perform the desired operations.\n// Returns 7 sumTwoValues(valueA: 2, valueB: 5) // Returns 31.1 sumTwoValues(valueA: 10.5, valueB: 20.6) Using multiple generics #In the previous examples, you\u0026rsquo;ve seen how to use a single generic type: T, or Element.\nThis means it could accept any type, but with the limitation that said type was always the same.\nIn the previous example, where two values were summed, you could sum two integers or two doubles, etc\u0026hellip; But always the same value.\nUsing multiple types is very simple; you just need to declare other generic types, separated by commas. And keeping in mind the standard naming convention mentioned earlier.\nHere\u0026rsquo;s another example:\nfunc displayTemp\u0026lt;City,Temp\u0026gt;(city: City, temp: Temp) where City: StringProtocol, Temp: Numeric { print(\u0026#34;\\(city):\\(temp)\u0026#34;) } The code above is not optimal, as it could be simplified if the parameters conformed to the StringProtocol and Numeric protocols (displayT(city: String, temp: any Numeric)), has been used to show a simple example. And now you can use different generic types.\n// Prints \u0026#34;Valencia:20\u0026#34; displayTemp(city: \u0026#34;Valencia\u0026#34;, temp: 20) // Prints \u0026#34;Munich:5.5\u0026#34; displayTemp(city: \u0026#34;Munich\u0026#34;, temp: 5.5) Conclusion #So, to summarize the most important points:\nYou should use generics to unify similar code that performs operations with different types. You can use them in functions or types. You can use: Words like Element, Key, or Value if they have a meaningful relationship. Letters like T, U, or V for more abstract cases. If you want to constrain the types of a generic, use the where clause to specify a protocol. If you only specify one generic type, you must always use the same type in the function or type. And if you want to practice, here\u0026rsquo;s the playground with examples 🙂\ngenerics-swift.playground.zip Source #Generics - Swift Documentation\n","date":"1 October 2024","permalink":"/blog/generics-swift/","section":"Blog","summary":"Generics in Swift allow you to use very similar code for operations with different types","title":"Optimize code in Swift with generics"},{"content":"Last week I was able to attend an event that meant a lot to me and that I was looking forward to attending for the first time.\nBefore going, I asked the people I knew who had been there in previous years.\nEven so, what I saw exceeded my expectations.\nSo today, I\u0026rsquo;ll tell you how I experienced it and why I think you should go if you\u0026rsquo;re interested in development for Apple environments.\nBut not without first thanking hiberus, who made it possible for several colleagues from the iOS team to attend.\nOnce upon a time #NSSpain has been a notable event on the Apple developer calendar since its inception in 2013.\nCreated by Luis Ascorbe and Borja Reinares the event has already completed its 212nd edition and everything points (and I hope) to many more to come.\nOver the years, it has gained popularity, not only in Spain but internationally.\nIts collaborative environment has been key to building an important and close community within the Apple ecosystem.\nNSSpain 2024 #The 2024 edition was held from September 17 to 19 in Logroño, attracting professionals worldwide to share experiences and learn about the latest developments in iOS, macOS, watchOS, and tvOS development.\naaand we are open!@NSSpain XII, our 12th edition 🏴‍☠️ #nsspain2024 pic.twitter.com/sPAfM2Yvhd\n\u0026mdash; NSSpain XII (@NSSpain) September 18, 2024 A punto ya de empezar en #NSSpain pic.twitter.com/y2rIIxiU4Q\n\u0026mdash; Óscar Moreno (@oscarmorenodev) September 18, 2024 Another fact that in my opinion favors its success is the chosen date.\nAfter a recent WWDC with news and the launch of the new version of iOS, it is accessible to start new conversations or talks.\nOrganization #This year, the workshops (optional, which I was unable to attend) were held on September 17, and the main conferences took place on the 18th and 19th.\nFrom the very beginning, it was clear that the organizers had been concerned with creating a welcoming environment and promoting a space for collaboration and the exchange of ideas.\nIn addition, they have taken care of details so that during breaks, travel, and schedules, you have everything you need and in the shortest time possible.\nExamples of this are ordering a coffee during the break, with barely any queues, to the ease of getting to the winery.\nThe quality of the speakers was also notable, with experts who contributed both technical knowledge and their vision of the future of Apple development.\nTalks #The talks offered a deep focus on technologies such as Swift, SwiftUI, Testing, and Vision Pro.\nSoftware architectures, accessibility, and security were discussed, providing the necessary tools to improve applications.\nThe talks ranged from the more fun to the more inspiring and thought-provoking.\nThe sessions also stood out for their thematic diversity, ensuring that both beginner and experienced developers could take away something valuable.\nI\u0026rsquo;m not going to talk in detail about the talks, nor will I reveal the technical aspects, as they will be published on the NSSpain Vimeo channel, and I recommend that you watch them.\nBut I do want to give you some key points that I found important. Both from the technical point of view of Apple development and if you want to give talks at these types of events.\nI\u0026rsquo;m not going to tell you about all the talks here either, it doesn\u0026rsquo;t mean that those that weren\u0026rsquo;t there weren\u0026rsquo;t interesting, but it would make the article too long.\nSo when I recommend that you watch them, I recommend that you watch them all and that you decide which ones you like the most.\nPreparing Your App For Apple Intelligence - Matthew Cassinelli #This was the first of the talks. I was quite interested in it because Apple Intelligence is a very important development for me and I predict (over time) it will have great potential.\nMathew raised an important key: Design for Apple Intelligence, not for Siri Shortcuts.\nSo You Think You Know Swift? - Nick Lockwood #The expectations for the second talk were high, its title (So You Think You Know Swift?) posed an important challenge.\nIf you ask this question at an event full of Apple developers, you either bring something good or you lose credibility, and Nick did not disappoint.\nHe gave us a very technical talk with a collection of tricks to write more efficient code, very well organized by the different features of the language.\nBroken isolation - draining your credentials from popular macOS password managers - Wojciech Reguła #The next talk, I confess that at first, it was not one of the ones I was most expecting to see.\nBut Wojciech led it expertly, making it easy to follow, and with a surprising outcome.\nI did not expect to see what he taught and how the most popular password management applications on macOS save passwords.\nBelieve me, you will be surprised.\nGetting the most from Swift Macros - Daniel Steinberg #Another outstanding talk was by Daniel Steinberg, who has a significant number of books published on Swift development at Editors Cut\nDaniel raised the question of whether we should create our macros. And watching his talk I have a clear answer 😂, so you should not miss it either.\nIt was enviable how he was able to show the ins and outs of Macros.\nAnd although they are complex, knowing them is essential to take advantage of their full potential.\nTraining, Using, Distributing, and Managing Machine Learning models for your iOS app - Felix Krause #Someone who also raised a lot of expectations was Felix Krause, founder of fastlane, the open-source tool used in numerous iOS and Android projects to build and deploy.\nNot only that but he is now immersed in the ContextSDK project, which discovers the best way to monetize your users through artificial intelligence.\nSo as a technology enthusiast and increasingly AI enthusiast, it is a blessing to be able to listen to Felix on how to approach a business based on ML to get the information your users need.\nWithout a doubt, an inspiring example of how to take advantage of technology to provide value to your users.\nChasing Fun: Creating a Career You Love - Michael Flarup #A talk that also had a positive impact on me was Michael Flarup\u0026rsquo;s.\nI was looking forward to hearing from him because professional development is another field that interests me.\nMichael is an example of how to give a talk at this type of event, not only for what he told us but above all for HOW he told it.\nHe knew how to capture attention at all times, mixing his professional career with very funny moments, highlighting the importance of working on what you love and continuing to move forward without giving up.\nAlso, being more focused on design, I\u0026rsquo;m more curious about his books on icons for apps\nBest-in-class Pull Request - Danijela Vrzan #I was also looking forward to seeing Danijela.\nI\u0026rsquo;ve been following her blog for a while now, where she offers very interesting resources, not only about Swift but also about general development or design.\nDanijela talked about a very practical topic such as PRs, and showed only the differences between a good PR and one that isn\u0026rsquo;t.\nIt should be noted that a Pull Request not only affects the person who creates it but also the person who will review it or who will take it as an example.\nI would highlight the example she gave about how to deal with large PRs.\nTest your apps! How testing can make you more efficient and what are best practices for maintainable tests - Krzysztof Zablocki #The second day started strong (and not because of the wine from the night before in the cellar 😉)\nKrzysztof Zablocki started speaking, someone who has developed libraries and tools used by Apple, Disney, Airbnb, The New York Times or Vinted.\nAnd if you add to that portfolio the fact that the topic is testing, he had my full attention.\nKrzysztof showed us the best practices he has learned over this time for making tests, emphasizing that they are maintainable.\nWhich can undoubtedly save us a lot of time.\nWhat I found most important is that he raised on several occasions the importance of testing implementations, not behaviors.\nAccessibility and the Vision Pro - Robin Kanatzar #If you are interested in accessibility (and you should be) you can\u0026rsquo;t miss Robin\u0026rsquo;s talk either.\nA good foundation will be great for you, but if you don\u0026rsquo;t have one, don\u0026rsquo;t worry, he explains it very well and it\u0026rsquo;s easy to follow.\nHe explained the differences and new features that we have in this field, for the new spatial computing device.\nAnd the fact is that, in this new hardware, there are many details that we still don\u0026rsquo;t take into account.\nDetails that can make a difference in the experience that users have when using accessibility features.\nSwift Server-Side. The Apple Last Frontier - Adolfo Vera #Another of the talks that I also really liked was Adolfo\u0026rsquo;s.\nAlthough I had previously written on social media, I met there for the first time.\nAdolfo spoke about Vapor, a tool that is still undervalued for me, and that brings many advantages to application development, especially for Apple.\nShe gave us an overview of what we can do, and what is the best way, providing tips that will be of great help for your first developments with Vapor.\nBut without a doubt, I would highlight how she was able to capture the attention of the audience throughout the talk 🙂.\nA very fun and recommendable talk.\nThe Date-ing Game - Ellen Shapiro #Ellen also brought a very interesting talk, although the topic might not seem so at first: dates.\nIt was also very enjoyable and fun to follow the talk and discover the number of elements that we can (and should) take into account when working with dates.\nEspecially if we have to work with several formats.\nEssential if this is your case.\nWarp Speed ​​with Metal Performance Shaders - Francesco Marini #Francesco gave us a masterclass on Apple hardware and how to take advantage of it to improve the graphical performance of games or apps.\nIt was a very in-depth talk, which I will watch again (pausing the video at times 😅) to be able to go deeper and look for relevant information.\nLots of quality information.\nSpecially important to watch if you work with graphics.\n“It Scrolls Like Butter” Part 2: Implementing High Performance Scrolling in Threads - Tim Oliver #Oliver\u0026rsquo;s talk also raised great expectations, and it is not every day that you can see an iOS engineer live on Instagram.\nAnd if there\u0026rsquo;s one thing you do on Instagram, it\u0026rsquo;s scrolling.\nSo it was great to hear so many details, and in such a fun and enjoyable way, that improved the user experience.\nBuilding amazing user experiences using SharePlay - Vanessa Furtado #Ending the second day, I was very pleasantly surprised by Vanessa\u0026rsquo;s talk.\nUntil that moment, I thought that SharePlay was limited to sharing video and audio.\nBut she showed us how they use it in iFood.\nIn addition to making the talk very interesting, it was creative and I\u0026rsquo;m sure that it has brought more than one (like me) new ideas for their development.\nSoftware engineer or code craftsman - Michael Fletcher #To close the event, Michael brought an interesting question: Software engineer or code craftsman?\nShowing real-life examples and comparisons, he invited us to think about what we do and what we would like to do.\nOne more thing #I\u0026rsquo;ve already said several times that I liked it not only because of the technical level but also because of how much fun I had.\nAnd one of those special moments was when we were able to learn how to properly hold a glass and taste the wine 😂\nI don\u0026rsquo;t know if it will appear in the videos, but it certainly deserves it.\nwe got @facumenzella and @nyeeu hijacking (a bit) the schedule to learn how to properly hold and tate a glass of wine 🍷 #NSSpain2024 pic.twitter.com/IsP8EYU6An\n\u0026mdash; NSSpain XII (@NSSpain) September 18, 2024 It\u0026rsquo;s not all about code #NSSpain 2024 was not just a space to learn about technology, but also to connect with the community.\nNetworking was an essential component, and social activities brought the opportunity to meet other professionals in a more relaxed way.\nOne of the most enriching experiences was the visit to a winery on September 18, where after the presentations, we were able to learn details about wine production and storage, followed by a cocktail dinner that opened up more opportunities for conversation and collaboration.\nVisit to the winery pic.twitter.com/959T2BDFVi\n\u0026mdash; Óscar Moreno (@oscarmorenodev) September 18, 2024 Additionally, during the evenings, most attendees gathered on and around the famous Laurel Street, a place known for its lively atmosphere and gastronomy (highlighting the pintxos and wine 🍷).\nThese nights out allowed us to continue sharing ideas in a more informal way.\nIn addition, visiting Logroño on these dates had an added attraction, and that is that on September 20th the local festivities began, creating a festive atmosphere that enhanced the experience of the event.\nWhy you should go to the next NSSpain #NSSpain continues to be one of the best opportunities for Apple developers looking to improve their skills.\nLearning from experts and building strong professional relationships is a must if you care about your professional development.\nFrom both a technical and human point of view, the event surpasses itself.\nIt offers not only valuable technical content but also a strong and accessible community.\nThere is no doubt that future editions will continue to be a reference point in the Apple developer calendar internationally.\nIf you are looking to improve your career as a developer, learn from the best, and expand your contacts network, NSSpain is the conference you should attend.\nConclusions #NSSpain 2024 demonstrated once again why it is an unmissable event for Apple developers, not just from Spain.\nIt has become an international reference point where it is important to go if you want to: learn, connect with other professionals, and have fun (not necessarily in that order 😉)\n","date":"24 September 2024","permalink":"/blog/nsspain-2024-en/","section":"Blog","summary":"NSSpain is a special international conference about Apple Engineering","title":"Why you should attend NSSpain"},{"content":"Key-paths are a feature of Swift that can be confusing at first.\nHowever, with the arrival of SwiftUI, their usage has expanded.\nAnd their use is not limited to the new interface framework.\nUnderstanding them can provide you with alternatives for accessing data in types.\nWriting a Key-Path Expression #Key-path expressions have the following structure\n\\\u0026lt;#type name#\u0026gt;.\u0026lt;#path#\u0026gt;\nThe type name is the concrete name of a type (structure, class, enumeration\u0026hellip;) including basic types like Int, [String], or Set\u0026lt;Double\u0026gt;.\nThe path can contain a property, a subscript, or optionals.\nWhen compiled, the key-path expression is replaced by an instance of the KeyPath class Accessing a Value Using a Key-Path #So, if you want to access a key-path value, you can do so through the subscript that requires a ket-path, which is available for all types.\nstruct Driver { var name: String } let driver = Driver(name: \u0026#34;Fernando Alonso\u0026#34;) let pathToNameProperty = \\Driver.name let driverName = driver[keyPath: pathToNameProperty] print(driverName) // Prints \u0026#34;Fernando Alonso\u0026#34; Keep in mind that the type name can be omitted when type inference can determine the expected type.\nstruct Race { var winner: Driver func displayWinnerProperty(keypath: KeyPath\u0026lt;Driver, String\u0026gt;) { print(\u0026#34;The winner is \\(winner[keyPath: keypath])\u0026#34;) } } let sai = Driver(name: \u0026#34;Carlos Sainz\u0026#34;) let race = Race(winner: sai) race.displayWinnerProperty(keypath: \\.name) // Prints \u0026#34;The winner is Carlos Sainz\u0026#34; Identity Key-Path #Additionally, the path can refer to self, known as an identity key-path (\\.self).\nThe identity key-path refers to the instance itself.\nDue to this, it can be useful to replace an entire instance with a single line.\nvar verstappenPoints = (a: 25, b: 18, c:25) // Equivalent to verstappenPoints = (a: 18, b: 25, c: 25) verstappenPoints[keyPath: \\.self] = (a: 18, b: 25, c: 25) print(verstappenPoints) // Prints \u0026#34;(a: 18, b: 25, c: 25)\u0026#34; But this feature is often leveraged in SwiftUI, for example, in a ForEach.\nList { ForEach([2, 4, 6, 8, 10], id: \\.self) { Text(\u0026#34;\\($0) is even\u0026#34;) } } Accessing Multiple Values from a Type #Another feature is that you can access nested properties.\nSo, you can refer to the property of a property value.\nHere\u0026rsquo;s an example:\nstruct Championsip { var winner: Driver init(winnerName: String) { self.winner = Driver(name: winnerName) } } let champion = Championsip(winnerName: \u0026#34;Max Verstappen\u0026#34;) let nestedKeyPath = \\Championsip.winner.name let championName = champion[keyPath: nestedKeyPath] print(championName) // Prints \u0026#34;Max Verstappen\u0026#34; Accessing Subscripts #Also, there are another possibility. The path can include subscripts using square brackets.\nlet tracks = [\u0026#34;Spa\u0026#34;, \u0026#34;Monza\u0026#34;, \u0026#34;Montmelo\u0026#34;, \u0026#34;Suzuka\u0026#34;] let fasterTrack = tracks[keyPath: \\[String].[1]] print(fasterTrack) // Prints \u0026#34;Monza\u0026#34; In this case, it\u0026rsquo;s essential that the subscript parameter type conforms to the Hashable protocol. Also, you should note that in this case, the captured values use value semantics, not reference semantics.\nSo, a copy will not update its value even you modify the original.\nHere\u0026rsquo;s an example:\nvar index = 1 let pathToTrack = \\[String].[index] let closure: ([String]) -\u0026gt; String = { strings in strings[index] } print(tracks[keyPath: pathToTrack]) // Prints \u0026#34;Monza\u0026#34; print(closure(tracks)) // Prints \u0026#34;bonjour\u0026#34; index += 1 print(tracks[keyPath: pathToTrack]) // Prints \u0026#34;Monza\u0026#34; // Because \u0026#39;fn\u0026#39; closes over \u0026#39;index\u0026#39;, it uses the new value print(closure(greetings)) // Prints \u0026#34;Spa\u0026#34; Accessing Optional Values #To access optional values, you simply need to use optional chaining or force unwrapping.\nAgain, an example.\nlet firstTrack: String? = tracks.first let count = tracks[keyPath: \\[String].first?.count] print(count as Any) // Prints Montmelo characters number \u0026#34;Optional(8)\u0026#34; Key-Path as an Alternative to Closures and Functions #You can also use key-paths in other contexts.\nFor example, in situations where you need to pass a function or closure.\nstruct Lap { var time: Double var valid: Bool } var timelaps = [ Lap(time: 106.0, valid: true), Lap(time: 99.5, valid: true), Lap(time: 102.0, valid: false) ] // Usual let validLaps1 = timelaps.filter{ $0.valid } print(validLaps1.count) // Prints \u0026#34;2\u0026#34; // Equivalent with key-paths let validLaps2 = timelaps.filter(\\.valid) print(validLaps2.count) // Prints \u0026#34;2\u0026#34; Note at the end of the example, where you can filter the valid laps with .filter(\\.valid) instead of most common .filter{ $0.valid }\nScope of Key-Paths #Lastly, regarding key-paths, there\u0026rsquo;s something important you should keep in mind.\nThe results of a key-path expression are only evaluated at the point where that expression is evaluated. If you call a function within a subscript in a key-path expression, the function will only be called once, as part of the expression\u0026rsquo;s evaluation, but not every time the key-path is used.\nYou can see this new example:\nfunc displayValidLap() -\u0026gt; Int { print(\u0026#34;Valid lap!\u0026#34;) return 0 } let greetingKeyPath = \\[Lap][displayValidLap()] // Prints \u0026#34;Valid lap!\u0026#34; // Using greetingKeyPath doesn\u0026#39;t call displayValidLap again. let someLap = timelaps[keyPath: greetingKeyPath] Conclusion #Key-paths are complex and can be difficult to see their utility.\nHowever, they are used in SwiftUI, so it\u0026rsquo;s important to know and understand them.\nMost importantly, remember that:\nTheir structure is \\\u0026lt;#type name#\u0026gt;.\u0026lt;#path#\u0026gt;. The type name is the name of the type and the path is the name of the property\u0026rsquo;s type. When compiled, they are replaced by an instance of the KeyPath class. You can access: A parameter An entire instance (\\.self) A subscript An optional value And since practice makes perfect, here\u0026rsquo;s a playground for you to play with 😉\nkey-paths-swift.playground.zip Source #Key-path Expressions - Swift Documentation\n","date":"17 September 2024","permalink":"/blog/swift-keypath-expressions/","section":"Blog","summary":"Key-path expressions offer an alternative for data access in types","title":"Understanding how key-paths work"},{"content":"The first time I encountered a property wrapper was in SwiftUI, but it\u0026rsquo;s a feature of Swift that you can use since version 5.1.\nProperties define characteristics of types, but often you have to perform (the same) operations on them.\nThe simplest way to perform these operations is by using property observers, which I mentioned earlier.\nBut what if you need to perform those operations too many times? If you only use observers, you\u0026rsquo;ll soon have duplicated code.\nThe solution is to use property wrappers.\nProperty Wrappers in Swift #Property wrappers add a layer of separation between the code that defines a property and the code that manages how it is stored.\nTheir main advantage is that you write the code that operates on that property once, and then reuse it in the properties you need.\nHow to Create a Property Wrapper in Swift #In the following code, you can see how a property wrapper is created:\n@propertyWrapper struct DashCase { private var text = \u0026#34;\u0026#34; var wrappedValue: String { get { text } set { text = newValue.lowercased().replacingOccurrences(of: \u0026#34; \u0026#34;, with: \u0026#34;-\u0026#34;) } } } You can create a class, a structure, or an enumeration, and it must be preceded by the @propertyWrapper attribute directive.\nThe type must have a property called wrappedValue, which will return the value you define when a property with the created property wrapper is accessed.\nThus, we could use the previous property wrapper as follows:\nstruct Branch { @DashCase var name: String } var branch = Branch() branch.name = \u0026#34;Random Branch Name\u0026#34; print(branch.name) // Prints \u0026#34;random-branch-name\u0026#34; This way, Branch does not need to format the name each time. Additionally, you can use DashCase whenever you need to format text to lowercase and hyphens.\nstruct File { @DashCase var name: String } var file = File() file.name = \u0026#34;Random File Name\u0026#34; print(file.name) // Prints \u0026#34;random-file-name\u0026#34; Note that if you declare an additional property in the type, it is advisable to declare it as private. This ensures that in the implementation, the value can only be accessed through the wrappedValue.\nSetting Initial Values for a Property Wrapper #Additionally, if needed, you can use an initializer.\nThis allows you to create the property wrapper in the following way:\n@propertyWrapper struct SnakeCase { var wrappedValue: String init(wrappedValue: String) { self.wrappedValue = wrappedValue.replacingOccurrences(of: \u0026#34; \u0026#34;, with: \u0026#34;_\u0026#34;).lowercased() } } This can be an advantage, for example, when you need to make it mandatory to create the object with an initial value, as you will have to provide one.\nstruct Table { @SnakeCase var name: String } var table = Table(name: \u0026#34;hello World\u0026#34;) print(table.name) // Prints \u0026#34;hello_world\u0026#34; Projected Value of a Property Wrapper #In addition to the wrapped value that a property wrapper returns, as seen in the previous examples, it also allows for a projected value.\nThis projected value could be used, following the previous examples, to determine if the value has been formatted.\n@propertyWrapper struct Capitalized { private var text: String private(set) var projectedValue = false var wrappedValue: String { get { text } set { text = newValue.capitalized } } init(wrappedValue: String) { self.text = wrappedValue.capitalized projectedValue = true } } With this, you could do the following:\nstruct CustomText { @Capitalized var title: String } let text = CustomText(title: \u0026#34;One more thing...\u0026#34;) print(text.title) // Prints \u0026#34;One More Thing...\u0026#34; print(text.$title) // Prints \u0026#34;true\u0026#34; Conclusion #As you can see, using property wrappers brings the main advantage of reusing code across parameters of different types that need to perform the same operations.\nThe most important points:\nYou need to use the @propertyWrapper directive, and it must have at least one property called wrappedValue. You can use a projectedValue property if you want to expose additional functionality. If you need an additional property to perform operations, declare it as private so that it can only be modified from within the property wrapper. If you want to practice, here is a playground with examples 😉\nproperty-wrappers-in-swift.playground.zip Sources #Property Wrappers - Swift Documentation\nProperty Wrappers in Swift - Swift by Sundell\n","date":"10 September 2024","permalink":"/blog/property-wrappers-in-swift/","section":"Blog","summary":"Property wrappers allow you to encapsulate repetitive code for properties","title":"How to create Property Wrappers for reuse code"},{"content":"In (many) cases, you will spend more time reading code than writing it, which is why it\u0026rsquo;s crucial to understand what you\u0026rsquo;re reading.\nMoreover, it’s a great way to learn more about programming concepts.\nDo you know the difference between open and public? Why is fileprivate not the same as private?\nKnowing this will prevent you from wasting time on errors that might otherwise be difficult to explain, and it will help you structure your application better.\nAccess control allows you to manage access to certain parts of your code from other parts of the same code. This lets you hide the implementation details of types, properties, functions, and more (which we’ll refer to as entities).\nIt’s not always necessary to use them since Swift provides a default access level for basic scenarios.\nSource files, modules, and packages #Before continuing, it’s important to understand the following elements to know where access is allowed.\nSource file #A source file is a file with a .swift extension that resides within a module.\nKeep in mind that normally, each type (class, structure, or enumeration) is defined in a source file, but sometimes several related ones can be in the same file.\nModule #A module is a unit of code distribution.\nIt can be a framework or an application, which will form a unit.\nModules can be imported from other modules using the keyword import.\nPackage #A package is a group of modules that form a unit.\nWhen creating a package, you must specify the modules it will contain.\nAccess levels in Swift #Now you can see the different levels ordered from least to most restrictive.\nopen #When an entity is defined with open, you can access it from any source file within the same module.\nAdditionally, it can also be accessed from source files in other modules that import the module containing that entity.\nOn the other hand, it allows access from subclasses or overriding from outside the module.\nYou should use it when creating a public interface for a framework.\npublic #Using public is almost the same as open.\nThe difference is that in the case of public, you cannot access it from subclasses or override methods.\npackage #This access level is available from Swift 5.9.\nAs you might have guessed, it allows access from any source file within the same package.\ninternal #Using internal allows access from any source file in the same module, but not from different modules.\nIt’s commonly used when defining the structure of a simple app or framework.\nYou’ll rarely see it explicitly, as it’s the default access level. That is, if you don’t see any access control before the entity\u0026rsquo;s keyword (struct, class, let, var, etc.), it’s because it’s using internal.\nfileprivate #In this case, with fileprivate, entities can only be accessed from the same source file that contains them.\nThis means, for example, if you have different classes and structures in a .swift file, the one marked with fileprivate can be accessed by the other classes and structures within that same file.\nprivate #Finally, private only allows access to its content from its declaration.\nThat is, if a class is marked with this access control, its entities can only be accessed from within that class.\nHow to use access levels in Swift #To use the different levels, you simply need to indicate it before the entity’s keyword.\nSee the following examples:\nopen class MyClass {} public struct MyStruct {} internal let myConstant = \u0026#34;Hello World!\u0026#34; fileprivate var myVar = \u0026#34;Hello again!\u0026#34; private func myMethod() {} Principle of access levels #The different access levels follow a general principle:\nYou cannot define any entity inside another entity that has a lower (more restrictive) access level. That is, you cannot define a public variable inside a private class; nor can you define an open variable in an internal method.\nDefault access level #The default access level is internal, so if you don’t specify anything before the entity, this is the level that will be applied.\nConclusion #You’ve seen the different access levels: open, public, internal, fileprivate, and private, and the restrictions each one entails.\nIt’s important to use the appropriate level to maintain clean, organized, and efficient code, allowing access only to those who need it.\nRemember that if you don’t specify anything, Swift will consider the entity as internal.\nSources #Access Control - Swift Documentation\n","date":"3 September 2024","permalink":"/blog/access-levels-swift/","section":"Blog","summary":"Access levels define where your code can be accessed","title":"What the different access levels mean in Swift"},{"content":"Apple devices stand out for several reasons: a design that identifies them and many want to copy, durability and reliability, but above all, an ecosystem that works as a whole when providing services.\nAlthough this has its disadvantages, the first advantage that usually comes to mind is the ease of coordinating all these components.\nAnd if there is one area where coordination between the different components is key, it is in security.\nIn this article I do not want to limit myself to mentioning more or less current news where it is \u0026ldquo;said\u0026rdquo; that it is a secure system. Instead, I want to list, based on the brand\u0026rsquo;s official documentation, the measures they use to ensure that your data and mine are safe.\nThose from Cupertino divide their security measures into several areas, both physical and logical, that cover all the actors involved in this matter.\nHardware and biometrics #The basis of a device\u0026rsquo;s security is its hardware. Taking an extreme example, imagine a device that had no possibility of accessing the Internet because it did not have a modem or network card, or that did not allow the entry of volumes of data: memory cards, USBs, SSDs\u0026hellip;\nIn this case, these devices would limit the possibility of malicious code injection, or the extraction of user data. Which could pose a lower security risk.\nTherefore, the security of Apple devices begins with their hardware, and more specifically in the functions of their processors.\nDuring recent years, Apple has invested great efforts in designing its own chips, and perfecting the systems housed in them, called System on Chip or SoC\nAn example of this is Secure Enclave, a security subsystem found in the most recent versions of Apple devices.\nSecure Enclave is separate from the main processor to maintain secure data in case the security of said processor is breached.\nIn addition, it has been designed in the same way as the SoC, with:\nA boot ROM that establishes the hardware root of trust An AES engine for cryptography Protected memory To identify users, Apple uses biometrics.\nThe best known method is FaceID, the system through which, through your eyes, you can perform operations such as: unlocking the device and confirming payments and purchases.\nFaceID uses neural networks to validate the match and learn about changes in the individual\u0026rsquo;s appearance.\nAnd all this is achieved through the TrueDepth camera, which stands out for being able to make 3D scans of our face, which prevents, for example, a simple image of us from being used to impersonate our identity.\nOn the other hand, older devices, as well as Magic Keyboard keyboards, have TouchID, which is used for the same cases as those mentioned above, but through our digital ones.\nBut it is not only limited to using the fingerprint recorded in its first configuration, since the sensor will detect the new nodes that exist with each use.\nAdditionally, it is important that you know that Apple provides APIs that allow applications to use these biometric elements to develop secure apps.\nOS #Operating systems have various services and resources that applications, users and others access to manage information.\nThe security of the system, therefore, is responsible for managing these accesses, only to those who must do so.\nA very important element in this section would be a secure boot, enough to prevent any unwanted code from being inserted into it, and therefore, achieve a high privilege being able to access any part of the system.\nThis is achieved by ensuring that each step is safe, and control is not passed to the next until it is completely validated.\nOnce the system is running, another factor that determines security is updates. In this case, the system\u0026rsquo;s mission will be to ensure that it is not possible to install older and consequently possibly vulnerable versions.\nOn the other hand, volumes (data storage devices), as input and output media, can also be violated and used to compromise security.\nTo avoid this, Apple in this case, since macOS 11, uses added encryption measures to protect the system code, so that it cannot be modified.\nData encryption and protection #iPhones and iPads use a type of encryption called Data Protection, while data on Intel-based Macs They were secured with a volume encryption method they called FileVault.\nThus, on mobile devices (iPhone and iPad), use for shorter periods of time. In short, codes are used, which are easier to enter. They can be used with four digits, six, or of indeterminate length.\nHowever, for access on computers, where we usually spend several hours in front of them, passwords are used.\nObviously, the longer the code or password, the more difficult it will be for them to find out. This is because, in addition to requiring more brute force attempts, the more complex it is, the more secure the encryption key will be.\nAs I told you before, this combined with the use of FaceID and TouchID, improves the user experience, without reducing the security of your data.\nAs an additional layer, Apple applies a delay time in the event of failure.\nFor example, on iOS and iPadOS devices they are as follows:\nAttempts Delay 1-4 None 5 1 minute 6 5 minutes 7-8 15 minutes 9 1 hour Additionally, if after 10 attempts, \u0026ldquo;Wipe data\u0026rdquo; is enabled, the content and settings are deleted from storage\nAnd in the case of macOS, the delay times coincide, but if there are more than 10 attempts, it will be deactivated.\nFinally, Apple also protects data, using a technique called secure data storage, which prevents different applications from accessing our user data such as Calendar, Camera, Contacts, Reminders, Notes\u0026hellip; .\nApp security #Apps pose a serious risk to the security of your data, in that it is the main means of code entry into your data.\nHowever, it is possible to do without them, since they are also the first source of functionality for the hardware.\nI have already mentioned a first layer before, with the secure data store.\nIn this case, you can differentiate between apps from the App Store and those downloaded from other sources, something that, until recently, was exclusive to macOS.\nIn the case of macOS, starting with version 10.15, all downloads outside the App Store must be certified by Apple to avoid the security message and blocking.\nOn the other hand, the same macOS system has its own antivirus protection system to prevent the execution of malicious code.\nIn the case of apps for iOS and iPadOS, all must be signed using the mechanism implemented by Apple to upload said apps to the App Store. This is done through certificate validation provided by the Apple Developer Program\nThese validations are not only carried out by developers or companies that distribute apps to end users. But it is a process that must also be gone through by organizations that develop internal apps for their employees.\nBut, all this refers only to the installation.\nApple further improves security by adding an additional layer to the app execution environment through three elements.\nThe first is isolation, and that is that all third-party apps run in an isolated environment, to prevent them from accessing files stored by other apps, or modifying the content of the system.\nSo to access other people\u0026rsquo;s information, you must go through the methods that Apple establishes in the system.\nThe second are authorizations that, through key-value pairs, allow authentication outside the execution environment, such as a user ID in UNIX. These authorizations are secured by digital signature, so it is not possible to modify them.\nAnd the third and last element is the randomization of the address space, which helps protect the system against attacks that make use of corrupted memory faults.\nServices #The first component that gives us access to the services that Apple provides on its devices is the Apple ID. This has a series of usual requirements to prevent a third party from gaining access to it. These requirements, when creating your password are:\nAt least eight characters Combination of numbers and letters They must not have more than three identical or consecutive characters It should not be in common use. Additionally, by default, Apple has two-factor authentication, which prevents unwanted access in case someone gets your password.\nOn the other hand, if you want to reset the password, it must be done from another trusted device.\niCloud is probably the company\u0026rsquo;s most used service, which allows the storage of data in the categories photos, contacts, email, health\u0026hellip; so every effort is little to keep Apple as an actor committed to security.\nIn this case, Apple offers two options to encrypt your content:\nStandard Protection: User data is encrypted and its keys are stored in the data centers of Apple, who can only help recover data, but does not have it. 14 categories of data will use end-to-end encryption. Advanced Protection: Encryption keys can only be accessed from a trusted device, which is where they are protected by end-to-end encryption. In this case, there are 23 categories that will make use of it. Another element, increasingly used, and without a doubt to which we must pay special attention is Apple Pay, which allows payments to be made.\nAnd here Apple protects payments through: Secure Element and the NFC Controller.\nThe first includes applets (components that run in the context of another program) certified by card issuers or payment networks. In this way, they are the only ones who know the encryption keys to access the data in the applets.\nIn the second case, the controller acts as a gateway, allowing the first to make the payment at a contactless point-of-sale terminal. This allows the connection, once the user has authorized the payment through biometrics or code.\nNetwork security #As for the network part, and even though it is the main element of communication between devices, I will limit myself to giving the technical data without going into detail.\nThus, iOS, iPadOS and macOS are compatible with TLS versions:\nTLS 1.0 TLS 1.1 TLS 1.2 TLS 1.3 Datagram Transport Layer Security (DTLS) TLS being compatible with AES128 and AES256.\nRegarding virtual private networks (VPNs), the compatible protocols are:\nIKEv2/IPsec with shared secret authentication, Elliptic Curve Digital Signature Algorithm (ECDSA) certified RSA certificates, EAP-MSCHAPv2, or EAP-TLS. SSL VPN with the appropriate client app from the App Store. L2TP/IPsec with MS-CHAPV2 password user authentication and machine authentication using shared secret (iOS, iPadOS, and macOS), and RSA SecurID or CRYPTOCard (macOS only). Cisco IPsec with user authentication via password, RSA SecurID or CRYPTOCard, and machine authentication using shared secret and certificates (macOS only). Development Kit #Finally, Apple provides you with a series of kits to develop apps that expand their services.\nThese kits are: HomeKit, CloudKit, SiriKit, DriverKit, ReplayKit and ARKit.\nIn this case, perhaps the service where privacy comes most into play is the case of HomeKit, in charge of managing home devices, as sensitive as video surveillance cameras, or audio recording devices like HomePods.\nTo secure these devices, HomeKit relies on Ed25519 key pairs made up of a public key and a private key.\nThese keys will be stored in the iCloud Keychain, so they can be updated between devices.\nConclusion #The elements that influence the security of Apple devices are many and of different kinds. But, whether you are a programmer, manager or user, knowing them is of great importance, mainly to be aware of the risks to which we are exposed.\nAnd if your work is also influenced by this security, you can provide great value to the users of your apps.\n","date":"9 May 2024","permalink":"/blog/apple-security/","section":"Blog","summary":"Apple combines numerous elements to promote and maintain security on its devices and apps","title":"Apple devices Security Guide"},{"content":"One of the main advantages of developing apps natively for Apple is that with the same language (Swift) and the same UI framework (SwiftUI) you can create apps for all its devices.\nHowever, there are subtle differences between these devices. And in turn, between different versions of these.\nTherefore, you can take a step further in the development of your products if you take into account some factors, achieving a better experience for your users.\nTherefore, today I want to present these details to you.\nResponsive design #Thanks to SwiftUI, it is not necessary to make adjustments to the constraints as was the case with UIKit, which allowed defining the distances between elements and with respect to the edge of the screen. So in that sense, you should not worry.\nBut, what you should keep in mind is that using the dynamic sizes and the fonts provided by Apple allow you to ensure compatibility with regards to the interface. In addition, the development part is simplified and streamlined.\nYou can find more info in the official SwiftUI documentation: [Applying to strong dynamic sizing support](https://developer.apple.com/documentation/swiftui/applying-custom-fonts-to-text#Apply-a -font-supporting-dynamic-sizing)\nIn addition, thanks to the SwiftUI preview, you can check how the views will look on multiple devices simultaneously.\nCreate a cross-platform app #Xcode allows the creation of cross-platform apps, in this way, there will be no different targets for iOS and macOS.\nCreate a dynamic layout #There are layout modifiers in SwiftUI that allow you to adjust how the view will be displayed, based for example on the value of a variable (bound by example to the subviews that exist)\nUse a minimum recent system version #Apple cares about this compatibility, since it is a huge benefit for its users to have an advantage in having their devices. It is very convenient to take a photo with the iPhone, view it on the iPad, and then edit it with the Macbook Pro.\nAnd this is something that is increasingly taken into account, which is why the most recent versions will facilitate integration and compatibility so that an app can be used on all these devices.\nDon\u0026rsquo;t forget about dark mode #Another important detail that you can see in the SwiftUI preview is that with a simple click you can check how your app looks in light or dark mode.\nThis is a feature that is increasingly used by users, not only by choosing the mode that visually most attracts them. Many times it is configured automatically. In this way, during the day we will see the light mode, and at night the dark mode.\nFor this reason, it is also very important to use the colors and modifiers provided by SwiftUI as much as possible, so that they have their different color versions.\nTry different screen layouts #Sometimes, users prefer to use the device in portrait mode, or in landscape mode.\nYes, again, thanks to SwiftUI and not having to depend on constraints, it has made developments easier for us. But it is important to check (also in the preview) how the views will be displayed in the different screen orientations.\nConsider iPad views #SwiftUI has the NavigationSplitViewStyle protocol to be able to display views divided into panels.\nThe clearest example is in the Mail app, where they are shown, from left to right:\nThe different mailboxes The content of the mailbox The selected message from that mailbox. This is useful for collections, which in turn have nested information But remember to check the result in the preview of each device.\nTake advantage of the unique capabilities of each device #While developing an app that works across multiple devices is crucial, it\u0026rsquo;s also essential to take advantage of each device\u0026rsquo;s unique capabilities.\nFor example, the Apple Watch offers unique health functionalities, while the Apple TV can focus on multimedia capabilities.\nMake sure you design your app not only to be compatible, but also to take full advantage of the specific features of each device.\nDevice status management #Managing device state is critical when designing for multiple platforms.\nThis includes handling changes such as screen rotation, interruptions such as incoming calls or alerts, and system settings such as changes to accessibility settings.\nListens to system events and responds appropriately to ensure create a seamless and consistent experience across all devices.\nConclusion #As you have been able to check all the aspects to take into account, they can be summarized in two:\nUse the elements provided by Apple natively Preview results on different target devices. This will allow you to take advantage of one of the Cupertino company\u0026rsquo;s strengths: the user experience of its ecosystem.\n","date":"25 April 2024","permalink":"/blog/apple-ecosistem-compatibility/","section":"Blog","summary":"Swift makes it easy to create apps for multiple devices, but we must ensure compatibility","title":"Ensure compatibility of apps for the Apple ecosystem"},{"content":"Properties are a fundamental feature in any object-oriented or, as in the case of Swift, protocol-oriented language.\nThink of an object, for example, a smartphone. You could see that a smartphone has:\nBehaviors Characteristics Among the behaviors you could identify: Call a contact, browse the internet, take a photo\u0026hellip; That is, actions you can perform with the device, or in other words: what it can do.\nAnd about the characteristics, you could see: the size of the screen, the weight, the color\u0026hellip; That is, details that define what the object is like, or rather, properties\nAnd the properties are those that will store the characteristics of the types (classes, structures, enumerations or protocols) that define said property.\nWith that, we can define the properties in 2 different ways: through stored properties, or through calculated properties.\nStored properties #Stored properties are the simplest way to define a property. Within a type, you indicate its property; and to do this, write the type of value (constant or variable), next to the name of the property.\nFrom there, you can indicate the type of value (and you will assign the value when you initialize it) or you can assign it a value, and Swift will infer the type of data you are storing.\nstruct Movie { let title: String let year: Int var released = false } var theFuture = Movie(title: \u0026#34;The future\u0026#34;, year: 2026) In that example, you can see 3 properties for the Movie structure.\nThe title and year, you must indicate it at initialization. While, if you do not indicate otherwise, the instance is created indicating that the movie has not been released since released will be initialized as false if you have not indicated anything.\nProperties on constant instances #It is important that you keep in mind that if you create an instance in a constant, two different situations can occur, depending on whether it is a structure or a class.\nIn the case of structures, since they are types by value, you will not be able to modify the properties of the instance (even if you have defined those properties with variables). And the instance will be stored in a constant location, and therefore, it will be immutable.\nThis does not happen with classes since, since they are reference types, what they keep constant is the reference to the location in memory. Therefore, you can modify the content and therefore its properties (as long as you have defined those properties as variables)\nstruct VideogameStruct { let title var played } class VideogameClass { let title var played } let videogameInStruct = VideogameStruct(title: \u0026#34;The last of us\u0026#34;, played: false) // ERROR: Change \u0026#39;let\u0026#39; to \u0026#39;var\u0026#39; to make it mutable let videogameInClass = VidegameClass(title: \u0026#34;God of war\u0026#34;, played: false) videogameInStruct.played = true // ERROR: Change \u0026#39;let\u0026#39; to \u0026#39;var\u0026#39; to make it mutable videgameInClass.played = true // You can change the value. As you see, in case of structure, this code will not compile. Both at instantiation and when trying to modify the value, it will tell you to change let to var to make it mutable.\nLazy properties #Lazy properties are lazy properties because their initial value is not calculated until they need to be used.\nTo define them you just have to use the reserved word lazy at the beginning of the declaration.\nclass Network { var online: Bool = false // Logic to check if internet connection works. } struct Device { let owner: String lazy var network = Network() } The lazy properties are especially useful for optimizing performance, since the value will not be accessed if it is not needed.\nIn the previous example, you can instantiate the device and assign it an owner, but since knowing if it is online is a more complex task that involves other operations, you can continue without checking it until you need it.\nIf multiple threads simultaneously access a lazy property that has not been initialized, Swift cannot guarantee that it will only be initialized once. Computed properties #The other property types, computed properties, do not store a value directly, but instead compute them and return them when its called.\nThey are useful when their value depends, for example, on the value of other properties within that same type.\nHere you can see a example:\nstruct TVSeries { var title: String var startYear: Int var endYear: Int? // A nil value indicates the series has not concluded // Computed property to determine if the series is still airing var isAiring: Bool { get { if let endYear = endYear { return false // The series has concluded } else { return true // The series is still airing } } set { let result = newValue ? \u0026#34;is\u0026#34; : \u0026#34;is not\u0026#34; print(\u0026#34;\\(title) \\(result) on air!\u0026#34;) } } } let breakingBad = TVSeries(title: \u0026#34;Breaking Bad\u0026#34;, startYear: 2008, endYear: 2013) let strangerThings = TVSeries(title: \u0026#34;Stranger Things\u0026#34;, startYear: 2016, endYear: nil) print(\u0026#34;\\(breakingBad.title) is still airing?: \\(breakingBad.isAiring)\u0026#34;) print(\u0026#34;\\(strangerThings.title) is still airing?: \\(strangerThings.isAiring)\u0026#34;) In this structure fragment from a TV series, you can see that the calculated property is divided into two components: the get (which will be executed when you want to access the value, that is, on the print line) and the set (which is executed when the value of the calculated variable has been set, after the print has been executed)\nSo, in the get, you can see that when you need the value the isAiring property (which indicates whether it is airing) will check to see if it has an end date (in which case, it will no longer be airing).\nThe set, however, will print a message depending on whether the value has been set to true or false. As you can also see, the new value can be accessed using the newValue variable that Swift will create automatically.\nRead-only properties #Calculated properties, which only have get but do not have set will be considered read-only properties, since nothing will be executed, when the value is set, and therefore will only be readable.\nYou can see this example:\nstruct Rectangle { var width: Double var height: Double var area: Double { get { return width * height } } } The area of a rectangle can only be read, since if you modify it, you would necessarily modify the width and/or height, which is why in this example, there is only the get.\nThe previous example can be simplified in two ways:\nIt only has the get so, it can be omitted. There is only a single statement, the return can be omitted. struct Rectangle { var width: Double var height: Double var area: Double { width * height } } This way, you can improve the readability of your code\u0026hellip; and whoever has to maintain it will thank you 😉.\nProperty Observers #Property observers make it possible to take actions when the value of a property changes. That is, it would be similar to set of a calculated property, but observers allow you to execute actions:\nBefore the value is changed (willSet) When the value has been changed (didSet) Property observers will run WHENEVER a value is set to a property. Although the established value is the same as it was previously. Property observers can be used in:\nStored properties that you define Stored properties that you inherit Calculated properties that you inherit Look at this other example:\nstruct ProgressTracker { var task: String var percentageComplete: Double { willSet(newPercentage) { print(\u0026#34;Will set percentageComplete for \\(task) to \\(newPercentage)%\u0026#34;) } didSet { print(\u0026#34;Did set percentageComplete for \\(task) from \\(oldValue)% to \\(percentageComplete)%\u0026#34;) if percentageComplete == 100.0 { print(\u0026#34;\\(task) is now complete.\u0026#34;) } } } } var reportProgress = ProgressTracker(task: \u0026#34;Download\u0026#34;, percentageComplete: 0) reportProgress.percentageComplete = 30 reportProgress.percentageComplete = 80 reportProgress.percentageComplete = 100 As you can see, you can pass the name of the value that you can use in its block (such as with the constant newPercentaje).\nYou can also use oldValue, which is the constant that Swift automatically creates, and which stores the old value.\nProperty wrappers #Finally, it is important to know that there are also property wrappers, they allow you to separate the code that manages how a property is stored and the code that defines said property, and this is achieved by wrapping the calculation.\nYou could do it in the following way:\n@propertyWrapper struct NonNegative { private var value: Int var wrappedValue: Int { get { value } set { value = max(0, newValue) } // Ensure the value is never negative } // Initialize with a value that is guaranteed to be non-negative init(wrappedValue: Int) { self.value = max(0, wrappedValue) } } struct InventoryItem { @NonNegative var stock: Int } var item = InventoryItem(stock: 5) print(item.stock) // Prints: 5 item.stock = -3 print(item.stock) // Prints: 2 With this example, you can try on the one hand how properties are managed to check that a property does not have a negative integer value. And thus, reuse it in other parts of the code, without having to copy and paste the content of the getters and setters.\nThe use of property wrappers requires and allows many more details, so if you want to know more you can see it in the [official documentation](https://docs.swift.org/swift-book/documentation/the-swift-programming- language/properties/#Property-Wrappers).\nConclusion #You have seen how properties basically define the characteristics of the type to which they belong.\nBut, in order to make the most of them, and optimize your code, it is key to know all the operations you can do with them.\nSwift, like many other features, offers different methods for accessing, calculating, and returning property values, which makes writing efficient code easier.\n","date":"18 April 2024","permalink":"/blog/properties-swift/","section":"Blog","summary":"Properties allow you to store values with information about the type that defines them","title":"Defining characteristics of types: The properties"},{"content":"There are numerous types of applications. I would dare say, almost as many as there are types of companies or developers. And, although we have a significant number on our devices, it is also true that the number of those we regularly use is drastically reduced.\nThis shows the importance of selecting each of the details that encompass an app: UX/UI, content, onboarding, accessibility\u0026hellip; details that will also change significantly depending on the audience they are addressing, and therefore, we can also say that there will be so many types of each element, such as users.\nBut if there is something that reduces the possibilities to a smaller number, it is the business model chosen to, as we like so much 😉, make our app profitable.\nAnd do you know that these benefits can vary considerably depending on the model you choose?\nThat\u0026rsquo;s why today I want to talk to you about the different business models that you can use if you are going to launch an application for an Apple device, and make it as profitable as possible.\nApplication business models in the App Store #Free #In a free application, the user will be able to download the app and can use it completely, without making any payment.\nThis model is used on many occasions when direct economic benefits are not sought: improving brand image, validating a market idea, showing a portfolio\u0026hellip;\nThe most common option to generate direct income with this model is by inserting advertising banners.\nIn this way, the business model will be very similar to content websites that obtain their income from advertising, so you will need a significant number of users to use your app, and also, to do so on a recurring basis, so that those incomes are maintained over time. Furthermore, it is very important not to saturate the user with advertising so as not to impoverish the user experience.\nIn this case you can use third-party SDKs to be able to enter the ads, the most used being Google\u0026rsquo;s AdMob platform. In its documentation you can see how and where to insert the code to display the ads.\nThe chosen advertising platform would be the one that would show you the management of said ads, benefits, configuration, etc\u0026hellip; and would have its own payment requirements.\nFreemium #In the Freemium model, the user downloads the app for free.\nFrom there, you have two options: Provide a period for which the user can use all the features and access the content of the entire app, when this period expires, they must pay to continue using it. Offer basic content or features, which can be used unlimitedly as long as they want, but in this case the user must pay to access higher-value content or features.\nThat is, the user will use a part of the application or for a limited time, but must pay to use it completely (that is, for the Premium part, not included in the free part)\nIn this model, it is key to show in the part that the user will see for free, the details that can provide the most value and solve the problem why they decided to download your app, and therefore, make them want to continue using it completely.\nIn this case, Apple makes the following in-app purchases types available to you\nConsumables #The user pays for elements that can be consumed: such as gems, lives or cards.\nThis type is especially used in games where the user needs some element that they will use to continue advancing.\nNot consumables #The user pays only once, and with this, gets the new content or feature, unlimitedly.\nIn this case, it can be used for other types of applications that are not a game: a new filter for the camera application, decorative elements for your avatar, etc\u0026hellip;\nAuto-renewable subscriptions #The user will pay for Premium content, which they will use for a limited period of time.\nThus, once it ends, it will be automatically renewed.\nNon-renewable subscriptions #Same as the previous one, but in this case the subscription will not be automatically renewed.\nLearn more about payment options in the Freemium model #You can see more information and very useful guides on the Apple developer page about business models and monetization\nPaid #In this payment model the user will pay to download the application.\nOnce downloaded, the user can access all the content and functions of your app, it is the simplest direct payment model that exists, similar to the purchase of a physical good.\nFor this model, the most important thing is that you can show the user the capabilities and benefits of your app.\nAs a first option (the first impression counts a lot) it is essential to carefully select the captures of screens and videos that you will upload to the App Store, as well as knowing how to explain in the description of the app, the problems that your user can solve.\nAnother highly recommended alternative would be to have a landing page so that you can show more information about the benefits that your app brings to users, both in text, images or video.\nThe prices are established when the application is uploaded to the App Store, on the product configuration page, and the different prices can be customized for different countries.\nPaymium #In a Paymium model, the user pays to download the app, and with this they will have access to certain features, but to be able to use it fully (Premium part), they will have to pay again.\nThis is a way that can be applied to higher-priced apps, allowing their most basic use at a reduced price.\nIt may be interesting for apps that can be used by amateurs and professionals, the latter being the ones who would pay for the complete app if it means a greater benefit than the expense they have made.\nAs in the previous case, a combination of an excellent product page in the App Store and additional information outside of it will make purchases easier.\nIn this model, it will also be set on the app\u0026rsquo;s product page in the App Store, using a combination\nBenefits and drawbacks of the models # Model Pros Cons Free Ease of downloading by users to try it. Greater difficulty in retaining users.\nExcessive advertising results in a worse user experience. Freemium Ease of download, just like the free model, which allows validation of acceptance.\nIf the user decides to pay, it is a way to pay for future updates. Difficulty showing value in the free part and wanting to pay for the premium. Single payment Income is obtained from the first moment. Difficulty in downloading as prior payment is required, especially for the most expensive ones.\nYou only earn income for downloading, but not for maintaining the app. Paymium Revenue is earned from the first moment, and also from the development of new features and updates. It will be more complex for the user to agree to use the app, knowing that for other options, they will have to pay again. Alternative business models #Although the ones you have seen previously are the ones that you can manage more directly through Apple, and therefore, the ones that I recommend. You have other ways to earn income from your more apps\nSponsorships #If you manage to associate with a brand that wants to make itself known through your app, you could organize activations that would allow both said brand and your users to benefit from said action, so this would be a new source of income with which to pay for the development and maintenance of your app.\nCrowdfunding #In this case, you could launch a crowdfunding campaign, with which you could initially obtain the necessary financing to launch the development of the app. Additionally, with users having provided an upfront payment before making the app, you could validate the idea and confirm that it brings value to your users.\nIt would also be an option if this allows the app to scale by offering features that represent a significant improvement.\nThen, your users could use download or feature unlock codes to get that reward for the funding they provided you.\nAffiliation #An affiliation model allows you to “Invite a friend” to try the application, although it would mean that you would have to reward those who invite, could bring you a considerable number of purchases or subscriptions.\nConclusion #Apple makes the tools for its recommended business models available to developers and organizations, but it will be up to you to select the most appropriate one for your app based on your users and objectives.\nIt is not a trivial decision, so dedicating the necessary time to it can impact whether the application business is viable or fails. As in so many other elements in which the user has so much to say, collecting feedback and responding quickly to demand can save you time, money and aggravation.\nIn addition, the different models have their configuration to determine and collect amounts in a secure, native and efficient way.\nEach of the models or strategies can be combined to align with the needs or marketing strategies you determine, but it will also be key to put the user at the center.\nFinally, as you probably know and may be thinking, third-party stores can now be integrated into iOS in Europe\u0026hellip; but that is for another (or other) article.\nAnd now that you know this, which model do you find most interesting for your application?\n","date":"4 April 2024","permalink":"/blog/apple-apps-business-models/","section":"Blog","summary":"Choosing the business and monetization model of your app is vital for its success and your profits.","title":"Business models in Apple apps: Discover the perfect one for you"},{"content":"In the world of software development with Swift, one of the fundamental choices we face is the decision between structures and classes. Both are essential constructs that allow us to model our data efficiently, but their differences are crucial for writing efficient and understandable code.\nStructures and classes in Swift share several similarities. Both can define properties to store values, methods to add functionality, subscripts to access values with specific syntax, and can be extended to increase their functionality. However, it\u0026rsquo;s in their differences where we find the keys to deciding when to use each.\nWhen to Use Structures? #Structures are value types. This means they are copied when assigned to a new variable or passed to a function. They are the preferred choice for representing simple and autonomous data that doesn\u0026rsquo;t need to inherit properties from elsewhere. For example, to model the specifications of a video game, you might use a structure:\nstruct VideoGame { var name: String var genre: String var platform: String } let halo = VideoGame(name: \u0026#34;Halo Infinite\u0026#34;, genre: \u0026#34;FPS\u0026#34;, platform: \u0026#34;Xbox\u0026#34;) This model is useful when copied values are what you need, such as passing video game data from one part of your app to another without worrying about unwanted side effects.\nWhen to Use Classes? #Classes are reference types. Unlike structures, if you assign an instance of a class to a new variable or pass it to a function, what is passed is a reference to the same instance. This is useful when you need to have a single object that is updated and accessed from multiple places. For example, you might want to have an object that represents a user session:\nclass UserSession { var user: String var status: String init(user: String, status: String) { self.user = user self.status = status } } let session = UserSession(user: \u0026#34;JuanGamer42\u0026#34;, status: \u0026#34;Active\u0026#34;) Using a class here allows any changes to the session to be reflected throughout the entire app, which would be crucial for managing states such as logging in or out.\nKey Differences # Inheritance: Only classes can inherit from another class. This makes them powerful for polymorphic use cases. Reference type vs. Value type: This is probably the biggest differentiator. It affects how information is passed in your app and can have significant implications for performance and memory use. Reference counting: Only classes support reference counting, allowing more than one reference to point to the same class instance. This is useful for managing the lifecycle of objects, especially in multi-threaded environments. Recommendations # Prefer structures by default: They are faster and safer in a concurrency context because they work with copies of the data they contain. Use classes when you need inheritance or unique identity management: For example, to control a single instance of a network service or a user session shared across your app. Conclusion #The choice between structures and classes depends on the nature of your data and how you plan to use it in your application. While structures offer a safe and efficient way to work with copied data, classes provide powerful tools for managing shared states and inheritance. By consciously choosing between these two constructs, you can write clearer, more efficient, and more appropriate code to your needs.\n","date":"28 March 2024","permalink":"/blog/structures-clases/","section":"Blog","summary":"Both options allow you to encapsulate and reuse values and behaviors, but knowing their differences helps optimize your code","title":"Mastering basics: Structures vs. Clases"},{"content":"Hello! Today, I want to share with you some practical advice and essential guidelines to help you successfully navigate the App Store review process. As developers aiming to launch our apps on this platform, it\u0026rsquo;s important to remember that attention to detail makes all the difference. So, let\u0026rsquo;s embark on this journey toward success together.\nPreparation Before Submission #The first step is ensuring you\u0026rsquo;re fully prepared. This means having an active developer account with Apple and making sure your app meets all their technical and visual guidelines. Preparation is key.\nTechnical and Design Aspects #Apple places a huge emphasis on quality and user experience. Your app should be error-free, run smoothly on all intended devices, and offer an intuitive user experience. Every detail counts in the interface and usability, not just to pass the review but to stand out in the market.\nUsing Tools Provided by Apple #Make the most of the tools Apple offers. Xcode Cloud and TestFlight are indispensable in your development arsenal. Xcode Cloud facilitates collaborative development, while TestFlight is essential for beta testing and gathering user feedback before your final launch.\nCustomization and A/B Testing #Customizing your app\u0026rsquo;s page for different audiences and evaluating the performance of various elements can make a significant difference in how you connect with your audience. This flexibility is key to optimizing your presentation and achieving a greater impact.\nApp Content and Functionality #Your app should provide complete and valuable content. Avoid publishing with errors, broken links, or inaccurate descriptions. A rich and seamless experience is crucial not only for approval but also for success on the App Store.\nAttention to Detail in Presentation #From your app\u0026rsquo;s name and description to the screenshots and icon, every element must be carefully considered. These materials must meet Apple\u0026rsquo;s specifications and effectively communicate what your app offers.\nOngoing Support and Assistance #Utilize the resources and support Apple offers. Technical documents, sample codes, and the ability to collaborate directly with Apple engineers are fundamental to overcoming any challenges during your app\u0026rsquo;s development.\nCompliance with Apple\u0026rsquo;s Policies #Ensuring your app complies with all of Apple\u0026rsquo;s policies is essential. This includes regulations on privacy, security, and content. To make sure your app aligns with these policies, review the following official links:\nApp Store Review Guidelines Apple Developer Program License Agreement By following these tips and utilizing the resources provided by Apple, you will significantly improve your chances of success on the App Store. With dedication, attention to detail, and a proactive attitude towards learning and continuous improvement, there\u0026rsquo;s no doubt you can create exceptional experiences that captivate users worldwide.\nI hope this article has been helpful and provided you with a solid foundation on which to build and successfully launch your app. Remember, the developer community is a great resource, and it never hurts to seek advice or share your own experiences. Together, we grow this incredible platform!\n","date":"18 March 2024","permalink":"/blog/app-store-publish-review/","section":"Blog","summary":"I\u0026rsquo;ll show you the keys to quickly and efficiently pass the publication review of your app in the App Store","title":"Keys to Success the App Store Publication Review"},{"content":"Enumerations, or simply enums as we know them in Swift, are a indispensable tool in your development kit, allowing you to define a common type for a related values group. This not only improves the readability of your code, but also facilitates its maintenance and helps you avoid those common errors that we all like to avoid. If you\u0026rsquo;re starting out in Swift and still getting familiar with function creation, understanding enumerations can be a game change.\nWhat are enumerations? #Imagine you\u0026rsquo;re working on a TV show app. You have different genres like drama, comedy, horror, etc. Instead of managing these genres as text strings (which could lead to typing errors) you can define an enumeration:\nenum TVShowGenre { case drama case comedy case horror case sciFi } With this definition, you can use TVShowGenre in a safe and controlled manner, thus improving the readability and consistency of your code.\nWhen to use enums? #Enumerations are incredibly useful when you need to group sets of related values that you already know. For example, in an app to follow Formula 1 seasons, you could have an enumeration for the teams:\nenum F1Team { case mercedes case ferrari case redBull case mclaren } This approach ensures that you can only assign drivers to the teams that exist in your enumeration, avoiding incorrect assignments.\nAssociated Values #Swift takes enumerations even further, allowing cases with associated values. This means you can store additional values of other types along with the enumeration cases. Imagine you\u0026rsquo;re creating a video game and want to define different types of enemies, some with special attributes:\nenum Enemy { case soldier case wizard(magicStrength: Int) case boss(isFinal: Bool, lives: Int) } Here, wizard has an associated value magicStrength, and boss has two associated values, indicating whether it is the final boss and how many lives it has. This allows you to handle each type of enemy more specifically and detailed in your game.\nRaw Values and Inheritance from the String Protocol #Enumerations in Swift can have raw values, which are predefined values that you can associate with each case of the enumeration. This is especially useful when your enumeration needs to represent a specific string or numeric value for each case.\nFor example, you could have an enumeration that represents Formula 1 drivers, where each driver is associated with their corresponding full name:\nenum Drivers: String { case verstappen = \u0026#34;Max Verstappen\u0026#34; case alonso = \u0026#34;Fernando Alonso\u0026#34; case leclerc = \u0026#34;Charles Leclerc\u0026#34; } Here, Drivers is an enumeration that inherits from the String protocol. This means that each case has a raw value of type String that matches its name. For example, you can access the raw value of a driver in the following way:\nlet driver = Drivers.verstappen print(driver.rawValue) // Prints \u0026#34;Max Verstappen\u0026#34; This is particularly useful when you need to work with data that comes from an external source that uses string representations, such as a web server or a database.\nIn addition, when an enumeration inherits from the String protocol, Swift automatically assigns to each case a raw value that matches the case name, saving you the need to explicitly assign a raw value to each case.\nenum Track: String { case monaco case spa } let track = Track.monaco.rawValue // track is a String with value \u0026#34;monaco\u0026#34; In summary, the use of raw values and inheritance from the String protocol in your enumerations can improve the readability of your code, facilitate interaction with other parts of your code that use strings and numbers, and help you avoid errors when handling external data. I hope this helps you understand even more the power of enumerations in Swift!\nConclusion #Enumerations in Swift are a powerful and safe way to work with sets of related values:\nThey facilitate the writing of cleaner and more maintainable code, while preventing common errors by limiting the values to those defined in the enumeration. Associated values offer additional flexibility, allowing you to include specific information directly in your data types. Raw values let you use strings of your values. By mastering enumerations, you are taking a huge step towards more robust and efficient software development. It\u0026rsquo;s your turn to experiment with them and see all they can do for your projects!\n","date":"11 March 2024","permalink":"/blog/swift-enums/","section":"Blog","summary":"With enumerations you can define a common type for associated values","title":"Enumerations"},{"content":"Closures are a fundamental concept in Swift. They are powerful tools that allow you to define and manipulate blocks of code as first-class citizens. In this article, we\u0026rsquo;ll explore closure expressions, trailing closures, capturing values, and the idea that closures are type references.\nClosure Expressions #A closure expression is a self-contained block of code that can be passed around and used in your code, just like any other variable. In Swift, you can define closures using the {} braces. Here\u0026rsquo;s a simple example:\nlet greet = { print(\u0026#34;Hello, world!\u0026#34;) } Trailing Closures #Trailing closures are a convenient way to include a closure expression as the last argument of a function. This makes your code more readable. Suppose you have a function that takes a closure as an argument:\nfunc performAction(action: () -\u0026gt; Void) { // Perform some setup action() } // Using a trailing closure performAction { print(\u0026#34;Action performed!\u0026#34;) } Capturing Values #Closures can capture and store references to variables and constants from the surrounding context in which they are defined. This means they can \u0026ldquo;remember\u0026rdquo; and manipulate those values even if they are no longer in scope. Here\u0026rsquo;s an example:\nfunc makeIncrementer(incrementAmount: Int) -\u0026gt; () -\u0026gt; Int { var total = 0 let incrementer: () -\u0026gt; Int = { total += incrementAmount return total } return incrementer } // Usage example: let incrementByTwo = makeIncrementer(incrementAmount: 2) let incrementByFive = makeIncrementer(incrementAmount: 5) print(incrementByTwo()) // Output: 2 print(incrementByTwo()) // Output: 4 print(incrementByTwo()) // Output: 6 print(incrementByFive()) // Output: 5 print(incrementByFive()) // Output: 10 print(incrementByFive()) // Output: 15 In this example, we define the makeIncrementer function, which takes an incrementAmount as an argument and returns a closure of type () -\u0026gt; Int. Each time you call the returned closure, it increments the total variable by the specified incrementAmount and returns the updated total. We create two separate closures, incrementByTwo and incrementByFive, each with its own captured total and `incrementAmount values. When we call these closures multiple times, you can see how they maintain their individual state and increment by their respective amounts.\nClosures Are Type References #Closures are more than just blocks of code; they are also type references. You can declare a closure type, and variables of that type can hold closures with matching signatures. This allows you to define functions that take closures as parameters or return them as results, providing flexibility and reusability in your code.\nConclusion #In summary, closures are a crucial concept in Swift, and understanding them is essential for any iOS developer. They provide a flexible way to work with code and data, whether you\u0026rsquo;re creating simple functions or advanced asynchronous operations. By mastering closure expressions, trailing closures, capturing values, and recognizing that closures are type references, you\u0026rsquo;ll be better equipped to write efficient and readable Swift code.\n","date":"5 September 2023","permalink":"/blog/closures-swift/","section":"Blog","summary":"A closure expression is a self-contained block that can be used in your code","title":"Understanding Closures in Swift"},{"content":"","date":null,"permalink":"/apps/shary/","section":"Apps","summary":"Shary is an easy and intuitive app for splitting expenses.","title":"Shary"},{"content":"As developers, we often manage situations where we need to work with functions in our iOS applications. Functions are an integral part of the Swift programming language and provide us with a powerful toolset to build flexible and modular code. In this article, we will explore the concept of using functions types and how it can benefit our development process.\nDetermining the Function Type #In Swift, functions are considered first-class citizens, which means they can be assigned to variables or constants and can also be used as types. To determine the type of a function, we can use the function\u0026rsquo;s signature. The signature consists of the parameter types and return type. Let\u0026rsquo;s consider an example:\nfunc add(_ a: Int, _ b: Int) -\u0026gt; Int { return a + b } The type of this function can be represented as (Int, Int) -\u0026gt; Int, where (Int, Int) represents the parameter types and Int represents the return type.\nUsing Functions Types as Parameters #One of the advantages of using functions types is the ability to pass them as parameters to other functions. This enables us to create higher-order functions that can accept different behaviors based on the functions provided. Let\u0026rsquo;s take an example where we have a function that applies a given operation on an array of integers:\nfunc applyOperation(_ numbers: [Int], operation: (Int) -\u0026gt; Int) -\u0026gt; [Int] { var result = [Int]() for number in numbers { let transformedNumber = operation(number) result.append(transformedNumber) } return result } In the above code, the applyOperation function takes an array of integers and a function operation as parameters. The operation parameter represents a function that takes an integer and returns an integer. We can use this higher-order function to perform various operations on our array of numbers.\nUsing Functions Types to Return #Another powerful aspect of using functions types is the ability to use them as output return. This enables us to create functions that dynamically generate and return other functions based on certain conditions or requirements. Let\u0026rsquo;s consider an example:\nfunc operationFactory() -\u0026gt; (Int) -\u0026gt; Int { if condition { return { number in number * 2 } } else { return { number in number / 2 } } } In this example, the operationFactory function returns a function of type (Int) -\u0026gt; Int based on a certain condition. We can utilize this behavior to create more flexible and adaptable code.\nConclusion #Using functions types in iOS development provides us with a powerful mechanism to create modular and flexible code. By treating functions first-class citizens, we can pass them as parameters to other functions, use them as return types, and dynamically generate them when needed. This approach enhances code reusability, promotes modularity, and allows for the creation of higher-order functions. By leveraging these capabilities, developers can build robust and adaptable iOS applications. So, next time you find yourself in a situation where you need to incorporate different behaviors in your code, consider using functions types for a more elegant solution.\nHappy coding! 👨🏻‍💻\n","date":"10 July 2023","permalink":"/blog/using-function-types-swift/","section":"Blog","summary":"As Functions are first-class citizens, you can enjoy its benefits","title":"Using Function Types in Swift"},{"content":"Understanding the intricacies of function argument labels and parameter names is essential to harness the full power of the Swift programming language. In this article, we will explore these concepts with a focus on simplicity, catering to developers with limited experience in function creation. So, let\u0026rsquo;s dive in!\nFunction Argument Labels #Argument labels provide a descriptive context when calling a function, making the code more expressive and readable. In Swift, argument labels are specified before the parameter names and are separated by a space. Let\u0026rsquo;s consider an example where we calculate the score of a video game level:\nfunc calculateScore(forLevel level: Int) -\u0026gt; Int { // Function body goes here } Here, forLevel is the argument label, and level is the parameter name. When calling this function, we use the argument label to provide clarity:\nlet finalScore = calculateScore(forLevel: 5) By using argument labels, we can convey the purpose of each parameter, enhancing the understanding of our code.\nAlso, you can omit an argument label. You simply must write an underscore instead an argument label:\nfunc addStamina(_ stamina: Int) -\u0026gt; Int { // Function body goes here } And you will only need to pass the value when you call the function.\nlet totalStamina = addStamina(100) Default Parameter Values #In Swift, we have the flexibility to assign default values to function parameters. This means that when calling a function, we can choose to omit specific arguments, and the default values will be used instead. Continuing with our video game theme, let\u0026rsquo;s modify our previous function to include a default value for the bonusPoints parameter:\nfunc calculateScore(level: Int, bonusPoints: Int = 500) -\u0026gt; Int { return level * bonusPoints } Now, we can call the function and use the two parameters but, if we call the function without providing a value for bonusPoints, it will automatically default to 500:\nlet totalScore = calculateScore(level: 2, bonusPoints: 100) // totalScore is equal to 200 let finalScore = calculateScore(level: 5) // finalScore is equal to 2500 Variadic Parameters #Sometimes, we may encounter situations where the number of function arguments is not fixed. To handle such scenarios, Swift allows us to use variadic parameters. These parameters can accept zero or more values of a specified type. To demonstrate, imagine a function that calculates the total score of multiple video games:\nfunc calculateTotalScore(scores: Int...) -\u0026gt; Int { // Function body goes here } Here, scores is a variadic parameter. We can pass any number of arguments separated by commas when calling the function:\nlet totalScore = calculateTotalScore(scores: 100, 250, 500, 750) In-Out Parameters #Lastly, Swift provides the in-out parameter modifier, which allows a function to modify the value of a variable from outside its own scope. In-out parameters are prefixed with the \u0026ldquo;inout\u0026rdquo; keyword. Consider a scenario where we need to update the health points of a game character:\nfunc updateHealthPoints(_ hp: inout Int) { // Function body goes here } To pass a variable as an in-out parameter, we prepend an ampersand before the variable name:\nvar characterHP = 100 updateHealthPoints(\u0026amp;characterHP) Conclusion #In this article, we\u0026rsquo;ve covered the fundamentals of function argument labels and parameter names in Swift. We explored the usage of argument labels, default parameter values, variadic parameters, and in-out parameters. By mastering these concepts, you\u0026rsquo;ll be equipped to write clean, expressive, and flexible code in your iOS projects. Keep practicing and incorporating these techniques into your development journey, and soon could be creating remarkable retro video games that leave players nostalgic for the golden age of gaming.\nHappy coding! 👨🏻‍💻\n","date":"26 June 2023","permalink":"/blog/function-argument-labels-parameters/","section":"Blog","summary":"Discover the basics about input parameters in functions","title":"Function Argument Labels and Parameter Names"},{"content":"Working as iOS developers, we often come across scenarios where we need to return multiple values from a function. Swift provides us with two useful approaches to achieve this: using tuples and collections. In this article, we will explore both methods and understand when to use each one.\nUsing Tuples #Tuples are lightweight data structures that allow us to group multiple values together. They provide a simple way to return multiple values from a function. Consider the following example:\nfunc getMovieDetails(movieId: Int) -\u0026gt; (String, String) { // Retrieve movie details from the database let movieTitle = \u0026#34;Back to the Future\u0026#34; let director = \u0026#34;Robert Zemeckis\u0026#34; return (movieTitle, director) } let movieDetails = getMovieDetails(movieId: 1) print(\u0026#34;Title: \\(movieDetails.0)\u0026#34;) print(\u0026#34;Director: \\(movieDetails.2)\u0026#34;) In this example, the getMovieDetails function returns a tuple containing the movie title and director. We can access individual values using dot syntax and the corresponding index. Tuples are handy when we have a fixed number of values to return.\nUsing Collections #Collections, such as arrays or dictionaries, offer a more flexible approach for returning multiple values. Let\u0026rsquo;s see how we can modify our previous example to utilize an array:\nfunc getMovieDetails(movieId: Int) -\u0026gt; [String] { // Retrieve movie details from the database let movieTitle = \u0026#34;Back to the Future\u0026#34; let releaseYear = 1985 let director = \u0026#34;Robert Zemeckis\u0026#34; return [movieTitle, String(releaseYear), director] } let movieDetails = getMovieDetails(movieId: 1) print(\u0026#34;Title: \\(movieDetails[0])\u0026#34;) print(\u0026#34;Release Year: \\(movieDetails[1])\u0026#34;) print(\u0026#34;Director: \\(movieDetails[2])\u0026#34;) Here, the getMovieDetails function returns an array of strings, containing the movie title, release year (converted to a string), and director. We access the values by their respective indices. Collections are advantageous when we have a varying number of values to return or if the number of values may change in the future.\nChoosing Between Tuples and Collections #When deciding between tuples and collections, consider the following guidelines:\nUse tuples when you have a fixed number of values that won\u0026rsquo;t change. Use collections when the number of values may vary or when you need to easily add or remove values. Conclusion #Returning multiple values from a function in Swift is essential in many programming scenarios. By utilizing tuples or collections, we can efficiently handle these situations. Tuples are suitable for returning a fixed number of values, while collections offer flexibility when the number of values may vary. Understanding these techniques empowers us to write cleaner, more expressive code.\nRemember to experiment with these concepts using real-world examples and explore how they can be applied to your own projects.\nHappy coding! 👨🏻‍💻\n","date":"12 June 2023","permalink":"/blog/returning-multiple-values-from-functions/","section":"Blog","summary":"Learn how you can return multiple values from a single function","title":"Returning Multiple Values from a Function: Tuples vs. Collections"},{"content":"As a developer, it\u0026rsquo;s essential to understand the fundamental concepts of programming. One such concept is functions, which play a crucial role in organizing and reusing code. In this article, we\u0026rsquo;ll explore the basics of functions in Swift. Whether you\u0026rsquo;re a beginner or looking for a refresher, this guide will help you grasp the essentials of functions in a simple and straightforward manner.\nWhat are Functions? #A function is a block of code that performs a specific task. It allows you to encapsulate a set of instructions under a meaningful name, making your code more organized and modular. Functions can accept input values, called parameters, and return output values. They provide a way to break down complex logic into smaller, manageable parts.\nSyntax and Structure: #In Swift, a function declaration begins with the func keyword, followed by the function name and parentheses. If the function accepts parameters, they are specified within the parentheses. The return type is indicated by an arrow -\u0026gt; followed by the type. Here\u0026rsquo;s an example:\nfunc greet(name: String) -\u0026gt; String { return \u0026#34;Hello, \\(name)!\u0026#34; } In this example, we have a function named \u0026ldquo;greet\u0026rdquo; that accepts a parameter called \u0026ldquo;name\u0026rdquo; of type String. It returns a String value containing a greeting message with the provided name.\nExample Scenario #Let\u0026rsquo;s say we\u0026rsquo;re building an app related to TV shows. We can create a function to recommend a show based on the user\u0026rsquo;s preferences. Here\u0026rsquo;s an example:\nfunc recommendShow(userPreference: String) -\u0026gt; String { if userPreference == \u0026#34;action\u0026#34; { return \u0026#34;You should watch \u0026#39;Game of Thrones\u0026#39;!\u0026#34; } else if userPreference == \u0026#34;comedy\u0026#34; { return \u0026#34;I recommend \u0026#39;Friends\u0026#39;!\u0026#34; } else { return \u0026#34;I\u0026#39;m sorry, I don\u0026#39;t have a recommendation for your preference.\u0026#34; } } When calling this function with different preferences, such as \u0026ldquo;action\u0026rdquo; or \u0026ldquo;comedy,\u0026rdquo; it will return an appropriate recommendation. If the user preference doesn\u0026rsquo;t match any specific case, a default message is returned.\nWhen to Use Functions #Functions are particularly useful in the following scenarios:\nReusability #If you find yourself performing the same task or calculation at multiple places in your code, it\u0026rsquo;s a good indication to create a function for that task. This way, you can reuse the code without duplicating it.\nModularity #Functions help in organizing code into smaller, self-contained units. This improves code readability and maintainability.\nAbstraction #By encapsulating complex logic within functions, you can abstract away the implementation details and focus on the higher-level functionality.\nConclusion #Understanding the basics of functions is essential for any developer. They allow you to write clean, reusable code and improve the structure of your programs. In this article, we explored the syntax and structure of functions in Swift, along with an example scenario using TV show preferences. By leveraging functions effectively, you can create more modular and maintainable code.\nHappy coding! 👨🏻‍💻\n","date":"29 May 2023","permalink":"/blog/understanding-basics-functions/","section":"Blog","summary":"Functions let us organize code, reuse it, and avoid duplications","title":"Understanding the Basics of Swift Functions"},{"content":"In Swift, there are various language constructs that make programming more efficient and robust.\nOne such construct is the defer statement, which allows developers to execute a block of code later in the program\u0026rsquo;s flow. This article aims to explain how defer works in Swift, provide examples of its usage, and highlight the scenarios in which it can be beneficial.\nIs used to define a block of code that is executed when the current scope is exited, regardless of how the scope is exited—whether through a return statement, an error, or a break. Have in mind that, in case your app stops running because a runtime error or a crash, deferred code doesn\u0026rsquo;t execute.\nIt ensures that specific cleanup or finalization code is executed before leaving the scope, regardless of the execution path.\nSyntax of Defer #The syntax is simple. You begin with the keyword defer followed by the code block you want to execute later. Here\u0026rsquo;s an example:\nfunc processFile() { print(\u0026#34;Opening file...\u0026#34;) defer { print(\u0026#34;Closing file...\u0026#34;) } // Code for processing the file goes here // This code will be executed before the file is closed } In this example, the \u0026ldquo;Opening file\u0026hellip;\u0026rdquo; message is printed first, and then the defer block is defined.\nThe defer block contains the code that will be executed at the end, just before leaving the scope. In this case, the message \u0026ldquo;Closing file\u0026hellip;\u0026rdquo; will always be printed, ensuring the file is properly closed.\nUse Cases of Defer #The defer statement is particularly useful in scenarios where you need to ensure resources are properly released or actions are performed regardless of the execution path. Some common use cases include:\nResource Cleanup #When working with files, databases, or network connections, you can use the defer statement to ensure that resources are released, connections are closed, or transactions are committed.\nLock Release #If you acquire a lock or a semaphore, the defer statement can help release it even if an exception occurs or if the code block is exited prematurely.\nState Restoration #In complex workflows or asynchronous operations, you can use the defer statement to restore the state to a consistent or initial condition before exiting the scope.\nLogging and Debugging #The defer statement can be employed to log or report information for debugging purposes before leaving the current scope.\nConclusion #The defer statement in Swift is a powerful language construct that allows developers to defer the execution of code until the end of a scope. It ensures that specific cleanup or finalization code is executed regardless of how the scope is exited.\nBy leveraging the defer statement, developers can write more resilient and organized code, making it easier to handle resource cleanup and ensure the desired behavior in various scenarios.\nRemember, the defer statement can be particularly handy when working with resources, locks, state management, and debugging needs.\n","date":"15 May 2023","permalink":"/blog/discovering-defer-swift/","section":"Blog","summary":"Execute a block of code later in the program\u0026rsquo;s flow","title":"Discovering Defer in Swift"},{"content":"In iOS programming, one powerful construct that helps streamline code readability and improve control flow is the guard statement. This statement acts as a gatekeeper, allowing us to gracefully handle exceptional scenarios and exit early from a code block.\nIn this article, you will discover the benefits of the guard statement, explore its usage, and provide examples to illustrate its effectiveness.\nUnderstanding the guard Statement #The guard statement serves as a conditional early exit mechanism in Swift, the programming language for iOS development.\nIt allows us to check for specific conditions and ensure that they are met before continuing the execution of a code block.\nIf the conditions aren\u0026rsquo;t met, the guard statement terminates the current scope, enabling us to handle failure scenarios elegantly.\nThe syntax for a guard statement is as follows:\nguard condition else { // Code to handle the failure case // Return, throw, or perform any necessary cleanup } // Code to execute when the condition is successfully met When a guard statement is encountered, the specified condition is evaluated.\nIf the condition evaluates to false, the code within the else block is executed.\nThis block typically contains code to handle the failure case, such as returning from the function, throwing an error, or performing any necessary cleanup. If the condition evaluates to true, the code continues executing normally after guard.\nEarly Exit for Unacceptable Conditions #guard statements can help avoid nested conditional statements by providing early exits for conditions that are considered unacceptable. This simplifies code and improves readability. For instance:\nlet amount = 500 let accountBalance = 1000 guard amount \u0026lt;= accountBalance else { print(\u0026#34;Insufficient funds!\u0026#34;) return } // Perform payment operation Another Use Cases #There are other use cases for guard, specifically related to Optionals and Error handling. However, since these are more advanced topics, in my opinion, it is better only mention them now, and explore them in detail in future advanced posts.\nInput Validation #guard statement is often used to validate input parameters, ensuring that they meet certain requirements before proceeding. This case is used handling optionals.\nResource Deallocation #In this case, guard is handy when dealing with resources that require cleanup. It ensures that the cleanup code is executed whenever a failure condition is encountered.\nConclusion #The guard statement is a powerful tool in iOS programming that allows for clean, concise, and efficient code. It provides an elegant way to handle failure scenarios and gracefully exit from a code block when certain conditions are not met.\nBy using the guard statement effectively, you can improve the readability and maintainability of your code.\nEmbrace this construct in your iOS projects, and enjoy the benefits of a more streamlined development process.\nHappy coding! 👨🏻‍💻\n","date":"2 May 2023","permalink":"/blog/guard-early-exit-swift/","section":"Blog","summary":"Exit early from a code block","title":"Understanding the Guard Statement for Early Exit"},{"content":"Control transfer statements are essential tools in programming that allow developers to alter the flow of execution within their code.\nIn Swift, three commonly used control transfer statements are continue, break, and fallthrough.\nIn this article, we will examine into each of these statements, providing examples and explaining the scenarios where they are most appropriate to use.\nContinue #The continue statement is primarily used within loop constructs (such as ‘for-in\u0026rsquo; or \u0026lsquo;while\u0026rsquo;) to skip the remaining code within the current iteration and proceed to the next iteration.It allows you to selectively skip over specific parts of a loop without terminating it entirely. Here\u0026rsquo;s an example to illustrate its usage:\nfor number in 1...10 { if number % 2 == 0 { continue } print(number) } Output\n1 3 5 7 9 In this example, the continue statement is used to skip printing even numbers. When the condition number % 2 == 0 is true, the continue statement is executed, bypassing the print statement and proceeding to the next iteration.\n## Break The break statement is used to terminate the execution of a loop or switch statement prematurely. It allows you to exit out of a loop or switch block before reaching its natural end.\nConsider the following example:\nlet cars = [“Red Bull\u0026#34;, “Aston Martin\u0026#34;, “Ferrari\u0026#34;, \u0026#34;Mercedes\u0026#34;, \u0026#34;McClaren\u0026#34;] for name in names { if name == \u0026#34;Mercedes\u0026#34; { break } print(name) } Output\nRed Bull Aston Martin Ferrari In this case, the break statement is used to exit the loop once the condition name == \u0026quot;Mercedes\u0026quot; is true. As a result, the loop terminates prematurely, and the remaining elements in the cars array are not printed.\nFallthrough #The fallthrough statement is exclusively used within switch statements. It allows the control flow to move to the next case without performing an implicit break.\nThis behavior differs from the default behavior of a switch statement, where control automatically exits the switch block after a case is matched.\nConsider the following example:\nlet grade = \u0026#34;A\u0026#34; switch grade { case \u0026#34;A\u0026#34;: print(\u0026#34;Excellent\u0026#34;) fallthrough case \u0026#34;B\u0026#34;: print(“You have approved\u0026#34;) case \u0026#34;C\u0026#34;: print(\u0026#34;Average\u0026#34;) default: print(\u0026#34;Incomplete\u0026#34;) } Output\nExcellent Good In this example, when the grade is \u0026ldquo;A,\u0026rdquo; the fallthrough statement is used to continue the execution to the next case without exiting the switch block. As a result, both \u0026ldquo;Excellent\u0026rdquo; and \u0026ldquo;You have approved\u0026rdquo; are printed.\nConclusion #Understanding control transfer statements like continue, break, and fallthrough is crucial for effective Swift programming.\ncontinue allows you to skip specific iterations within loops, break enables premature termination of loops or switch statements, and fallthrough allows control to flow to the next case in a switch statement.\nBy leveraging these statements appropriately, you can enhance the flexibility and control of your code execution in iOS development.\nHappy coding! 👨🏻‍💻\n","date":"17 April 2023","permalink":"/blog/control-transfer-statements-swift/","section":"Blog","summary":"Altering the flow of execution within the code","title":"Exploring Control Transfer Statements in Swift"},{"content":"Understanding the fundamentals of Swift programming is crucial to creating robust and efficient applications.\nOne of the key concepts you need to grasp is conditional statements. In this article, we will navigate into the world of conditional statements in Swift, exploring their syntax, examples, and best practices for using them effectively. So let\u0026rsquo;s go!\nConditional Statements: Making Decisions in Swift #In programming, there are often situations where you need your app to make decisions based on certain conditions. This is where conditional statements come into play, enabling you to execute specific blocks of code depending on whether a condition evaluates to true or false.\nSwift offers three primary conditional statements: if statements, if-else statements, and switch statements.\nEach statement serves a distinct purpose, and understanding when to use them is essential for writing clean and maintainable code.\nThe If Statement #The if statement is the simplest form of conditional statement in Swift. It allows you to execute a block of code only if a specified condition is true.\nFor example, let\u0026rsquo;s say you want to display a message if a user\u0026rsquo;s age is greater than or equal to 18:\nlet userAge = 20 if userAge \u0026gt;= 18 { print(\u0026#34;Welcome! You can access.\u0026#34;) } The If-Else Statement #The if-else statement expands upon the if statement by providing an alternative block of code to execute when the condition evaluates to false.\nConsider the following example that checks whether a number is positive or negative:\nlet number = -5 if number \u0026gt; 0 { print(\u0026#34;The number is positive.\u0026#34;) } else { print(\u0026#34;The number is negative.\u0026#34;) } The Switch Statement #The switch statement offers a more concise way to handle multiple possible conditions. It evaluates a given value against various cases and executes the code block associated with the first matching case.\nLet\u0026rsquo;s say you want to display a message based on a user\u0026rsquo;s role:\nlet userRole = \u0026#34;admin\u0026#34; switch userRole { case \u0026#34;admin\u0026#34;: print(\u0026#34;Welcome, administrator!\u0026#34;) case \u0026#34;user\u0026#34;: print(\u0026#34;Welcome, user!\u0026#34;) default: print(\u0026#34;Unknown role.\u0026#34;) } Best Practices for Using Conditional Statements: #Keep it simple #Aim to write concise and readable code. Avoid complex nested conditions that can make your code difficult to understand and maintain.\nUse appropriate operators #Swift provides a range of comparison and logical operators, such as \u0026lt;, \u0026gt;, ==, \u0026amp;\u0026amp;, ||, to construct meaningful conditions.\nPlan for all possibilities #Ensure you account for all possible scenarios in your conditional statements. The default case in switch acts as a catch-all for unmatched conditions.\nTest your code #Validate your conditional statements with different inputs to ensure they behave as expected. Unit testing is a valuable practice to identify and fix any issues early on.\nConclusion #Conditional statements are fundamental tools for iOS developers, allowing you to make decisions and control the flow of your code based on specific conditions. By mastering if statements, if-else statements, and switch statements, you gain the ability to create dynamic and responsive applications.\nRemember to use these statements wisely, keeping your code clean and understandable.\nHappy coding! 👨🏻‍💻\n","date":"3 April 2023","permalink":"/blog/conditional-statements-swift/","section":"Blog","summary":"Controling the program\u0026rsquo;s behavior based on conditions","title":"Swift Fundamentals about Conditionals"},{"content":"In iOS development, flow control statements play a crucial role in directing the execution of code.\nIt allow developers to iterate over collections, perform repetitive tasks, and control the program\u0026rsquo;s behavior based on certain conditions. In this post, we will dive into three essential flow control statements in Swift: for-in, while, and repeat-while.\nWhether you\u0026rsquo;re a junior iOS developer or someone looking to refresh their knowledge, understanding these statements is essential for building robust and efficient iOS applications.\nFor-In Loops: Simplifying iteration #The for-in loop is particularly useful when you want to iterate over a collection of elements, such as an array or a dictionary. It simplifies the process of accessing each element without the need for manual indexing. Let\u0026rsquo;s take a look at an example:\nlet books = [“A Game of Thrones”, “A Clash of Kings”, “A Storm of Swords”, ”A Feast for Crows”, “A Dance with Dragons”] for book in books { print(book) } In this example, the for-in loop iterates over each element in the books array and prints it title. The loop automatically assigns each element to the book constant, allowing you to perform operations on it within the loop\u0026rsquo;s scope.\nThis loop is ideal for scenarios such as:\nEnumerating through an array to perform operations on each element. Iterating over a dictionary to access both the keys and values. Looping over a range of numbers or characters. While Loops: Executing Code Conditionally #The while loop executes a block of code repeatedly as long as a given condition remains true. This is particularly useful when you don\u0026rsquo;t know the exact number of iterations in advance. Here\u0026rsquo;s an example to illustrate its usage:\nvar count = 0 while count \u0026lt; 5 { print(\u0026#34;Count: \\(count)\u0026#34;) count += 1 } In this example, the while loop will continue executing as long as the count variable is less than 5. It prints the current value of count and increments it by 1 in each iteration. Be cautious when using while loops to ensure that the condition eventually becomes false; otherwise, it can result in an infinite loop.\nConsider using the while loop in the following situations:\nRepeatedly performing an action until a specific condition is met. Implementing input validation and continuously asking for user input until valid data is provided. Interacting with external systems or processes that require continuous monitoring. Repeat-While Loop: Ensuring First Code Execution #The repeat-while loop is similar to the while loop, but with a crucial difference: the condition is evaluated at the end of the loop. This guarantees that the code block executes at least once, even if the condition is initially false. Here\u0026rsquo;s an example:\nvar number = 10 repeat { print(number) number -= 2 } while number \u0026gt; 0 In this example, the repeat-while loop prints the value of number and subtracts 2 from it until number becomes 0 or less. Unlike the while loop, the repeat-while loop executes the code block first and then checks the condition.\nIs suitable for scenarios like:\nImplementing menu-driven systems where you want to ensure execution before checking for user choices. Handling game logic where an action must be performed at least once before checking for game-ending conditions. Repeating an operation until a specific condition is met. Conclusion #Understanding flow control statements like for-in, while, and repeat-`while is fundamental for any iOS developer.\nThese statements enable you to control the program\u0026rsquo;s flow, iterate over collections, and execute code conditionally. By mastering these flow control statements, you\u0026rsquo;ll have the ability to build more efficient and dynamic iOS applications.\nUtilize these statements wisely, paying attention to loop termination conditions to avoid infinite loops. Keep exploring their capabilities and experimenting with different scenarios to enhance your programming skills.\nHappy coding! 👨🏻‍💻\n","date":"20 March 2023","permalink":"/blog/loops-swift/","section":"Blog","summary":"Iterating and performing repetitive tasks","title":"Exploring Loops in Swift"},{"content":"The collections are one of the most used data structure when you are programming so, it is extremely important know the different approach you dispose to work with them.\nCollection types are complex data types, and Swift allow use three collection types: Arrays, Sets and Dictionaries for manage related values.\nThe reliability of these collections is based on the types of values and keys that you can store. When you create an instance of a collection, you need to confirm the type of values that it manages. This means that: you cannot store different types that you previously defined, and you can be sure the type of data you will retrieve when you manage a collection.\nAlso, thanks to type inference, you can specify the type, or Swift will infere the type.\nCollection Mutability #As well as variables and constants, collections can be mutable or unmutable depending on how was created.\nIf you store an array, set or a dictionary in a variable, you can mutate the collection, because you can add, remove or change a single or multiple values in these collection.\nBut, if you store it in a constant, you cannot add new elements or modify the ones with was instantiated.\nDiferences between arrays, sets and dictionaries #Arrays are ordered collections, where duplications are allowed and values can be accessed by a numeric index (position in the array)\nSets are unordered collections where duplications are no allowed, and values can be iterated, but cannot be accesed by an index or key.\nDictionaries are unordered collections composed by key-value associations.\nFundamentals of different collection types #Arrays #If you want to create an empty array, you will need specify the data type. There are different ways to create an empty array, this a example.\nvar numbers = [Int]() But, if you want to create it with values, you don\u0026rsquo;t need specify the types. Next, you can see how to create an strings array\nvar tutorials = [\u0026#34;SwiftUI\u0026#34;, \u0026#34;Combine\u0026#34;, \u0026#34;AsyncAwait\u0026#34;] And, if you need to access to a value, you must indicate the position of the value in the array. But, remember that collections index starts by 0.\nlet firstCourse = tutorials[0] The above code will store \u0026ldquo;SwiftUI\u0026rdquo; in firstCourse constant.\nSets #Again, you will need specify data type for create an empty set.\nvar numbers = Set\u0026lt;Int\u0026gt;() Create a set with values, is similar to create an array but, in this case, you will need to specify that is a set to don\u0026rsquo;t create an array\nvar tutorials = [\u0026#34;SwiftUI\u0026#34;, \u0026#34;Combine\u0026#34;, \u0026#34;AsyncAwait\u0026#34;] But, in this case, as sets have not an index, you cannot use it to access to the data. At least, you can check if the value exists.\nvar swiftuiExists = tutorials.contains(\u0026#34;SwiftUI\u0026#34;) The above code wil store true in swiftuiExists variable\nDictionaries #And, lastly, you can create an empty dictionary specifying both the key type and the value type\nvar nameOfNumbers = [Int: String]() To create a dictionary with values, it is also similar to an array, but you have to write the key of each value. Remember that the keys must be uniques.\nvar requirements = [\u0026#34;View\u0026#34;:\u0026#34;SwiftUI\u0026#34;, \u0026#34;Database\u0026#34;:\u0026#34;CoreData\u0026#34;, \u0026#34;AugmentedReality\u0026#34;:\u0026#34;ARKit\u0026#34;] And, if you want to access to a value, you only need know the index\nlet database = requirements[\u0026#34;Database\u0026#34;] In next posts, I will write about useful methods in collection types to manage arrays, sets and dictionaries. Happy coding! 👨🏻‍💻\n","date":"6 March 2023","permalink":"/blog/swift-collection-types/","section":"Blog","summary":"Swift has three collection types to manage common values","title":"Swift Collection Types"},{"content":"This post is a complement for the previous one about Swift Strings.\nI real-world projects, you can store a lot of strings but, it is important that you know how to transform those strings, to display them according to your view.\nFor this reason, let\u0026rsquo;s see usual methods that you can use for it.\nCount characters #Because a String is a Collection of Characters, you can use a very common method in Arrays: count()\nEither you can use it in a constant/variable or in a String\nlet starWarsIntro = \u0026#34;A long time ago...\u0026#34; let numberOfCharacters = starWarsIntro.count() // numberOfCharacters value 18 let numberOfCharactersOfGreet = \u0026#34;Hello World!\u0026#34;.count() // numberOfCharactersOfGreet value is 12 Even you can combine values in the same String through String interpolation:\nlet plotTwist = \u0026#34;I am your father\u0026#34; print(\u0026#34;The number of character in \\(plotTwist) is \\(plotTwist).count()\u0026#34;) // It will print \u0026#34;The number of character in I am your father is 16\u0026#34; Insert or remove #Also it is important add or remove characters or substrings\nInsert #For insert, you can:\nInsert a character with the method .insert(_ newElement:at:) Insert a substring with the method .insert(contentsOf:at:) In at you will need to write a index. You can know more about indexes in Swift official Documentation - String Indices\nvar warning = \u0026#34;we have a problem\u0026#34; warning.insert(contentsOf: \u0026#34;Houston, \u0026#34;, at: warning.startIndex) print(warning) // It will print \u0026#34;Houston, we have a problem\u0026#34; Remove #Similar to insert, for remove Swift allow remove characters of substrings:\nRemove a character with the method .remove(:at:) Remove a substring with the method removeSubrange(_ bounds:) Be careful with don\u0026rsquo;t exit out of bounds\nvar greeting = \u0026#34;Hello World!\u0026#34; greeting.remove(at: greeting.index(before: greeting.endIndex)) print(greeting) // It will print \u0026#34;Hello World\u0026#34; Modify strings #Uppercase and lowercase #The methods that you can use for it are .uppercased(), .lowercased() or .capitalized()\nExamples:\nlet lordOfTheRings = \u0026#34;A ring to rule them all\u0026#34; print(lordOfTheRings.uppercased()) // It will print \u0026#34;A RING TO RULE THEM ALL\u0026#34; print(lordOfTheRings.lowercased()) // It will print \u0026#34;a ring to rule them all\u0026#34; print(lordOfTheRings.capitalized) // It will print \u0026#34;A Ring To Rule Them All\u0026#34; Extract a string to an array #For this goal you can use .components(separatedBy: \u0026quot; \u0026quot;)\nlet et = “E.T. phone home.” let etWords = et.components(separatedBy: \u0026#34; \u0026#34;) // etWords value is equal to [\u0026#34;E.T.\u0026#34;, \u0026#34;phone\u0026#34;, \u0026#34;home.\u0026#34;] Replacing occurrences #In this case, a useful method is .replacingOccurrences(of:, with:), you can replace a character or a string with another character or string\nlet darkKnight = \u0026#34;I am Batman\u0026#34; let coded = darkKnight.replacingOccurrences(of: \u0026#34;a\u0026#34;, with: \u0026#34;4\u0026#34;) // coded value is equal to \u0026#34;I 4m B4tm4n\u0026#34; Happy coding! 👨🏻‍💻\n","date":"20 February 2023","permalink":"/blog/useful-strings-methods-swift/","section":"Blog","summary":"Learn useful String methods in Swift to display data as you need","title":"Useful String Methods in Swift"},{"content":"When you save a text in a constant or a variable, your are saving a string in Swift. Furthermore, you can see a string as a serie of characters. For that reason, you can access to the content of a string in various ways, such as Collection (Array i.e.) of characters.\nInitialize a String #A string literal is a text writed with a double quote at beginning and at the end. So, if you need to save a text in a constant or a variable, you only must to assign a string literal to it.\nlet coach = \u0026#34;Ted Lasso\u0026#34; var team = \u0026#34;AFC Richmond\u0026#34; NOTE: It is fundamental remember that strings are case sensitive. So, \u0026ldquo;a simple string\u0026rdquo; it is different of \u0026ldquo;A simple string\u0026rdquo;.\nConcatenating strings #If you need to save the value of two strings in another constant or variable, you can concatenate it.\nIt is as easy as use the operator + between the two values when you have to assign it.\nlet name = \u0026#34;Michael\u0026#34; let lastName = \u0026#34;Scott\u0026#34; let funnyBoss = name + lastName Another way, it is to use the operator += to add text to a previous initialized string\nvar spy = \u0026#34;Bond\u0026#34; spy += \u0026#34;, James Bond\u0026#34; In the above example, the final value of spy is Bond, James Bond\nAnd, as a String is a Collection of characters, you can also use the method .append()\nvar greet = \u0026#34;Hello, world\u0026#34; greet.append(\u0026#34;!\u0026#34;) In the last code, greet value is Hello, world!\nString interpolation #But maybe the most used feature in Strings could be String interpolation. It allows use constants or variables values inside a string.\nIn this case, you can do it, writing the constant or variable name, inside parenthesis \u0026ldquo;()\u0026rdquo;, and starting with a backlash \u0026ldquo;\u0026quot;. That is \\(variableName)\nlet name = \u0026#34;Forest\u0026#34; let fullName = \u0026#34;Forest Gump\u0026#34; let introduction = \u0026#34;Hello, I am \\(name), \\(fullName)\u0026#34; The final value of introduction is \u0026quot;Hello, I am Forest, Forest Gump\u0026quot;\nMultiline String #Finishing (althought it is not used often in real world apps) maybe sometimes you need to save larger texts in a string, and it could be difficult read the value for others programmers o for yourself. In this case, you can use a multiline string.\nTo save a multiline string, you only need to write three quotation marks at the beginning, and finish with another three in a single line. For example:\nlet text = \u0026#34;\u0026#34;\u0026#34; To be, or not to be, that is the question: Whether \u0026#39;tis nobler in the mind to suffer The slings and arrows of outrageous fortune, Or to take arms against a sea of troubles, And by opposing end them? To die, to sleep; \u0026#34;\u0026#34;\u0026#34; First triple double quotes doesn\u0026rsquo;t need to be in a single line, but it helps to focus in text value.\nYou can see useful methods in the post [Useful String methods in Swift](../useful-strings-methods-swift) Happy coding! 👨🏻‍💻\n","date":"6 February 2023","permalink":"/blog/swift-strings/","section":"Blog","summary":"As other languages, Strings are a fundamental type that allows save text","title":"Swift Strings"},{"content":"Programming has been often for process numbers and obtain results so difficult to calculate for humans: universe distances, planet radius, pi…\nSo, is part of fundamental learning, in Swift in particular and in programming globally.\nThere are basically 2 types of numbers in Swift: Integers and Floating-Point numbers. Each one represents a different range and is used for different targets.\nIntegers #A integer number (also called int, for short) is possibly the most used number. We could say that it is the most simple, because has no fractional component.\nIt can be positive, zero, or negative. For example, integer numbers are: 5, -3, 99, -256…\nAlso, Swift provides signed and unsigned integers for 8,16, 32 and 64 bit. Following naming convention of C, the type of 8 bit unsigned number is UInt8, whereas 16 bit signed is Int16. But, is not frequently used in most of developed apps.\nIntegers range #It depends of bits number, but each one has a max and min number to store. You can check it in next list.\nUInt8: from 0 to 255 UInt16: from 0 to 65535 UInt32: from 0 to 4294967295 UInt64: from 0 to 18446744073709551615 Int8: from -128 to 127 Int16: from -32768 to 32767 Int32: from -2147483648 to 2147483647 Int64: from -9223372036854775808 to 9223372036854775807 But, if you don’t remember the values, you can use the methods .max or .min let minValue = Int.min //minValue is equal to let maxValue = Int.max //maxValue is equal to ```swift ## Floating-Point numbers Unlike integers, floating-point numbers has a fractional component. But, like integers, can be positive or negative. It exists two signed floating-point number types ### Double Double numbers represent a 64-bit floating-point number, and has a precision of at least 15 decimal digits. ### Float Float numbers represent a 32-bit floating-point number, and has a precision of at least 6 decimal digits. *** \u0026lt;br/\u0026gt; *NOTE: You will need Double or Float depending of multiple factors, but if either would be appropriated, Swift documentation recommends use Double.* Happy coding! 👨🏻‍💻 ","date":"30 January 2023","permalink":"/blog/numbers-in-swift/","section":"Blog","summary":"Programming has been often for process numbers and obtain results so difficult to calculate for humans","title":"Numbers in Swift"},{"content":"Programming is a way to manage data, and usually, you need save multiple values temporally: to manage it after other operations, to display it…\nFor this matter, as another programming languages, Swift is able to store values in constants and variables.\nThanks to constant and variables you are able to associate a name that you choose to a value.\nConstants #A constant value is saved in a memory space, and it can’t be modified. After a value is established in a constant, it remains immutable.\nHow to declare a constant #To declare a constant you must start with reserved word let, followed by a name you choose. Then, you must can use the operator ‘=‘ and assign a value.\nIn the next example, ‘let’ is the reserved word for constants, survivor the name of the constant, and the value that is assigned to the constant ‘survivor’ is “Jack Shepard”.\nlet survivor = “Jack Shepard” The value is between double quotes because is a String value type. You can read about Strings in official documentation: Strings and Characters\nDo you know why Swift use let instead const or similar as another languages? It comes from the mathematics world, where they say things like:\nlet x be equal to 5\nVariables #A variable is a value that you can modify after have been declared. So, is a mutable value.\nHow to declare a variable #To declare a variable, the structure is the same as a constant, but you must use the reserved word var\nThen, for declare a variable you must write\nvar videogame = “Metal Gear Solid” Ok but, if we want to change a var value, how should we do it? Easy, you only need assign a new value, and don’t write the reserved word var\nvideogame = “Uncharted” Naming a constant, variable or value #You can use almost any character for a name of constant or variable, including Unicode characters. It means that you can use for example emojis\nBut it is something that a I wouldn’t recommend. Why? Because the name of a constant or a variable, should explain without any doubt what is stored within.\nFor example, which one explain what means the value 10?\nlet times = 10 let numberOfTimesIHaveSeenBackToTheFutureTrilogy = 10 In second case is easier to know\nConclusion #So, don’t worry about numbers of characters for the name. It is more recommended use a large (but descriptive ) name than use another shorter that doesn’t specify what stores. And, nowadays, IDE’s are in charge to autocomplete names, it won’t be difficult write them 😉\nHappy coding! 👨🏻‍💻\n","date":"16 January 2023","permalink":"/blog/constants-and-variables-swift/","section":"Blog","summary":"How to save and manage data values in Swift","title":"Constants and Variables to Save Values in Swift"},{"content":"Hi! I am very happy today, because I have refactored my blog 😉\nThis is not my first experience writing in my blog but, 2022 was a year with changes and new challenges in my working life so, I decided restart my blog to align it with what I am doing day by day.\nFor this reason, this is my first post, but only in this new version of my blog.\nAbout me #If I have to talk about me in a sentence, I like to say that I am a passionate about programming and tech world.\nNowadays, I work as iOS Developer at Hiberus, a global consultancy company founded in Spain, but growing quickly and opening new offices in places such as Berlín, London, México DF or Miami.\nBut, my work experience have been mainly focused in IT. Besides programming, I have previous experience working as QA or DevOps engineer.\nRecently, because I\u0026rsquo;m a enthusiastic user of Apple products, I decided to learn Swift, and specialize in their ecosystem development. Not only for iOS devices, but for MacOS or the rest of Apple operating systems.\nMy personal life #I was born in Valencia (Spain), where I live, at 80’s, the age of Spectrum, Atari and the first Sega\u0026rsquo;s or Nintendo videoconsoles. So, I grow up and enjoyed play videogames with my Sega Megadrive, watch cartoons as He-man, Dragon Ball or Captain Tsubasa.\nI\u0026rsquo;m the proud father of Lucas 👶🏻, my 3 years son that became the home CEO, and the proud husband of Lorena, the best life companion that I could have. A wonderfull woman, with a special power to treat with the childhood (And with me 😅)\nNowadays, I spend my non-working hours with my family or my hobbies, such as: enjoying TV Series, watching Formula 1, reading or playing chess.\nWhy I write in this blog #Knowledge #The first reason (and the most important) is for learning. I think that there are 3 levels of knowledge:\n1st: When someone teach you something, or you learn it watching a video or reading a book 2nd: When you are able to do what you have learned 3rd: When you are able to teach someone what you know. And, for this reason, write in a blog help me to learn teaching others.\nTo help #The second one, is helping others what today I love: programming. I think that everybody’s like help others, and also, this my way to extend the help that I receive from others.\nExpress my opinion #Another reason is, as iOS Developer, I need to have a deep understand about the Apple ecosystem so, this will be a place to organize my thoughts about the news, products, events as WWDC… but ever focused in coding\nPractice english #And the last reason, (but no less important), practice to write tech documentation in English. My native language is Spanish, but globalization and remote working has opened a lot of opportunities. And English is today the key language for learn and work.\nIf you wanna know more about me, feel free to check my social media links (see the footer)\nSo, I hope you enjoy my posts! 🙂\n","date":"2 January 2023","permalink":"/blog/my-new-first-post/","section":"Blog","summary":"Who I am and why I have relaunch my blog","title":"My (New) First Post"},{"content":"My profesional life #If I have to talk about me in a sentence, I like to say that I am a passionate about programming and tech world.\nI currently work as an iOS Developer at Openbank, the online bank of Grupo Santander, which has apps used by millions of people across Europe and the Americas.\nBut, my work experience have been mainly focused in IT. Besides programming, I have previous experience working as QA or DevOps engineer.\nRecently, because I\u0026rsquo;m a enthusiastic user of Apple products, I decided to learn Swift, and specialize in their ecosystem development. Not only for iOS devices, but for MacOS or the rest of Apple operating systems.\nMy personal life #I was born in Valencia (Spain), where I live actually. and I was born at 80’s, the age of Spectrum, Atari and the first Sega\u0026rsquo;s or Nintendo videoconsoles. So, I grow up and enjoyed play videogames with my Sega Megadrive, watch cartoons as He-man, Dragon Ball or Captain Tsubasa.\nI’m the proud father of Lucas and Vega — the tiny royals who now run our home, and the husband of Lorena, the best life companion that I could have. A wonderfull woman, with a special power to treat with the childhood (And with me 😅)\nNowadays, I spend my non-working hours with my family or my hobbies, such as: enjoying TV Series or watching Formula 1 races.\n","date":null,"permalink":"/about/","section":"Oscar Moreno | iOS Developer ","summary":"\u003ch3 id=\"my-profesional-life\" class=\"relative group\"\u003eMy profesional life \u003cspan class=\"absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100\"\u003e\u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\" style=\"text-decoration-line: none !important;\" href=\"#my-profesional-life\" aria-label=\"Anchor\"\u003e#\u003c/a\u003e\u003c/span\u003e\u003c/h3\u003e\u003cp\u003eIf I have to talk about me in a sentence, I like to say that I am a passionate about programming and tech world.\u003c/p\u003e\n\u003cp\u003eI currently work as an iOS Developer at \u003ca href=\"https://www.openbank.com\" target=\"_blank\" rel=\"noreferrer\"\u003eOpenbank\u003c/a\u003e, the online bank of \u003ca href=\"https://santander.com\" target=\"_blank\" rel=\"noreferrer\"\u003eGrupo Santander\u003c/a\u003e, which has apps used by millions of people across Europe and the Americas.\u003c/p\u003e\n\u003cp\u003eBut, my work experience have been mainly focused in IT. Besides programming, I have previous experience working as QA or DevOps engineer.\u003c/p\u003e","title":"About"},{"content":"You can reach me in social media at:\n@oscarmorenodev\nOscar Moreno\nOr feel free to contact me at oscar@oscarmoreno.com\n","date":null,"permalink":"/contact/","section":"Oscar Moreno | iOS Developer ","summary":"\u003cp\u003eYou can reach me in social media at:\u003c/p\u003e\n\u003cp\u003e\n\n  \u003cspan class=\"icon relative inline-block align-text-bottom\"\u003e\n    \u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 512 512\"\u003e\u003cpath fill=\"currentColor\" d=\"M389.2 48h70.6L305.6 224.2 487 464H345L233.7 318.6 106.5 464H35.8L200.7 275.5 26.8 48H172.4L272.9 180.9 389.2 48zM364.4 421.8h39.1L151.1 88h-42L364.4 421.8z\"/\u003e\u003c/svg\u003e\n\n  \u003c/span\u003e\n\n \u003ca href=\"https://x.com/oscarmorenodev\" target=\"_blank\" rel=\"noreferrer\"\u003e@oscarmorenodev\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\n\n  \u003cspan class=\"icon relative inline-block align-text-bottom\"\u003e\n    \u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 448 512\"\u003e\u003cpath fill=\"currentColor\" d=\"M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z\"/\u003e\u003c/svg\u003e\n\n  \u003c/span\u003e\n\n \u003ca href=\"https://linkedin.com/in/oscarmorenodev\" target=\"_blank\" rel=\"noreferrer\"\u003eOscar Moreno\u003c/a\u003e\u003c/p\u003e","title":"Contact"},{"content":"One email. One essential. Every week. Looking for a Swift newsletter that saves you time and gives you the most important update of the week?\nOne Swift Thing is for you.\nEach week, I check the best Swift newsletters —covering Swift, SwiftUI, Xcode, tools, productivity and more— and pick just one article. The one I think is most useful for Apple developers.\n🧭 Why only one thing? Because learning one thing every week is better than reading a lot once and then nothing for months.\nOne Swift Thing is a simple Swift newsletter to help you keep learning without stress.\n💡 What if I have more time? I recommend subscribing to more Swift newsletters if you can. I do that too — there’s lots of great content out there.\nBut if you don’t have time to read everything, or don’t want to decide what to read…\nThat’s why I made this Swift newsletter.\n✅ What you’ll get 📌 The most relevant article, once a week. 🧠 Context on why I chose it and what you’ll learn. ✉️ Delivered every Monday. 🚫 No long lists. 🎯 Who is it for? Apple developers with little time. People who want to keep learning, slowly but often. Anyone who doesn’t want to miss the most useful update from the Swift world. 📩 Subscribe for free Just one thing. Once a week.\nA simple Swift newsletter made for busy Apple devs.\nOne Swift Thing * indica que es obligatorio Dirección de email * /* real people should not fill this in and expect good things - do not remove this or risk form bot signups */ 🔒 100% private. I won’t share your email with anyone.\n🔁 Unsubscribe anytime.\n","date":null,"permalink":"/newsletter/","section":"Oscar Moreno | iOS Developer ","summary":"\u003ch2 id=\"one-email-one-essential-every-week\" class=\"relative group\"\u003eOne email. One essential. Every week. \u003c/h2\u003e\u003cp\u003eLooking for a \u003cstrong\u003eSwift newsletter\u003c/strong\u003e that saves you time and gives you the most important update of the week?\u003cbr\u003e\n\u003cstrong\u003eOne Swift Thing\u003c/strong\u003e is for you.\u003c/p\u003e\n\u003cp\u003eEach week, I check the best Swift newsletters —covering Swift, SwiftUI, Xcode, tools, productivity and more— and pick \u003cstrong\u003ejust one article\u003c/strong\u003e. The one I think is most useful for Apple developers.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"-why-only-one-thing\" class=\"relative group\"\u003e🧭 Why only one thing? \u003c/h2\u003e\u003cp\u003eBecause learning one thing every week is better than reading a lot once and then nothing for months.\u003cbr\u003e\n\u003cstrong\u003eOne Swift Thing\u003c/strong\u003e is a simple \u003cstrong\u003eSwift newsletter\u003c/strong\u003e to help you keep learning without stress.\u003c/p\u003e","title":"One Swift Thing"},{"content":"I collect usage data using Google analytics for the purposes of visualizing the traffic on this website.\nAll data is anonymized and I do not sell or share any data with third parties.\nIf you choose to deny, no info will be collected whatsoever.\n","date":null,"permalink":"/privacy/","section":"Oscar Moreno | iOS Developer ","summary":"\u003cp\u003eI collect usage data using Google analytics for the purposes of visualizing the traffic on this website.\u003c/p\u003e\n\u003cp\u003eAll data is anonymized and I do not sell or share any data with third parties.\u003c/p\u003e\n\u003cp\u003eIf you choose to deny, no info will be collected whatsoever.\u003c/p\u003e","title":"Privacy"},{"content":"","date":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags"}]